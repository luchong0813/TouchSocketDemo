<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TouchSocket</name>
    </assembly>
    <members>
        <member name="T:TouchSocket.Core.ByteBlock">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Int32,System.Boolean)">
            <summary>
             构造函数
            </summary>
            <param name="byteSize"></param>
            <param name="equalSize"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Byte[])">
            <summary>
            实例化一个已知内存的对象。且该内存不会被回收。
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Ratio">
            <summary>
            扩容增长比，默认为1.5，
            min：1.5
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Buffer">
            <summary>
            字节实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanRead">
            <summary>
            仅当内存块可用，且<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>>0时为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanReadLen">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.ByteBlock.Len"/>与<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanReadLength">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.ByteBlock.Len"/>与<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanSeek">
            <summary>
            支持查找
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanWrite">
            <summary>
            可写入
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Capacity">
            <summary>
            容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.FreeLength">
            <summary>
            空闲长度，准确掌握该值，可以避免内存扩展，计算为<see cref="P:TouchSocket.Core.ByteBlock.Capacity"/>与<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Holding">
            <summary>
            表示持续性持有，为True时，Dispose将调用无效。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Len">
            <summary>
            Int真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Length">
            <summary>
            真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Pos">
            <summary>
            int型流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Using">
            <summary>
            使用状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.AbsoluteDispose">
            <summary>
            直接完全释放，游离该对象，然后等待GC
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Clear">
            <summary>
            清空所有内存数据
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Flush">
            <summary>
            无实际效果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Read(System.Byte[])">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Read(System.Byte[]@,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadByte">
            <summary>
            从当前流位置读取一个<see cref="T:System.Byte"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Reset">
            <summary>
            将内存块初始化到刚申请的状态。
            <para>仅仅重置<see cref="P:TouchSocket.Core.ByteBlock.Position"/>和<see cref="P:TouchSocket.Core.ByteBlock.Length"/>属性。</para>
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            设置流位置
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Seek(System.Int32)">
            <summary>
            移动游标
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SeekToEnd">
            <summary>
            设置游标到末位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SeekToStart">
            <summary>
            设置游标到首位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            重新设置容量
            </summary>
            <param name="size">新尺寸</param>
            <param name="retainedData">是否保留元数据</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetHolding(System.Boolean)">
            <summary>
            设置持续持有属性，当为True时，调用Dispose会失效，表示该对象将长期持有，直至设置为False。
            当为False时，会自动调用Dispose。
            </summary>
            <param name="holding"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetLength(System.Int64)">
            <summary>
            设置实际长度
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToArray(System.Int32,System.Int32)">
            <summary>
            从指定位置转化到指定长度的有效内存
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToArray">
            <summary>
            转换为有效内存
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToArray(System.Int32)">
            <summary>
            从指定位置转化到有效内存
            </summary>
            <param name="offset"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString">
            <summary>
            转换为UTF-8字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString(System.Int32,System.Int32)">
            <summary>
            转换为UTF-8字符
            </summary>
            <param name="offset">偏移量</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString(System.Int32)">
            <summary>
            转换为UTF-8字符
            </summary>
            <param name="offset">偏移量</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Byte[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBytesPackage">
            <summary>
            从当前流位置读取一个独立的<see cref="T:System.Byte"/>数组包
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.TryReadBytesPackageInfo(System.Int32@,System.Int32@)">
            <summary>
            尝试获取数据包信息，方便从Buffer操作数据
            </summary>
            <param name="pos"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBytesPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入一个独立的<see cref="T:System.Byte"/>数组包，值可以为null。
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBytesPackage(System.Byte[])">
            <summary>
            写入一个独立的<see cref="T:System.Byte"/>数组包。值可以为null。
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt32(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int32"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Int32,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int32"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt16(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int16"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Int16,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int16"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt64(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int64"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Int64,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int64"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBoolean">
            <summary>
            从当前流位置读取一个<see cref="T:System.Boolean"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Boolean)">
            <summary>
            写入<see cref="T:System.Boolean"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Byte)">
            <summary>
            写入<see cref="T:System.Byte"/>值
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadString">
            <summary>
            从当前流位置读取一个<see cref="T:System.String"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.String)">
            <summary>
            写入<see cref="T:System.String"/>值。值可以为null，或者空。
            <para>注意：该操作不具备通用性，读取时必须使用ReadString。或者得先做出判断，由默认端序的int32值标识，具体如下：</para>
            <list type="bullet">
            <item>小于0，表示字符串为null</item>
            <item>等于0，表示字符串为""</item>
            <item>大于0，表示字符串在utf-8编码下的字节长度。</item>
            </list>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteString(System.String,System.Text.Encoding)">
            <summary>
            写入<see cref="T:System.String"/>值。值必须为有效值。可通用解析。
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadChar(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Char"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Char,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Char"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDouble(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Double"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Double,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Double"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadFloat(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Single"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.Single,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Single"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt16(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt16"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.UInt16,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt16"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt32(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt32"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.UInt32,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt32"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt64(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt64"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.UInt64,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt64"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadIsNull">
            <summary>
            从当前流位置读取一个标识值，判断是否为null。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteIsNull``1(``0)">
            <summary>
            判断该值是否为Null，然后写入标识值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteNotNull">
            <summary>
            写入一个标识非Null值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteNull">
            <summary>
            写入一个标识Null值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadPackage``1">
            <summary>
            读取一个指定类型的包
            </summary>
            <typeparam name="TPackage"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WritePackage``1(``0)">
            <summary>
            以包进行写入。允许null值。
            读取时调用<see cref="M:TouchSocket.Core.ByteBlock.ReadPackage``1"/>，解包。或者先判断<see cref="M:TouchSocket.Core.ByteBlock.ReadIsNull"/>，然后自行解包。
            </summary>
            <typeparam name="TPackage"></typeparam>
            <param name="package"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDateTime">
            <summary>
            从当前流位置读取一个<see cref="T:System.DateTime"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.DateTime)">
            <summary>
            写入<see cref="T:System.DateTime"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadTimeSpan">
            <summary>
            从当前流位置读取一个<see cref="T:System.TimeSpan"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.TimeSpan)">
            <summary>
            写入<see cref="T:System.TimeSpan"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadObject``1(TouchSocket.Core.SerializationType)">
            <summary>
             从当前流位置读取一个泛型值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="serializationType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteObject(System.Object,TouchSocket.Core.SerializationType)">
            <summary>
            写入<see cref="T:System.Object"/>值
            </summary>
            <param name="value"></param>
            <param name="serializationType"></param>
        </member>
        <member name="T:TouchSocket.Core.ByteBlockExtensions">
            <summary>
            ByteBlock扩展
            </summary>
        </member>
        <member name="T:TouchSocket.Core.BytePool">
            <summary>
            字节池
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.Default">
            <summary>
            默认的内存池实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.AutoZero">
            <summary>
            回收内存时，自动归零
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.Disabled">
            <summary>
            表示内存池是否可用。
            <para>当业务太轻量级，且要求超高并发时（千万数量级别），可禁用内存池。</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.KeyCapacity">
            <summary>
            键容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.MaxBlockSize">
            <summary>
            单个块最大值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.MaxSize">
            <summary>
            允许的内存池最大值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.MinBlockSize">
            <summary>
            单个块最小值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.AddSizeKey(System.Int32)">
            <summary>
            添加尺寸键
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.Clear">
            <summary>
            清理
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.ContainsSizeKey(System.Int32)">
            <summary>
            确定是否包含指定尺寸键
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetAllSizeKeys">
            <summary>
            获取所以内存键
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetByteBlock(System.Int32,System.Boolean)">
            <summary>
            获取ByteBlock
            </summary>
            <param name="byteSize">长度</param>
            <param name="equalSize">要求长度相同</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetByteBlock(System.Int32)">
            <summary>
            获取ByteBlock
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetByteCore(System.Int32,System.Boolean)">
            <summary>
            获取内存核心。获取的核心可以不用归还。
            如果要调用<see cref="M:TouchSocket.Core.BytePool.Recycle(System.Byte[])"/>归还，切记不要有持久性引用。
            </summary>
            <param name="byteSize"></param>
            <param name="equalSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetPoolSize">
            <summary>
            获取内存池容量
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetValueByteBlock(System.Int32,System.Boolean)">
            <summary>
             获取ValueByteBlock
            </summary>
            <param name="byteSize"></param>
            <param name="equalSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetValueByteBlock(System.Int32)">
            <summary>
            获取ValueByteBlock
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.Recycle(System.Byte[])">
            <summary>
            回收内存核心。
            <para>注意：回收的内存，必须百分百确定该对象没有再被其他引用。不然这属于危险操作。</para>
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:TouchSocket.Core.BytePool.RemoveSizeKey(System.Int32)">
            <summary>
            移除尺寸键
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.SetBlockSize(System.Int32,System.Int32)">
            <summary>
            设置内存块参数
            </summary>
            <param name="minBlockSize"></param>
            <param name="maxBlockSize"></param>
        </member>
        <member name="T:TouchSocket.Core.BytesQueue">
            <summary>
            字节块集合
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytesQueue.FullSize">
            <summary>
            占用空间
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesQueue.TryGet(System.Byte[]@)">
            <summary>
            获取当前实例中的空闲的Block
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesQueue.Add(System.Byte[])">
            <summary>
            向当前集合添加Block
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="T:TouchSocket.Core.IByteBlock">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Buffer">
            <summary>
            字节实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.CanRead">
            <summary>
            仅当内存块可用，且<see cref="P:TouchSocket.Core.IByteBlock.CanReadLen"/>>0时为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.FreeLength">
            <summary>
            剩余的长度，准确掌握该值，可以避免内存扩展，计算为<see cref="P:TouchSocket.Core.IByteBlock.Capacity"/>与<see cref="P:TouchSocket.Core.IByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.CanReadLen">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.IByteBlock.Len"/>与<see cref="P:TouchSocket.Core.IByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.CanReadLength">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.IByteBlock.Len"/>与<see cref="P:TouchSocket.Core.IByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Capacity">
            <summary>
            容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Holding">
            <summary>
            表示持续性持有，为True时，Dispose将调用无效。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Len">
            <summary>
            Int真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Length">
            <summary>
            真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Pos">
            <summary>
            int型流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Using">
            <summary>
            使用状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.AbsoluteDispose">
            <summary>
            直接完全释放，游离该对象，然后等待GC
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Clear">
            <summary>
            清空所有内存数据
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Reset">
            <summary>
            将内存块初始化到刚申请的状态。
            <para>仅仅重置<see cref="P:TouchSocket.Core.IByteBlock.Position"/>和<see cref="P:TouchSocket.Core.IByteBlock.Length"/>属性。</para>
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadByte">
            <summary>
            读取一个字节
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            重新设置容量
            </summary>
            <param name="size">新尺寸</param>
            <param name="retainedData">是否保留元数据</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetHolding(System.Boolean)">
            <summary>
            设置持续持有属性，当为True时，调用Dispose会失效，表示该对象将长期持有，直至设置为False。
            当为False时，会自动调用Dispose。
            </summary>
            <param name="holding"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetLength(System.Int64)">
            <summary>
            设置实际长度
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToArray(System.Int32,System.Int32)">
            <summary>
            从指定位置转化到指定长度的有效内存
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ValueByteBlock">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Int32,System.Boolean)">
            <summary>
             构造函数
            </summary>
            <param name="byteSize"></param>
            <param name="equalSize"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Byte[])">
            <summary>
            实例化一个已知内存的对象。且该内存不会被回收。
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Create(System.Int32,System.Boolean)">
            <summary>
            创建一个来自于内存池的成员。
            </summary>
            <param name="byteSize"></param>
            <param name="equalSize"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Ratio">
            <summary>
            扩容增长比，默认为1.5，
            min：1.5
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Buffer">
            <summary>
            字节实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanRead">
            <summary>
            仅当内存块可用，且<see cref="P:TouchSocket.Core.ValueByteBlock.CanReadLen"/>>0时为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanReadLen">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.ValueByteBlock.Len"/>与<see cref="P:TouchSocket.Core.ValueByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanReadLength">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.ValueByteBlock.Len"/>与<see cref="P:TouchSocket.Core.ValueByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanSeek">
            <summary>
            支持查找
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanWrite">
            <summary>
            可写入
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Capacity">
            <summary>
            容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.FreeLength">
            <summary>
            空闲长度，准确掌握该值，可以避免内存扩展，计算为<see cref="P:TouchSocket.Core.ValueByteBlock.Capacity"/>与<see cref="P:TouchSocket.Core.ValueByteBlock.Pos"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Holding">
            <summary>
            表示持续性持有，为True时，Dispose将调用无效。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Len">
            <summary>
            Int真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Length">
            <summary>
            真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Pos">
            <summary>
            int型流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Using">
            <summary>
            使用状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.AbsoluteDispose">
            <summary>
            直接完全释放，游离该对象，然后等待GC
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Clear">
            <summary>
            清空所有内存数据
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Dispose">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Read(System.Byte[])">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Read(System.Byte[]@,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadByte">
            <summary>
            从当前流位置读取一个<see cref="T:System.Byte"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Reset">
            <summary>
            将内存块初始化到刚申请的状态。
            <para>仅仅重置<see cref="P:TouchSocket.Core.ValueByteBlock.Position"/>和<see cref="P:TouchSocket.Core.ValueByteBlock.Length"/>属性。</para>
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            设置流位置
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Seek(System.Int32)">
            <summary>
            移动游标
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SeekToEnd">
            <summary>
            设置游标到末位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SeekToStart">
            <summary>
            设置游标到首位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            重新设置容量
            </summary>
            <param name="size">新尺寸</param>
            <param name="retainedData">是否保留元数据</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetHolding(System.Boolean)">
            <summary>
            设置持续持有属性，当为True时，调用Dispose会失效，表示该对象将长期持有，直至设置为False。
            当为False时，会自动调用Dispose。
            </summary>
            <param name="holding"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetLength(System.Int64)">
            <summary>
            设置实际长度
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToArray(System.Int32,System.Int32)">
            <summary>
            从指定位置转化到指定长度的有效内存
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToArray">
            <summary>
            转换为有效内存
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToArray(System.Int32)">
            <summary>
            从指定位置转化到有效内存
            </summary>
            <param name="offset"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString">
            <summary>
            转换为UTF-8字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString(System.Int32,System.Int32)">
            <summary>
            转换为UTF-8字符
            </summary>
            <param name="offset">偏移量</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString(System.Int32)">
            <summary>
            转换为UTF-8字符
            </summary>
            <param name="offset">偏移量</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Byte[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBytesPackage">
            <summary>
            从当前流位置读取一个独立的<see cref="T:System.Byte"/>数组包
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.TryReadBytesPackageInfo(System.Int32@,System.Int32@)">
            <summary>
            尝试获取数据包信息，方便从Buffer操作数据
            </summary>
            <param name="pos"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBytesPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入一个独立的<see cref="T:System.Byte"/>数组包，值可以为null。
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBytesPackage(System.Byte[])">
            <summary>
            写入一个独立的<see cref="T:System.Byte"/>数组包。值可以为null。
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt32(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int32"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Int32,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int32"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt16(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int16"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Int16,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int16"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt64(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int64"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Int64,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Int64"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBoolean">
            <summary>
            从当前流位置读取一个<see cref="T:System.Boolean"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Boolean)">
            <summary>
            写入<see cref="T:System.Boolean"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Byte)">
            <summary>
            写入<see cref="T:System.Byte"/>值
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadString">
            <summary>
            从当前流位置读取一个<see cref="T:System.String"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.String)">
            <summary>
            写入<see cref="T:System.String"/>值。值可以为null，或者空。
            <para>注意：该操作不具备通用性，读取时必须使用ReadString。或者得先做出判断，由默认端序的int32值标识，具体如下：</para>
            <list type="bullet">
            <item>小于0，表示字符串为null</item>
            <item>等于0，表示字符串为""</item>
            <item>大于0，表示字符串在utf-8编码下的字节长度。</item>
            </list>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteString(System.String,System.Text.Encoding)">
            <summary>
            写入<see cref="T:System.String"/>值。值必须为有效值。可通用解析。
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadChar(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Char"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Char,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Char"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDouble(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Double"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Double,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Double"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadFloat(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.Single"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.Single,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.Single"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt16(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt16"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.UInt16,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt16"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt32(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt32"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.UInt32,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt32"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt64(System.Nullable{System.Boolean})">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt64"/>值
            </summary>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.UInt64,System.Nullable{System.Boolean})">
            <summary>
            写入<see cref="T:System.UInt64"/>值
            </summary>
            <param name="value"></param>
            <param name="bigEndian">是否为指定大端编码。允许true（大端），false（小端），null（默认端序）三种赋值。默认为null。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadIsNull">
            <summary>
            从当前流位置读取一个标识值，判断是否为null。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteIsNull``1(``0)">
            <summary>
            判断该值是否为Null，然后写入标识值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteNotNull">
            <summary>
            写入一个标识非Null值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteNull">
            <summary>
            写入一个标识Null值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDateTime">
            <summary>
            从当前流位置读取一个<see cref="T:System.DateTime"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.DateTime)">
            <summary>
            写入<see cref="T:System.DateTime"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadTimeSpan">
            <summary>
            从当前流位置读取一个<see cref="T:System.TimeSpan"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.TimeSpan)">
            <summary>
            写入<see cref="T:System.TimeSpan"/>值
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadObject``1(TouchSocket.Core.SerializationType)">
            <summary>
             从当前流位置读取一个泛型值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="serializationType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteObject(System.Object,TouchSocket.Core.SerializationType)">
            <summary>
            写入<see cref="T:System.Object"/>值
            </summary>
            <param name="value"></param>
            <param name="serializationType"></param>
        </member>
        <member name="T:TouchSocket.Core.CacheEntry`2">
            <summary>
            缓存实体
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CacheEntry`2.#ctor(`0)">
            <summary>
            缓存实体
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.CacheEntry`2.#ctor(`0,`1)">
            <summary>
            缓存实体
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Duration">
            <summary>
            有效区间。如果想长期有效，请使用<see cref="F:System.TimeSpan.Zero"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Key">
            <summary>
            键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.UpdateTime">
            <summary>
            更新时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.CacheManagementExtensions">
            <summary>
            CacheExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CacheManagementExtensions.AddCache``2(TouchSocket.Core.ICache{``0,``1},``0,``1,System.Int32)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Core.ICache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})"/>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="cacheManagement"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="duration"></param>
        </member>
        <member name="M:TouchSocket.Core.CacheManagementExtensions.SetCache``2(TouchSocket.Core.ICache{``0,``1},``0,``1,System.Int32)">
            <summary>
             <inheritdoc cref="M:TouchSocket.Core.ICache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})"/>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="cacheManagement"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="duration"></param>
        </member>
        <member name="T:TouchSocket.Core.ICache`2">
            <summary>
            缓存键值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            添加缓存。当缓存存在时，不会添加成功。
            </summary>
            <param name="entity">缓存实体</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.AddCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            添加缓存。当缓存存在时，不会添加成功。
            </summary>
            <param name="entity">缓存实体</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ClearCache">
            <summary>
            清空所有缓存
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ClearCacheAsync">
            <summary>
            清空所有缓存
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ContainsCache(`0)">
            <summary>
            判断缓存是否存在，且在生命周期内。
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ContainsCacheAsync(`0)">
            <summary>
            判断缓存是否存在，且在生命周期内。
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            设置缓存，不管缓存存不存在，都会添加。
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.SetCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            设置缓存，不管缓存存不存在，都会添加。
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.GetCache(`0)">
            <summary>
            获取指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.GetCacheAsync(`0)">
            <summary>
            获取指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.RemoveCache(`0)">
            <summary>
            移除指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.RemoveCacheAsync(`0)">
            <summary>
            移除指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.ICacheEntry">
            <summary>
            缓存实体接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry.Duration">
            <summary>
            有效区间。如果想长期有效，请使用<see cref="F:System.TimeSpan.Zero"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry.UpdateTime">
            <summary>
            更新时间
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ICacheEntry`2">
            <summary>
            缓存实体接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry`2.Key">
            <summary>
            键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry`2.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemoryCache`2">
            <summary>
            一个简单的内存缓存
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.#ctor">
            <summary>
             一个简单的内存缓存
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemoryCache`2.Remove">
            <summary>
            当每个元素超时被移除时触发。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.AddCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ClearCache">
            <summary>
            清空所有缓存
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ClearCacheAsync">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ContainsCache(`0)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ContainsCacheAsync(`0)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetCache(`0)">
            <summary>
            获取缓存实体。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetCacheAsync(`0)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetEnumerator">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCache(`0,TouchSocket.Core.ICacheEntry{`0,`1}@)">
            <summary>
            移除缓存
            </summary>
            <param name="key"></param>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCache(`0)">
            <summary>
            移除缓存
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCacheAsync(`0)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.SetCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.TryGetValue(`0,`1@,System.Boolean)">
            <summary>
            获取对应的值。
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="update"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentDoublyDictionary`2">
            <summary>
            安全双向字典
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentDoublyDictionary`2.KeyToValue">
            <summary>
            由键指向值得集合
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentDoublyDictionary`2.ValueToKey">
            <summary>
            由值指向键的集合
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryAdd(`0,`1)">
            <summary>
             尝试将指定的键和值添加到字典中。
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryRemoveFromKey(`0,`1@)">
            <summary>
            由键尝试移除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryRemoveFromValue(`1,`0@)">
            <summary>
            由值尝试移除
            </summary>
            <param name="value"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryGetFromKey(`0,`1@)">
            <summary>
            由键获取到值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryGetFromValue(`1,`0@)">
            <summary>
            由值获取到键
            </summary>
            <param name="value"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentList`1">
            <summary>
            线程安全的List，其基本操作和List一致。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            构造函数
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Count">
            <summary>
            元素数量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.IsReadOnly">
            <summary>
            是否为只读
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Item(System.Int32)">
            <summary>
            获取索引元素
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Add(`0)">
            <summary>
            添加元素
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Clear">
            <summary>
            清空所有元素
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Contains(`0)">
            <summary>
            是否包含某个元素
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.CopyTo(`0[],System.Int32)">
            <summary>
            复制到
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.GetEnumerator">
            <summary>
            返回迭代器
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            返回迭代器组合
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0)">
            <summary>
            索引
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Insert(System.Int32,`0)">
            <summary>
            插入
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Remove(`0)">
            <summary>
            移除元素
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveAt(System.Int32)">
            <summary>
            按索引移除
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Capacity">
            <summary>
            获取或设置容量
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="item"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <param name="item"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})"/>
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Find(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLast(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ForEach(System.Action{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})"/>
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Reverse">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Reverse"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Comparison{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})"/>
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ToArray">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ToArray"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.TrimExcess">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.TrimExcess"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Ternary`3">
            <summary>
            三元组合
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.Ternary`3.#ctor(`0,`1,`2)">
            <summary>
            三元组合
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Key1">
            <summary>
            首键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Key2">
            <summary>
            次键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentMultiDictionary`3">
            <summary>
            线程安全的双键字典
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentMultiDictionary`3.Count">
            <summary>
            元素数量。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.Clear">
            <summary>
            清空所有元素。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.ContainsKey(`1)">
            <summary>
            是否包含指定键。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.ContainsKey(`0)">
            <summary>
            是否包含指定键。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryAdd(`0,`1,`2)">
            <summary>
            尝试添加。
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryRemove(`0,`2@)">
            <summary>
            由首键删除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryRemove(`1,`2@)">
            <summary>
            由次键删除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryGetValue(`0,`2@)">
            <summary>
            由首键获取值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryGetValue(`1,`2@)">
            <summary>
            由次键获取值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IntelligentConcurrentQueue`1">
            <summary>
            智能安全队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="maxCount"></param>
        </member>
        <member name="P:TouchSocket.Core.IntelligentConcurrentQueue`1.MaxCount">
            <summary>
            允许的最大长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentConcurrentQueue`1.Count">
            <summary>
            长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.Enqueue(`0)">
            <summary>
            入队
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            出队
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IQueueData">
            <summary>
            队列数据
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IQueueData.Size">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="T:TouchSocket.Core.QueueDataBytes">
            <summary>
            传输字节
            </summary>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.CreateNew(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从指定内存创建一个新对象，且内存也为新创建。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.#ctor(System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Buffer">
            <summary>
            数据内存
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Offset">
            <summary>
            偏移
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Size">
            <summary>
            尺寸
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IntelligentDataQueue`1">
            <summary>
            智能数据安全队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.#ctor(System.Int64)">
            <summary>
            构造函数
            </summary>
            <param name="maxSize"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.ActualSize">
            <summary>
            实际尺寸
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.Free">
            <summary>
            是否有空位允许入队
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.MaxSize">
            <summary>
            允许的最大长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.OnQueueChanged">
            <summary>
            在队列修改时
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.OverflowWait">
            <summary>
            溢出等待
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.Timeout">
            <summary>
            超时时间。默认1000*30ms；
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.Clear(System.Action{`0})">
            <summary>
            清空队列
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.Enqueue(`0)">
            <summary>
            入队
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.TryDequeue(`0@)">
            <summary>
            出队
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TriggerQueue`1">
            <summary>
            触发器队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.#ctor">
            <summary>
             触发器队列
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.OnDequeue">
            <summary>
            出队列处理。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.OnError">
            <summary>
            发生错误
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.Sending">
            <summary>
            是否处于发送状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Enqueue(`0)">
            <summary>
            发送
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Dispose(System.Boolean)">
            <summary>
            释放
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.IgnoreCaseNameValueCollection">
            <summary>
            IgnoreCaseNameValueCollection
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IgnoreCaseNameValueCollection.#ctor">
            <summary>
            IgnoreCaseNameValueCollection
            </summary>
        </member>
        <member name="T:TouchSocket.Core.NameValueCollectionDebugView">
            <summary>
            NameValueCollectionDebugView
            </summary>
        </member>
        <member name="M:TouchSocket.Core.NameValueCollectionDebugView.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            NameValueCollectionDebugView
            </summary>
            <param name="nameValue"></param>
        </member>
        <member name="T:TouchSocket.Core.AppConfigBase">
            <summary>
            运行配置类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppConfigBase.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="fullPath"></param>
        </member>
        <member name="M:TouchSocket.Core.AppConfigBase.Save(System.Boolean,System.String@)">
            <summary>
            保存配置
            </summary>
            <param name="overwrite"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppConfigBase.Load(System.String@)">
            <summary>
            加载配置
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppConfigBase.GetDefault``1">
            <summary>
            获取默认配置。
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppConfigBase.GetNewDefault``1">
            <summary>
            获取默认配置，每次调用该方法时，都会重新加载配置。
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DateExtensions">
            <summary>
            DateExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DateExtensions.ConvertTime(System.DateTime@)">
            <summary>
            将时间转为毫秒级别的短整形
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DateExtensions.ConvertTime(System.DateTimeOffset@)">
            <summary>
            将时间转为毫秒级别的短整形
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DisposableObject">
            <summary>
            具有释放的对象。
            并未实现析构函数相关。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DisposableObject.m_disposedValue">
            <summary>
            判断是否已释放。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DisposableObject.DisposedValue">
            <summary>
            标识该对象是否已被释放
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DisposableObject.Dispose(System.Boolean)">
            <summary>
            调用释放，切换释放状态。
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.DisposableObject.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:TouchSocket.Core.EndianType">
            <summary>
            大小端类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.Little">
            <summary>
            小端模式
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.Big">
            <summary>
            大端模式
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ResultCode">
            <summary>
            结果类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Error">
            <summary>
            错误
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Exception">
            <summary>
            异常
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Success">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Fail">
            <summary>
            失败
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Overtime">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Canceled">
            <summary>
            操作取消
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FlowGate">
            <summary>
            流量控制
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FlowGate.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FlowGate.Maximum">
            <summary>
            最大值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FlowGate.MaximumPeriod">
            <summary>
            最长休眠周期。默认为5*1000ms.
            <para>当设置为5000时，假如设置的<see cref="P:TouchSocket.Core.FlowGate.Maximum"/>=10，而一次递增了100，则理应会休眠10s，但是会休眠5s。反之，如果设置1，则每秒周期都会清空。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FlowGate.AddCheckWait(System.Int32)">
            <summary>
            检测等待
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FlowGate.AddCheckWaitAsync(System.Int32)">
            <summary>
            检测等待
            </summary>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.GlobalEnvironment">
            <summary>
            全局环境设置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.GlobalEnvironment.OptimizedPlatforms">
            <summary>
            优化平台
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IResult">
            <summary>
            返回通知接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResult.ResultCode">
            <summary>
            是否成功
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IWrite">
            <summary>
            规范写端口，提供更多扩展
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IWrite.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.IWrite.Write(System.Byte[])">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:TouchSocket.Core.ReadLock">
            <summary>
            读取锁
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ReadLock.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            构造函数
            </summary>
            <param name="locks"></param>
        </member>
        <member name="M:TouchSocket.Core.ReadLock.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WriteLock">
            <summary>
            写入锁
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WriteLock.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            构造函数
            </summary>
            <param name="locks"></param>
        </member>
        <member name="M:TouchSocket.Core.WriteLock.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Mapper">
            <summary>
            映射数据
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map``1(System.Object)">
            <summary>
            简单映射
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map``2(``0)">
            <summary>
            简单映射
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map(System.Object,System.Type)">
            <summary>
            简单对象映射
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map(System.Object,System.Object)">
            <summary>
            简单对象映射
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.MapList``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            映射List
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.MapList``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            映射List
            </summary>
            <typeparam name="T1"></typeparam>
            <param name="list"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.Metadata">
            <summary>
            元数据键值对。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Metadata.#ctor">
            <summary>
            元数据键值对。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Add(System.String,System.String)">
            <summary>
            添加。如果键存在，将被覆盖。
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Package(TouchSocket.Core.ByteBlock)">
            <summary>
            打包
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Unpackage(TouchSocket.Core.ByteBlock)">
            <summary>
            解包
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Core.MetadataFastBinaryConverter">
            <summary>
            MetadataFastBinaryConverter
            </summary>
        </member>
        <member name="T:TouchSocket.Core.OptimizedPlatforms">
            <summary>
            优化平台
            </summary>
        </member>
        <member name="F:TouchSocket.Core.OptimizedPlatforms.None">
            <summary>
            无特殊优化
            </summary>
        </member>
        <member name="F:TouchSocket.Core.OptimizedPlatforms.Unity">
            <summary>
            针对Unity优化。
            一般来说，在unity2020及以下版本，中执行il2cpp时，需要设置该值。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Result">
            <summary>
            结果返回
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Success">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Default">
            <summary>
            初始状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.UnknownFail">
            <summary>
            未知失败
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Overtime">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Canceled">
            <summary>
            取消
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode"></param>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.IResult)">
            <summary>
            构造函数
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode"></param>
        </member>
        <member name="P:TouchSocket.Core.Result.ResultCode">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Result.Message">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Result.FromCanceled(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Canceled"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromError(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Error"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromException(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Exception"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromFail(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Overtime"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromOvertime(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Overtime"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromSuccess(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Success"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Result.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ResultBase">
            <summary>
            结果返回
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode"></param>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode"></param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.Result)">
            <summary>
            构造函数
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ResultBase.ResultCode">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ResultBase.Message">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ResultExtensions">
            <summary>
            ResultExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.IsSuccess(TouchSocket.Core.IResult)">
            <summary>
            是否成功。
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.NotSuccess(TouchSocket.Core.IResult)">
            <summary>
            是否没有成功。
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.ToResult(TouchSocket.Core.IResult)">
            <summary>
            转换为<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SnowflakeIDGenerator">
            <summary>
            雪花ID生成器(该代码来自网络)
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SnowflakeIDGenerator.SequenceMask">
            <summary>
            一微秒内可以产生计数，如果达到该值则等到下一微妙在进行生成
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIDGenerator.#ctor(System.Int64)">
            <summary>
            机器码
            </summary>
            <param name="workerId"></param>
        </member>
        <member name="P:TouchSocket.Core.SnowflakeIDGenerator.MaxWorkerId">
            <summary>
            最大机器ID
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIDGenerator.NextID">
            <summary>
            获取ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIDGenerator.tillNextMillis(System.Int64)">
            <summary>
            获取下一微秒时间戳
            </summary>
            <param name="lastTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIDGenerator.timeGen">
            <summary>
            生成当前时间戳
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.StringResStore">
            <summary>
            字符串资源字典
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringResStore.GetDescription(System.Enum,System.Object[])">
            <summary>
            获取资源字符
            </summary>
            <param name="enum"></param>
            <param name="objs"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketBitConverter">
            <summary>
            将基数据类型转换为指定端的一个字节数组，
            或将一个字节数组转换为指定端基数据类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.BigEndian">
            <summary>
            以大端
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.LittleEndian">
            <summary>
            以小端
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.Default">
            <summary>
            以默认小端，可通过<see cref="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType"/>重新指定默认端。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType">
            <summary>
            默认大小端切换。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.#ctor(TouchSocket.Core.EndianType)">
            <summary>
            构造函数
            </summary>
            <param name="endianType"></param>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.EndianType">
            <summary>
            指定大小端。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.IsSameOfSet">
            <summary>
            判断当前系统是否为设置的大小端
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt16)">
            <summary>
            转换为指定端2字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            转换为指定端模式的2字节转换为UInt16数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt64)">
            <summary>
            转换为指定端8字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的Ulong数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Boolean)">
            <summary>
            转换为指定端1字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的bool数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Char)">
            <summary>
            转换为指定端2字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的Char数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int16)">
            <summary>
            转换为指定端2字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的Short数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int32)">
            <summary>
            转换为指定端4字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的int数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int64)">
            <summary>
            转换为指定端8字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的long数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt32)">
            <summary>
            转换为指定端4字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的Uint数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Single)">
            <summary>
            转换为指定端4字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的float数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Double)">
            <summary>
            转换为指定端8字节
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的double数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketCoreUtility">
            <summary>
            常量
            </summary>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketConfig">
            <summary>
            配置文件基类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConfig.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketConfig.Container">
            <summary>
            IOC容器。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketConfig.IsUsePlugin">
            <summary>
            使用插件
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketConfig.PluginsManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConfig.SetContainer(TouchSocket.Core.IContainer)">
            <summary>
            设置注入容器。
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConfig.SetPluginsManager(TouchSocket.Core.IPluginsManager)">
            <summary>
            设置PluginsManager
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConfig.UsePlugin">
            <summary>
            启用插件
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketCoreConfigExtension">
            <summary>
            TouchSocketCoreConfigExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigurePlugins(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Core.IPluginsManager})">
            <summary>
            配置插件。
            </summary>
            <param name="config"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigureContainer(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Core.IContainer})">
            <summary>
            配置容器注入。
            </summary>
            <param name="config"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.BytesConverter">
            <summary>
            字节类转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesConverter.#ctor">
            <summary>
            字节类转换器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.JsonBytesToClassConverter">
            <summary>
            Json字节转到对应类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonBytesToClassConverter.Order">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonBytesToClassConverter.TryConvertFrom(System.Byte[],System.Type,System.Object@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonBytesToClassConverter.TryConvertTo(System.Object,System.Byte[]@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IConverter`1">
            <summary>
            转换器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IConverter`1.Order">
            <summary>
            转换器执行顺序
            <para>该属性值越小，越靠前执行。值相等时，按添加先后顺序</para>
            <para>该属性效果，仅在<see cref="M:TouchSocket.Core.TouchSocketConverter`1.Add(TouchSocket.Core.IConverter{`0})"/>之前设置有效。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IConverter`1.TryConvertFrom(`0,System.Type,System.Object@)">
            <summary>
            尝试将源数据转换目标类型对象
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IConverter`1.TryConvertTo(System.Object,`0@)">
            <summary>
            尝试将目标类型对象转换源数据
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.StringConverter">
            <summary>
            String类型数据转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringConverter.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:TouchSocket.Core.StringToPrimitiveConverter">
            <summary>
            String值转换为基础类型。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.StringToPrimitiveConverter.Order">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringToPrimitiveConverter.TryConvertFrom(System.String,System.Type,System.Object@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringToPrimitiveConverter.TryConvertTo(System.Object,System.String@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonStringToClassConverter">
            <summary>
            Json字符串转到对应类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonStringToClassConverter.Order">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonStringToClassConverter.TryConvertFrom(System.String,System.Type,System.Object@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonStringToClassConverter.TryConvertTo(System.Object,System.String@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketConverter`1">
            <summary>
            转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.Add(TouchSocket.Core.IConverter{`0})">
            <summary>
            添加插件
            </summary>
            <param name="converter">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.Clear">
            <summary>
            清除所有转化器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.ConvertFrom(`0,System.Type)">
            <summary>
            将源数据转换目标类型对象
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.ConvertTo(System.Object)">
            <summary>
            将目标类型对象转换源数据
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.Remove(TouchSocket.Core.IConverter{`0})">
            <summary>
            移除插件
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConverter`1.Remove(System.Type)">
            <summary>
            移除插件
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:TouchSocket.Core.GZipDataCompressor">
            <summary>
            GZip压缩算法的压缩机
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IDataCompressor">
            <summary>
            数据压缩机接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IDataCompressor.Compress(System.ArraySegment{System.Byte})">
            <summary>
            压缩数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IDataCompressor.Decompress(System.ArraySegment{System.Byte})">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Crc">
            <summary>
            Crc相关。
            <para>该代码来源于网络</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc1(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-4/ITU    x4+x+1
             Poly: 0x03
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc2(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/EPC    x5+x3+1
             Poly: 0x09
             Init: 0x09
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc3(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/ITU    x5+x4+x2+1
             Poly: 0x15
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc4(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/USB    x5+x2+1
             Poly: 0x05
             Init: 0x1F
             Refin: true
             Refout: true
             Xorout: 0x1F
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc5(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-6/ITU    x6+x+1
             Poly: 0x03
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc6(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-7/MMC    x7+x3+1
             Poly: 0x09
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc7(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC8    x8+x2+x+1
             Poly: 0x07
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc8(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/ITU    x8+x2+x+1
             Poly: 0x07
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x55
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc9(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/MAXIM    x8+x5+x4+1
             Poly: 0x31
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc10(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/ROHC    x8+x2+x+1
             Poly: 0x07
             Init: 0xFF
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="F:TouchSocket.Core.Crc.table">
            Z1协议校验码计算
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc11(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Crc11
            </summary>
            <param name="buffer"></param>
            <param name="start"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc12(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-12    x16+x12+x5+1
             Poly: 0x80
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc13(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/CCITT    x16+x12+x5+1
             Poly: 0x1021
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc14(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/CCITT FALSE    x16+x12+x5+1
             Poly: 0x1021
             Init: 0xFFFF
             Refin: false
             Refout: false
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc15(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/DNP    x16+x13+x12+x11+x10+x8+x6+x5+x2+1
             Poly: 0x3D65
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc16(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/IBM    x16+x15+x2+1
             Poly: 0x8005
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc17(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/MAXIM    x16+x15+x2+1
             Poly: 0x8005
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc18(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/MODBUS    x16+x15+x2+1
             Poly: 0x8005
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc19(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/USB    x16+x15+x2+1
             Poly: 0x8005
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc20(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/X25    x16+x12+x5+1
             Poly: 0x1021
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc21(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/XMODEM    x16+x12+x5+1
             Poly: 0x1021
             Init: 0x0000
             Refin: false
             Refout: false
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc22(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC32    x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
             Poly: 0x04C11DB7
             Init: 0xFFFFFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFFFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc23(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC32/MPEG-2    x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
             Poly: 0x04C11DB7
             Init: 0xFFFFFFFF
             Refin: false
             Refout: false
             Xorout: 0x00000000
            *************************************************************************
        </member>
        <member name="T:TouchSocket.Core.GZip">
            <summary>
            Gzip操作类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(TouchSocket.Core.ByteBlock,System.Byte[],System.Int32,System.Int32)">
            <summary>
            压缩数据
            </summary>
            <param name="byteBlock"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(TouchSocket.Core.ByteBlock,System.Byte[])">
            <summary>
            压缩数据
            </summary>
            <param name="byteBlock"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            压缩数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.Byte[])">
            <summary>
            压缩数据
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(TouchSocket.Core.ByteBlock,System.Byte[],System.Int32,System.Int32)">
            <summary>
            解压数据
            </summary>
            <param name="byteBlock"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(TouchSocket.Core.ByteBlock,System.Byte[])">
            <summary>
            解压数据
            </summary>
            <param name="byteBlock"></param>
            <param name="data"></param>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(System.Byte[])">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.MD5">
            <summary>
            MD5相关操作类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.String)">
            <summary>
            从字符串获取MD5值
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从字节获取MD5值
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.Byte[])">
            <summary>
            从字节获取MD5值
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.VerifyMD5Hash(System.String,System.String)">
            <summary>
            验证MD5值。
            </summary>
            <param name="str"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DataSecurity">
            <summary>
            数据安全加密
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataSecurity.Keys">
            <summary>
            自定义加密密钥。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.EncryptDES(System.Byte[],System.String)">
            <summary>
            使用3DES加密
            </summary>
            <param name="data">待加密字节</param>
            <param name="encryptKey">加密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.DecryptDES(System.Byte[],System.String)">
            <summary>
            使用3DES解密
            </summary>
            <param name="data">待解密字节</param>
            <param name="encryptKey">解密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.StreamEncryptDES(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            使用3DES流数据加密。
            <para>注意：数据会从<see cref="P:System.IO.Stream.Position"/>开始</para>
            </summary>
            <param name="inStream"></param>
            <param name="outStream"></param>
            <param name="encryptKey">加密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.StreamDecryptDES(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            使用3DES流数据解密
            <para>注意：数据会从<see cref="P:System.IO.Stream.Position"/>开始</para>
            </summary>
            <param name="inStream"></param>
            <param name="outStream"></param>
            <param name="encryptKey">解密口令（长度为8）</param>
        </member>
        <member name="T:TouchSocket.Core.Swap">
            <summary>
            交换类。功能类似：a=1，b=2，交换后a=2，b=1。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Swap.Execute``1(``0@,``0@)">
            <summary>
            执行交换
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:TouchSocket.Core.XmlTool">
            <summary>
            xml主类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="path">文件路径，包含文件名</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.AttributeStorage(System.String,System.String,System.String)">
            <summary>
            单节点，单属性储存
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Attribute_name">属性名</param>
            <param name="Attribute_value">属性值</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.AttributeStorage(System.String,System.String[],System.String[])">
            <summary>
            单节点，多属性存储
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Attribute_name">属性集合</param>
            <param name="Attribute_value">属性值集合</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.AttributeStorage(System.String[],System.String[],System.String[])">
            <summary>
            单节点，单属性多集合存储
            </summary>
            <param name="NodeName">节点集合</param>
            <param name="Attribute_name">属性名集合</param>
            <param name="Attribute_value">属性值集合</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.AttributeStorage(System.String[],System.String[],System.Int32,System.String[][])">
            <summary>
            多节点，多属性，多集合存储
            </summary>
            <param name="NodeName">节点集合</param>
            <param name="Attribute_name">属性集合</param>
            <param name="AttributeNumber">每个节点的属性数量</param>
            <param name="Attribute_value">属性值集合</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.NodeStorage(System.String,System.String)">
            <summary>
            节点值存储
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Text">文本</param>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchNode(System.String)">
            <summary>
            通过节点取值
            </summary>
            <param name="NodeName">节点名</param>
            <returns>取值失败返回null</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchNumber(System.String,System.String)">
            <summary>
            查找数字
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Attribute_name">属性名</param>
            <returns>取值失败返回0</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchWords(System.String,System.String)">
            <summary>
            查找属性值
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Attribute_name">属性名</param>
            <returns>取值失败返回null</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchBoolean(System.String,System.String)">
            <summary>
            查找布尔值
            </summary>
            <param name="NodeName">节点名</param>
            <param name="Attribute_name">属性值</param>
            <returns>返回查找结果，查询失败返回false</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchWords(System.String[],System.String[])">
            <summary>
            查找属性值集合
            </summary>
            <param name="NodeName">节点名集合</param>
            <param name="Attribute_name">属性名集合</param>
            <returns>文件不在返回null，单个属性不在返回“空”</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchWords(System.String,System.String,System.String)">
            <summary>
            通过确切属性值，属性名，查找其他属性值
            </summary>
            <param name="Attribute_name1">已知属性名</param>
            <param name="Attribute_value">已知属性值</param>
            <param name="Attribute_name2">待查属性名</param>
            <returns>待查属性值</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchAllAttributes(System.String)">
            <summary>
            查找节点的所有属性值
            </summary>
            <param name="NodeName">节点 名</param>
            <returns>返回查找键值对，查询失败返回null</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.SearchBoolean(System.String,System.String,System.String)">
            <summary>
            通过确切属性值，属性名，查找其他属性的布尔值
            </summary>
            <param name="Attribute_name1">已知属性名</param>
            <param name="Attribute_value">已知属性值</param>
            <param name="Attribute_name2">待查属性名</param>
            <returns>待查布尔值，失败返回false</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.RemoveNode(System.String)">
            <summary>
            按节点名移除节点
            </summary>
            <param name="NodeName">节点名</param>
            <returns>是否移除成功</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.RemoveNode(System.String,System.String)">
            <summary>
            按确切的属性名，属性值删除节点
            </summary>
            <param name="Attribute_name">属性名</param>
            <param name="Attribute_value">属性值</param>
            <returns>是否移除成功</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.RemoveNode(System.String,System.DateTime)">
            <summary>
            如果节点中有日期属性，把日期之前的节点都删除
            </summary>
            <param name="Attribute_name">属性名</param>
            <param name="dateTime">截止时间</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.NodeExist(System.String)">
            <summary>
            判断节点是否存在
            </summary>
            <param name="NodeName">节点名</param>
            <returns>返回结果</returns>
        </member>
        <member name="M:TouchSocket.Core.XmlTool.RemoveAllNode">
            <summary>
            删除所有节点，不包含子节点
            </summary>
            <returns>返回删除是否成功</returns>
        </member>
        <member name="T:TouchSocket.Core.DataValidationAttribute">
            <summary>
            依赖属性数据验证
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyTypeAttribute">
            <summary>
            指定依赖类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyTypeAttribute.#ctor(TouchSocket.Core.DependencyType)">
            <summary>
            初始化一个依赖类型。当确定某个类型仅以某种特定方式注入时，可以过滤不必要的注入操作，以提高效率。
            </summary>
            <param name="type">可以叠加位域</param>
        </member>
        <member name="P:TouchSocket.Core.DependencyTypeAttribute.Type">
            <summary>
            支持类型。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyType">
            <summary>
            依赖注入类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Constructor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Property">
            <summary>
            属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Method">
            <summary>
            方法
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyInjectAttribute">
            <summary>
            指定依赖类型，构造函数，可用于构造函数，属性，方法。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor(System.Object[])">
            <summary>
            初始化一个依赖注入对象。并且指定构造参数。
            <para>当创建时也指定参数时，会覆盖该设定。</para>
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor(System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="resolveNullIfNoRegistered"></param>
        </member>
        <member name="P:TouchSocket.Core.DependencyInjectAttribute.Ps">
            <summary>
            构造参数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyInjectAttribute.ResolveNullIfNoRegistered">
            <summary>
            如果没有注册则返回为空
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyParamterInjectAttribute">
            <summary>
            参数，属性指定性注入。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyParamterInjectAttribute.#ctor(System.String,System.Object[])">
            <summary>
            参数，属性指定性注入。
            </summary>
            <param name="key"></param>
            <param name="ps"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyParamterInjectAttribute.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            类型，参数，属性指定性注入。
            </summary>
            <param name="type"></param>
            <param name="key"></param>
            <param name="ps"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyParamterInjectAttribute.#ctor(System.Type,System.Object[])">
            <summary>
            类型，参数，属性指定性注入。
            </summary>
            <param name="type"></param>
            <param name="ps"></param>
        </member>
        <member name="P:TouchSocket.Core.DependencyParamterInjectAttribute.Type">
            <summary>
            注入类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyParamterInjectAttribute.#ctor(System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="resolveNullIfNoRegistered"></param>
        </member>
        <member name="P:TouchSocket.Core.DependencyParamterInjectAttribute.Key">
            <summary>
            指定键。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Container">
            <summary>
            IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Container.#ctor">
            <summary>
            初始化一个IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Container.GetEnumerator">
            <summary>
            返回迭代器
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Container.IsRegistered(System.Type,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Container.Register(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.Container.Resolve(System.Type,System.Object[],System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="fromType"></param>
            <param name="ps"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Container.Unregister(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.Container.Create(System.Type,System.Object[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="toType"></param>
            <param name="ops"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ContainerExtension">
            <summary>
            IContainerExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``2(TouchSocket.Core.IContainer,``1)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton(TouchSocket.Core.IContainer,System.Object)">
            <summary>
            注册单例
            </summary>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``2(TouchSocket.Core.IContainer,System.String,``1)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton(TouchSocket.Core.IContainer,System.Type,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="container"></param>
            <param name="fromType"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``1(TouchSocket.Core.IContainer,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton(TouchSocket.Core.IContainer,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="container"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``1(TouchSocket.Core.IContainer,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton(TouchSocket.Core.IContainer,System.Type,System.Type,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="container"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``2(TouchSocket.Core.IContainer)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterSingleton``2(TouchSocket.Core.IContainer,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterTransient``2(TouchSocket.Core.IContainer)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterTransient``1(TouchSocket.Core.IContainer)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterTransient``2(TouchSocket.Core.IContainer,System.String)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterTransient(TouchSocket.Core.IContainer,System.Type,System.Type,System.String)">
            <summary>
            注册临时映射
            </summary>
            <param name="container"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterScoped``2(TouchSocket.Core.IContainer)">
            <summary>
            注册区域映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterScoped``1(TouchSocket.Core.IContainer)">
            <summary>
            注册区域映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterScoped``2(TouchSocket.Core.IContainer,System.String)">
            <summary>
            注册区域映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.RegisterScoped(TouchSocket.Core.IContainer,System.Type,System.Type,System.String)">
            <summary>
            注册区域映射
            </summary>
            <param name="container"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.Resolve``1(TouchSocket.Core.IContainerProvider,System.Object[],System.String)">
            <summary>
            创建类型对应的实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
            <param name="ps"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.Resolve``1(TouchSocket.Core.IContainerProvider)">
            <summary>
            创建类型对应的实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.Resolve``1(TouchSocket.Core.IContainerProvider,System.String)">
            <summary>
            创建类型对应的实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.Unregister(TouchSocket.Core.IContainer,System.Type,System.String)">
            <summary>
            移除注册信息
            </summary>
            <param name="container"></param>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ContainerExtension.Unregister``1(TouchSocket.Core.IContainer,System.String)">
            <summary>
            移除注册信息
            </summary>
            <param name="container"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DependencyDescriptor">
            <summary>
            注入依赖对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type,System.Object)">
            <summary>
            初始化一个单例实例。
            </summary>
            <param name="fromType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type,System.Type,TouchSocket.Core.Lifetime)">
            <summary>
            初始化一个完整的服务注册
            </summary>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="lifetime"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type)">
            <summary>
            初始化一个简单的的服务描述
            </summary>
            <param name="fromType"></param>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ImplementationFactory">
            <summary>
            实例化工厂委托
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ToType">
            <summary>
            实例类型
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ToInstance">
            <summary>
            实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.Lifetime">
            <summary>
            生命周期
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.FromType">
            <summary>
            注册类型
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IDependencyObject">
            <summary>
            依赖对象接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.GetValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            获取依赖注入的值
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.HasValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            是否有值。
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.RemoveValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            重置属性值。
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.SetValue``1(TouchSocket.Core.IDependencyProperty{``0},``0)">
            <summary>
            设置依赖注入的值
            </summary>
            <param name="dp"></param>
            <param name="value"></param>
        </member>
        <member name="T:TouchSocket.Core.DependencyObject">
            <summary>
            依赖项对象.
            线程安全。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.GetValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            获取依赖注入的值
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.HasValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.RemoveValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            移除设定值。
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.SetValue``1(TouchSocket.Core.IDependencyProperty{``0},``0)">
            <summary>
            设置依赖注入的值
            </summary>
            <param name="dp"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.IDependencyProperty`1">
            <summary>
            IDependencyProperty
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:TouchSocket.Core.IDependencyProperty`1.DefauleValue">
            <summary>
            默认值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IDependencyProperty`1.Name">
            <summary>
            属性名称
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IDependencyProperty`1.Owner">
            <summary>
            所属类型
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyProperty`1">
            <summary>
            依赖项属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyProperty`1.m_name">
            <summary>
            属性名称
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyProperty`1.m_owner">
            <summary>
            所属类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.#ctor">
            <summary>
            依赖项属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyProperty`1.DefauleValue">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyProperty`1.Name">
             <summary>
            <inheritdoc/>
             </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyProperty`1.Owner">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.Register(System.String,System.Type,`0)">
            <summary>
            注册依赖项属性。
            <para>依赖属性的默认值，可能会应用于所有的<see cref="T:TouchSocket.Core.IDependencyObject"/></para>
            </summary>
            <param name="propertyName"></param>
            <param name="owner"></param>
            <param name="value">依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IContainer">
            <summary>
            注入容器接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IContainer.Register(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            添加类型描述符。
            </summary>
            <param name="key"></param>
            <param name="descriptor"></param>
        </member>
        <member name="M:TouchSocket.Core.IContainer.Unregister(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            移除注册信息。
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IContainerProvider">
            <summary>
            具有区域效应的容器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IContainerProvider.Resolve(System.Type,System.Object[],System.String)">
            <summary>
            创建目标类型的对应实例。
            </summary>
            <param name="fromType"></param>
            <param name="ps"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IContainerProvider.IsRegistered(System.Type,System.String)">
            <summary>
            判断某类型是否已经注册
            </summary>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Lifetime">
            <summary>
            注入项的生命周期。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Lifetime.Singleton">
            <summary>
            单例对象
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Lifetime.Scoped">
            <summary>
            以<see cref="T:TouchSocket.Core.IContainerProvider"/>接口为区域实例单例。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Lifetime.Transient">
            <summary>
            瞬时对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.TimeMeasurer">
            <summary>
            时间测量器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TimeMeasurer.Run(System.Action)">
            <summary>
            开始运行
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TimeMeasurer.RunAsync(System.Action)">
            <summary>
            异步执行
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketEventArgs">
            <summary>
            TouchSocketEventArgs
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation">
            <summary>
            是否允许操作
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketEventArgs.Handled">
            <summary>
            是否已处理
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MessageNotFoundException">
            <summary>
            未找到消息异常类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageNotFoundException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="mes"></param>
        </member>
        <member name="T:TouchSocket.Core.MessageRegisteredException">
            <summary>
            消息已注册
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageRegisteredException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="mes"></param>
        </member>
        <member name="T:TouchSocket.Core.BytesExtension">
            <summary>
            BytesExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesExtension.ToBase64(System.Byte[])">
            <summary>
            转Base64。
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesExtension.IndexOfInclude(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引包含数组。
            <para>
            例如：在{0,1,2,3,1,2,3}中搜索{1,2}，则会返回list:[2,5]，均为最后索引的位置。
            </para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesExtension.IndexOfFirst(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引第一个包含数组的索引位置，例如：在{0,1,2,3,1,2,3}中索引{2,3}，则返回3。
            <para>如果目标数组为null或长度为0，则直接返回offset的值</para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesExtension.ByBytesToHexString(System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            字节数组转16进制字符
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="splite"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DictionaryExtension">
            <summary>
            DictionaryExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DictionaryExtension.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            移除满足条件的项目。
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="pairs"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DictionaryExtension.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            尝试添加
            </summary>
            <typeparam name="Tkey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="tkey"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DictionaryExtension.AddOrUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            尝试添加
            </summary>
            <typeparam name="Tkey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="tkey"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DictionaryExtension.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            获取值。如果键不存在，则返回默认值。
            </summary>
            <typeparam name="Tkey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dictionary"></param>
            <param name="tkey"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.StringExtension">
            <summary>
            StringExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.IsNullOrEmpty(System.String)">
            <summary>
            IsNullOrEmpty
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.IsNullOrWhiteSpace(System.String)">
            <summary>
            IsNullOrWhiteSpace
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.HasValue(System.String)">
            <summary>
            当不为null，且不为空。
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.TryParseToType(System.String,System.Type,System.Object@,System.Char[])">
            <summary>
              将字符串格式化成指定的数据类型
            </summary>
            <param name="str"></param>
            <param name="type"></param>
             <param name="value"></param>
             <param name="splits"></param>
               <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.HitStringCount(System.String,System.String)">
            <summary>
            判断字符串compare 在 input字符串中出现的次数
            </summary>
            <param name="input">源字符串</param>
            <param name="compare">用于比较的字符串</param>
            <returns>字符串compare 在 input字符串中出现的次数</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ParseToType(System.String,System.Type)">
            <summary>
            将字符转换为对应的基础类型类型。
            </summary>
            <param name="value"></param>
            <param name="destinationType">目标类型必须为基础类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.SplitFirst(System.String,System.Char)">
            <summary>
            只按第一个匹配项分割
            </summary>
            <param name="str"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.Split(System.String,System.String)">
            <summary>
            按字符串分割
            </summary>
            <param name="str"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.SplitLast(System.String,System.Char)">
            <summary>
            只按最后一个匹配项分割
            </summary>
            <param name="str"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.Format(System.String,System.Object[])">
            <summary>
            按格式填充
            </summary>
            <param name="str"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ToSha1(System.String,System.Text.Encoding)">
            <summary>
            转换为SHA1。
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ToUTF8Bytes(System.String)">
            <summary>
            转换为UTF-8数据，效果等于<see cref="P:System.Text.Encoding.UTF8"/>
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByHexStringToBytes(System.String,System.String)">
            <summary>
            将16进制的字符转换为数组。
            </summary>
            <param name="hexString"></param>
            <param name="splite"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByHexStringToInt32(System.String)">
            <summary>
            将16进制的字符转换为int32。
            </summary>
            <param name="hexString"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByBase64ToBytes(System.String)">
            <summary>
            从Base64转到数组。
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SystemExtensions">
            <summary>
            为System提供扩展。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.SafeDispose(System.IDisposable)">
            <summary>
            安全性释放（不用判断对象是否为空）。不会抛出任何异常。
            </summary>
            <param name="dis"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.GetAttribute``1(System.Enum)">
            <summary>
            获取自定义attribute
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumObj"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.ToGMTString(System.DateTime,System.String)">
            <summary>
            格林尼治标准时间
            </summary>
            <param name="dt"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.Clear``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            清除所有成员
            </summary>
            <typeparam name="T"></typeparam>
            <param name="queue"></param>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.Clear``1(System.Collections.Concurrent.ConcurrentQueue{``0},System.Action{``0})">
            <summary>
            清除所有成员
            </summary>
            <typeparam name="T"></typeparam>
            <param name="queue"></param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.GetBit(System.Byte,System.Int16)">
            <summary>
            获取字节中的指定Bit的值
            </summary>
            <param name="this">字节</param>
            <param name="index">Bit的索引值(0-7)</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtensions.SetBit(System.Byte,System.Int16,System.Int32)">
            <summary>
            设置字节中的指定Bit的值
            </summary>
            <param name="this">字节</param>
            <param name="index">Bit的索引值(0-7)</param>
            <param name="bitvalue">Bit值(0,1)</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SystemNetExtension">
            <summary>
            其他扩展
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SystemNetExtension.GetIP(System.Net.EndPoint)">
            <summary>
            从<see cref="T:System.Net.EndPoint"/>中获得IP地址。
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemNetExtension.GetPort(System.Net.EndPoint)">
            <summary>
            从<see cref="T:System.Net.EndPoint"/>中获得Port。
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TaskExtension">
            <summary>
            TaskExtension
            </summary>
        </member>
        <member name="T:TouchSocket.Core.TupleExtension">
            <summary>
            元组扩展
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TupleExtension.GetTupleElementNames(System.Reflection.ParameterInfo)">
            <summary>
            获取元组的名称列表。
            </summary>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TypeExtension">
            <summary>
            TypeExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TypeExtension.GetRefOutType(System.Type)">
            <summary>
            获取类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TypeExtension.GetDefault(System.Type)">
            <summary>
            获取默认值
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TypeExtension.IsStatic(System.Type)">
            <summary>
            判断是否为静态类。
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TypeExtension.IsStruct(System.Type)">
            <summary>
            判断为结构体
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TypeExtension.IsNullableType(System.Type)">
            <summary>
            判断该类型是否为可空类型
            </summary>
            <param name="theType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.BlockReader">
            <summary>
            阻塞式读取。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReader.CanRead">
            <summary>
            可读
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReader.ReadTimeout">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.PeekRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            阻塞读取，但不会移动游标。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            阻塞读取。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.Input(System.Byte[],System.Int32,System.Int32)">
            <summary>
            传输输入.
            当以length为0结束。
            否则读取端会超时。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.InputComplate">
            <summary>
            输入完成
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.BlockReader.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="T:TouchSocket.Core.BlockReadStream">
            <summary>
            阻塞式单项读取流。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.Write(System.Byte[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:TouchSocket.Core.BlockReadStream.CanReadLen">
            <summary>
            还剩余的未读取的长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReadStream.CanSeek">
            <summary>
            不可使用
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReadStream.Length">
            <summary>
            不可使用
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReadStream.Position">
            <summary>
             不可使用
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BlockReadStream.ReadTimeout">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            阻塞读取。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            不可使用
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.SetLength(System.Int64)">
            <summary>
            不可使用
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.BlockReadStream.Input(System.Byte[],System.Int32,System.Int32)">
            <summary>
            传输输入.
            必须以length为0结束。读取端会超时。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ConsoleAction">
            <summary>
            控制台行为
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="helpOrder">帮助信息指令，如："h|help|?"</param>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.ShowAll">
            <summary>
            显示所有注册指令
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConsoleAction.HelpOrder">
            <summary>
            帮助信息指令
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.Add(System.String,System.String,System.Action)">
            <summary>
            添加
            </summary>
            <param name="order">指令，多个指令用“|”分割</param>
            <param name="description">描述</param>
            <param name="action"></param>
        </member>
        <member name="E:TouchSocket.Core.ConsoleAction.OnException">
            <summary>
            执行异常
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.Run(System.String)">
            <summary>
            执行，返回值仅表示是否有这个指令，异常获取请使用<see cref="E:TouchSocket.Core.ConsoleAction.OnException"/>
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.VAction.#ctor(System.String,System.String,System.Action)">
            <summary>
            构造函数
            </summary>
            <param name="action"></param>
            <param name="description"></param>
            <param name="fullOrder"></param>
        </member>
        <member name="T:TouchSocket.Core.DirectoryUtility">
            <summary>
            DirectoryUtility
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DirectoryUtility.CopyDirectory(System.String,System.String)">
            <summary>
            复制文件夹及文件
            </summary>
            <param name="sourceFolder">原文件路径</param>
            <param name="destFolder">目标文件路径</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DirectoryUtility.GetDirectories(System.String)">
            <summary>
            获取文件夹下的一级文件夹目录名称，不含子文件夹。
            </summary>
            <param name="sourceFolder"></param>
        </member>
        <member name="T:TouchSocket.Core.FilePool">
            <summary>
            文件池。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetAllPaths">
            <summary>
            获取所有的路径。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForRead(System.String)">
            <summary>
            加载文件为读取流
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForRead(System.IO.FileInfo)">
            <summary>
            加载文件为读取流
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForWrite(System.String)">
            <summary>
            加载文件为写流
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForWrite(System.IO.FileInfo)">
            <summary>
            加载文件为写流
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageStream(System.String)">
            <summary>
            获取一个可读可写的Stream对象。
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageStream(System.IO.FileInfo)">
            <summary>
            获取一个可读可写的Stream对象。
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReader(System.String)">
            <summary>
            获取一个文件读取访问器
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReader(System.IO.FileInfo)">
            <summary>
            获取一个文件读取访问器
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReferenceCount(System.String)">
            <summary>
            获取引用次数。
            </summary>
            <param name="path">必须是全路径。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetWriter(System.String)">
            <summary>
            获取一个文件写入访问器
            </summary>
            <param name="path">路径</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetWriter(System.IO.FileInfo)">
            <summary>
            获取一个文件写入访问器
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.LoadFileForCacheRead(System.String)">
            <summary>
            加载文件为缓存读取流
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.TryReleaseFile(System.String,System.Int32)">
            <summary>
            减少引用次数，并尝试释放流。
            </summary>
            <param name="path"></param>
            <param name="delayTime">延迟释放时间。当设置为0时，立即释放,单位毫秒。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Core.FileStorage">
            <summary>
            文件存储器。在该存储器中，读写线程安全。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.#ctor(System.IO.FileInfo,System.IO.FileAccess)">
            <summary>
            初始化一个文件存储器。在该存储器中，读写线程安全。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.AccessTime">
            <summary>
            最后访问时间。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.AccessTimeout">
            <summary>
            访问超时时间。默认10s
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Cache">
            <summary>
            是否为缓存型。为false时，意味着该文件句柄正在被该程序占用。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileAccess">
            <summary>
            访问属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileInfo">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileStream">
            <summary>
            文件流。
            一般情况下，请不要直接访问该对象。否则有可能会产生不可预测的错误。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Length">
            <summary>
            文件长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Path">
            <summary>
            文件路径
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Reference">
            <summary>
            引用次数。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.TryCreateCacheFileStorage(System.String,TouchSocket.Core.FileStorage@,System.String@)">
            <summary>
            创建一个只读的、已经缓存的文件信息。该操作不会占用文件句柄。
            </summary>
            <param name="path"></param>
            <param name="fileStorage"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Flush">
            <summary>
            写入时清空缓存区
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Read(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            从指定位置，读取数据到缓存区。线程安全。
            </summary>
            <param name="stratPos"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.TryReleaseFile(System.Int32)">
            <summary>
            减少引用次数，并尝试释放流。
            </summary>
            <param name="delayTime">延迟释放时间。当设置为0时，立即释放,单位毫秒。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Write(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            从指定位置，写入数据到存储区。线程安全。
            </summary>
            <param name="stratPos"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Core.FileStorageReader">
            <summary>
            文件读取器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            构造函数
            </summary>
            <param name="fileStorage"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageReader.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageReader.Pos">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageReader.Position">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据到缓存区
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.FileStorageStream">
            <summary>
            FileStorageStream。非线程安全。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            构造函数
            </summary>
            <param name="fileStorage"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanRead">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanSeek">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanWrite">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.Length">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.Position">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Flush">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.SetLength(System.Int64)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.FileStorageWriter">
            <summary>
            文件写入器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            构造函数
            </summary>
            <param name="fileStorage"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Write(System.Byte[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageWriter.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageWriter.Pos">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageWriter.Position">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.SeekToEnd">
            <summary>
            移动Pos到流末尾
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据到缓存区
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.FileUtility">
            <summary>
            文件操作
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetDuplicateFileName(System.String)">
            <summary>
            获取不重复文件名。
            <para>例如：New.txt已存在时，会返回New(1).txt</para>
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetDuplicateDirectoryName(System.String)">
            <summary>
            获取不重复文件夹名称.
            <para>例如：NewDir已存在时，会返回NewDir(1)</para>
            </summary>
            <param name="dirName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.ToFileLengthString(System.Int64)">
            <summary>
            转化为文件大小的字符串，类似10B，10Kb，10Mb，10Gb。
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileMD5(System.String)">
            <summary>
            获取文件MD5
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamMD5(System.IO.Stream)">
            <summary>
            获取流MD5
            </summary>
            <param name="fileStream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileHash256(System.String)">
            <summary>
            获得文件Hash值
            </summary>
            <param name="filePath">文件路径</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamHash256(System.IO.Stream)">
            <summary>
            获得流Hash值
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileHash(System.String,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            获得文件Hash值
            </summary>
            <param name="filePath">文件路径</param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamHash(System.IO.Stream,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            获得流Hash值
            </summary>
            <param name="stream"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetIncludeFileNames(System.String)">
            <summary>
            获取仅当前文件夹中包含的文件名称，不含全路径。
            </summary>
            <param name="dirPath"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetRelativePath(System.String,System.String)">
            <summary>
            获取相对路径。
            </summary>
            <param name="relativeTo"></param>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.Delete(System.String)">
            <summary>
            删除路径文件
            </summary>
            <param name="path"></param>
        </member>
        <member name="T:TouchSocket.Core.WrapStream">
            <summary>
            包装的流。为避免该流释放时，内部流也会被释放的问题
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.#ctor(System.IO.Stream)">
            <summary>
            包装的流。为避免该流释放时，内部流也会被释放的问题
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanRead">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanSeek">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanWrite">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.Length">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.Position">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Flush">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.SetLength(System.Int64)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Close">
            <summary>
            没有关闭效果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Dispose(System.Boolean)">
            <summary>
            没有释放效果
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.ConsoleLogger">
            <summary>
            控制台日志记录器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleLogger.#ctor">
            <summary>
            初始化一个日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConsoleLogger.Default">
            <summary>
            默认的实例
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleLogger.WriteLog(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.EasyLogger">
            <summary>
            快捷日志
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.#ctor(System.Action{TouchSocket.Core.LogType,System.Object,System.String,System.Exception})">
            <summary>
            构造函数
            </summary>
            <param name="action">参数依次为：日志类型，触发源，消息，异常</param>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.#ctor(System.Action{System.String})">
            <summary>
            构造函数
            </summary>
            <param name="action">参数为日志消息输出。</param>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.WriteLog(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.FileLogger">
            <summary>
            文件日志记录器
            <para>会在指定目录下，生成logs文件夹，然后按[yyyy-MM-dd].log的形式，每日生成日志</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="rootPath">日志根目录</param>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.WriteLog(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.ILog">
            <summary>
            日志接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ILog.LogType">
            <summary>
            日志输出类型。
            当<see cref="M:TouchSocket.Core.ILog.Log(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)"/>的类型，在该设置之内时，才会真正输出日志。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ILog.Log(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            日志记录
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerBase">
            <summary>
            日志基类
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LoggerBase.All">
            <summary>
            全部的日志类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.#ctor">
            <summary>
            日志基类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoggerBase.LogType">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.Log(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.WriteLog(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            筛选日志后输出
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerContainerExtension">
            <summary>
            LoggerContainerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.SetLogger``1(TouchSocket.Core.IContainer)">
            <summary>
            设置日志。
            </summary>
            <typeparam name="TLogger"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.SetSingletonLogger``1(TouchSocket.Core.IContainer)">
            <summary>
            设置单例日志。
            </summary>
            <typeparam name="TLogger"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.SetSingletonLogger``1(TouchSocket.Core.IContainer,``0)">
            <summary>
            设置实例日志。
            </summary>
            <typeparam name="TLogger"></typeparam>
            <param name="container"></param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddConsoleLogger(TouchSocket.Core.IContainer)">
            <summary>
            添加控制台日志到日志组。
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.IContainer,System.Action{TouchSocket.Core.LogType,System.Object,System.String,System.Exception})">
            <summary>
            添加委托日志到日志组。
            </summary>
            <param name="container"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.IContainer,System.Action{System.String})">
            <summary>
            添加委托日志到日志组。
            </summary>
            <param name="container"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddFileLogger(TouchSocket.Core.IContainer,System.String)">
            <summary>
            添加文件日志到日志组。
            </summary>
            <param name="container"></param>
            <param name="rootPath"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddLogger(TouchSocket.Core.IContainer,TouchSocket.Core.ILog)">
            <summary>
            添加日志到日志组。
            </summary>
            <param name="container"></param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.LoggerExtensions">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Critical``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出中断日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Debug``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出调试日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception``1(TouchSocket.Core.ILog,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception``1(TouchSocket.Core.ILog,System.Object,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Log``1(TouchSocket.Core.ILog,TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出日志
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Trace``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出详细日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Critical(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出中断日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Debug(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出调试日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception(TouchSocket.Core.ILog,System.Exception)">
            <summary>
            输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception(TouchSocket.Core.ILog,System.Object,System.Exception)">
            <summary>
            输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Trace(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出详细日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.#ctor(TouchSocket.Core.ILog[])">
            <summary>
            一组日志记录器
            </summary>
            <param name="logs"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.#ctor">
            <summary>
             一组日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoggerGroup.Logs">
            <summary>
            组内的日志记录器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.AddLogger(System.String,TouchSocket.Core.ILog)">
            <summary>
            添加日志组件
            </summary>
            <param name="key"></param>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.AddLogger(TouchSocket.Core.ILog)">
            <summary>
            添加日志组件
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.Log``1(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            指定输出<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定类型的日志
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.RemoveLogger(TouchSocket.Core.ILog)">
            <summary>
            移除日志
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.RemoveLogger(System.Type)">
            <summary>
            移除日志
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.RemoveLogger(System.String)">
            <summary>
            移除对应键的日志
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.WriteLog(TouchSocket.Core.LogType,System.Object,System.String,System.Exception)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="logType"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`2">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`2.#ctor(`0,`1)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`3">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`3.#ctor(`0,`1,`2)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`4">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`4.#ctor(`0,`1,`2,`3)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`5">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
            <typeparam name="TLog5"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`6">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
            <typeparam name="TLog5"></typeparam>
            <typeparam name="TLog6"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LogType">
            <summary>
            日志类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.None">
            <summary>
            不使用日志类输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Trace">
            <summary>
            更为详细的步骤型日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Debug">
            <summary>
            调试信息日志
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Info">
            <summary>
            消息类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Warning">
            <summary>
            警告类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Error">
            <summary>
            错误类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogType.Critical">
            <summary>
            不可控中断类日输出
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPackage">
            <summary>
            包接口规范
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPackage.Package(TouchSocket.Core.ByteBlock)">
            <summary>
            打包。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.IPackage.Unpackage(TouchSocket.Core.ByteBlock)">
            <summary>
            解包。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Core.MsgRouterPackage">
            <summary>
            可承载消息的路由包
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MsgRouterPackage.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MsgRouterPackage.PackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MsgRouterPackage.UnpackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PackageBase">
            <summary>
            PackageBase包结构数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PackageBase.Package(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.PackageBase.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PackageExtensions">
            <summary>
            PackageExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PackageExtensions.PackageAsBytes(TouchSocket.Core.PackageBase)">
            <summary>
            打包为字节
            </summary>
            <param name="packageBase"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.RouterPackage">
            <summary>
            具有目标id和源id的路由包
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.Route">
            <summary>
            标识是否路由
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.SourceId">
            <summary>
            源Id
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.TargetId">
            <summary>
            目标Id
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.Package(TouchSocket.Core.ByteBlock)">
            <summary>
            打包所有的路由包信息。顺序为：先调用<see cref="M:TouchSocket.Core.RouterPackage.PackageRouter(TouchSocket.Core.ByteBlock)"/>，然后<see cref="M:TouchSocket.Core.RouterPackage.PackageBody(TouchSocket.Core.ByteBlock)"/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.PackageBody(TouchSocket.Core.ByteBlock)">
            <summary>
            打包数据体。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.PackageRouter(TouchSocket.Core.ByteBlock)">
            <summary>
            打包路由。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.SwitchId">
            <summary>
            转换目标和源的id。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.UnpackageBody(TouchSocket.Core.ByteBlock)">
            <summary>
            解包数据体。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.UnpackageRouter(TouchSocket.Core.ByteBlock)">
            <summary>
            只解包路由部分。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Core.WaitPackage">
            <summary>
            WaitPackage
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Message">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Sign">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Status">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitPackage.Package(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitPackage.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.WaitRouterPackage">
            <summary>
            可等待的路由包。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitRouterPackage.Sign">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitRouterPackage.Status">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.PackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.UnpackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.AsyncRaiserAttribute">
            <summary>
            标识该接口应当还会触发异步接口。
            异步接口方法的返回值应该为Task，且必须以Async结尾。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPlugin">
            <summary>
            插件接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPlugin.Order">
            <summary>
            插件执行顺序
            <para>该属性值越大，越靠前执行。值相等时，按添加先后顺序</para>
            <para>该属性效果，仅在<see cref="M:TouchSocket.Core.IPluginsManager.Add(TouchSocket.Core.IPlugin)"/>之前设置有效。</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPluginObject">
            <summary>
            具有插件功能的对象
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginObject.Container">
            <summary>
            内置IOC容器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginObject.PluginsManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginObject.UsePlugin">
            <summary>
            是否已启用插件
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPluginsManager">
            <summary>
            插件管理器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginsManager.Enable">
            <summary>
            标识该插件是否可用。当不可用时，仅可以添加和删除插件，但不会触发插件
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginsManager.Container">
            <summary>
            内置IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPluginsManager.Add(TouchSocket.Core.IPlugin)">
            <summary>
            添加插件
            </summary>
            <param name="plugin">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IPluginsManager.Remove(TouchSocket.Core.IPlugin)">
            <summary>
            移除插件
            </summary>
            <param name="plugin"></param>
        </member>
        <member name="M:TouchSocket.Core.IPluginsManager.Remove(System.Type)">
            <summary>
            移除插件
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:TouchSocket.Core.IPluginsManager.Clear">
            <summary>
            清除所有插件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPluginsManager.Raise``1(System.String,System.Object,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            触发对应方法
            </summary>
            <typeparam name="TPlugin">接口类型</typeparam>
            <param name="name">触发名称</param>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Core.PlguinObjectExtension">
            <summary>
            PlguinObjectExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PlguinObjectExtension.AddPlugin``1(TouchSocket.Core.IPluginObject)">
            <summary>
            添加插件
            </summary>
            <typeparam name="TPlugin">插件类型</typeparam>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.PlguinObjectExtension.AddPlugin(TouchSocket.Core.IPluginObject,TouchSocket.Core.IPlugin)">
            <summary>
            添加插件
            </summary>
            <param name="plguinObject"></param>
            <param name="plugin">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.PlguinObjectExtension.ClearPlugins(TouchSocket.Core.IPluginObject)">
            <summary>
            清空插件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PlguinObjectExtension.RemovePlugin(TouchSocket.Core.IPluginObject,TouchSocket.Core.IPlugin)">
            <summary>
            移除插件
            </summary>
            <param name="plguinObject"></param>
            <param name="plugin"></param>
        </member>
        <member name="M:TouchSocket.Core.PlguinObjectExtension.RemovePlugin``1(TouchSocket.Core.IPluginObject)">
            <summary>
            移除插件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="plguinObject"></param>
        </member>
        <member name="T:TouchSocket.Core.PluginsManager">
            <summary>
            表示插件管理器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.#ctor(TouchSocket.Core.IContainer)">
            <summary>
            构造函数
            </summary>
            <param name="container"></param>
        </member>
        <member name="P:TouchSocket.Core.PluginsManager.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PluginsManager.Enable">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.TouchSocket#Core#IPluginsManager#Add(TouchSocket.Core.IPlugin)">
            <summary>
            添加插件
            </summary>
            <param name="plugin">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.TouchSocket#Core#IPluginsManager#Clear">
            <summary>
            清除所有插件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.TouchSocket#Core#IPluginsManager#Raise``1(System.String,System.Object,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            触发对应方法
            </summary>
            <typeparam name="TPlugin">接口类型，此处也必须是接口类型</typeparam>
            <param name="name">触发名称</param>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.TouchSocket#Core#IPluginsManager#Remove(TouchSocket.Core.IPlugin)">
            <summary>
            移除插件
            </summary>
            <param name="plugin"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginsManager.TouchSocket#Core#IPluginsManager#Remove(System.Type)">
            <summary>
            移除插件
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:TouchSocket.Core.PluginsManagerExtension">
            <summary>
            PluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginsManagerExtension.Add``1(TouchSocket.Core.IPluginsManager)">
            <summary>
            添加插件
            </summary>
            <typeparam name="TPlugin">插件类型</typeparam>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.PluginsManagerExtension.Add``1(TouchSocket.Core.IPluginsManager,System.Object[])">
            <summary>
            添加插件
            </summary>
            <typeparam name="TPlugin">插件类型</typeparam>
            <param name="pluginsManager"></param>
            <param name="ps">创建插件相关构造函数插件</param>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.PluginsManagerExtension.Clear(TouchSocket.Core.IPluginsManager)">
            <summary>
            清空插件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginsManagerExtension.Remove(TouchSocket.Core.IPluginsManager,TouchSocket.Core.IPlugin)">
            <summary>
            移除插件
            </summary>
            <param name="pluginsManager"></param>
            <param name="plugin"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginsManagerExtension.Remove``1(TouchSocket.Core.IPluginsManager)">
            <summary>
            移除插件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="pluginsManager"></param>
        </member>
        <member name="T:TouchSocket.Core.SingletonPluginAttribute">
            <summary>
            标识插件只能注册一次。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IObjectPool">
            <summary>
            对象池接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IObjectPool.FreeSize">
            <summary>
            可使用数量
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IObjectPool.Clear">
            <summary>
            清空池中对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPoolObject">
            <summary>
            对象池单位接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPoolObject.NewCreate">
            <summary>
            是否为新建对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPoolObject.Create">
            <summary>
            初创建对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPoolObject.Recreate">
            <summary>
            重新创建对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPoolObject.Destroy">
            <summary>
            销毁对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ObjectPool`1">
            <summary>
            对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ObjectPool`1.AutoCreate">
            <summary>
            是否自动生成
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ObjectPool`1.Capacity">
            <summary>
            对象池容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ObjectPool`1.FreeSize">
            <summary>
            可使用（创建）数量
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.Clear">
            <summary>
            清除池中所有对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.DestroyObject(`0)">
            <summary>
            注销对象
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.Dispose">
            <summary>
            释放对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.GetAllObject">
            <summary>
            获取所有对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.GetObject">
            <summary>
            获取对象T
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ObjectPool`1.PreviewGetObject">
            <summary>
            预获取
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DynamicMethodMemberAccessor">
            <summary>
            DynamicMethodMemberAccessor
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DynamicMethodMemberAccessor.OnGetProperties">
            <summary>
            获取属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DynamicMethodMemberAccessor.OnGetFieldInfes">
            <summary>
            获取字段
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DynamicMethodMemberAccessor.GetValue(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DynamicMethodMemberAccessor.SetValue(System.Object,System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ExpressionMapper">
            <summary>
            表达式复制
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ExpressionMapper.Trans``2(``0)">
            <summary>
            字典缓存表达式树
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IMemberAccessor">
            <summary>
            一个成员访问接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IMemberAccessor.GetValue(System.Object,System.String)">
            <summary>
            获取指定成员的值
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IMemberAccessor.SetValue(System.Object,System.String,System.Object)">
             <summary>
            设置指定成员的值
             </summary>
             <param name="instance"></param>
             <param name="memberName"></param>
             <param name="newValue"></param>
        </member>
        <member name="T:TouchSocket.Core.Member">
            <summary>
            用于表达式树的成员
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemberAccessor`1">
            <summary>
            动态成员访问器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor`1.#ctor">
            <summary>
            动态成员访问器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemberAccessor">
            <summary>
            动态成员访问器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.#ctor(System.Type)">
            <summary>
            动态成员访问器
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.Build">
            <summary>
            构建
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.OnGetProperties">
            <summary>
            获取属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.OnGetFieldInfes">
            <summary>
            获取字段
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.Type">
            <summary>
            所属类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.GetValue(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.SetValue(System.Object,System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.MemberGetter">
            <summary>
            表示属性的Getter
            </summary>
        </member>
        <member name="F:TouchSocket.Core.MemberGetter.m_getFunc">
            <summary>
            get方法委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            表示属性的Getter
            </summary>
            <param name="property">属性</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.#ctor(System.Reflection.FieldInfo)">
            <summary>
            表示类型字段或属性的Getter
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.Invoke(System.Object)">
            <summary>
            获取属性的值
            </summary>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.MemberSetter">
            <summary>
            表示属性的设置器
            </summary>
        </member>
        <member name="F:TouchSocket.Core.MemberSetter.setFunc">
            <summary>
            set方法委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberSetter.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            表示属性的Getter
            </summary>
            <param name="property">属性</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberSetter.Invoke(System.Object,System.Object)">
            <summary>
            设置属性的值
            </summary>
            <param name="instance">实例</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TaskReturnType">
            <summary>
            Task类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.None">
            <summary>
            没有Task
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.Task">
            <summary>
            仅返回Task
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.TaskObject">
            <summary>
            返回Task的值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Method">
            <summary>
            表示方法
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Method.m_invoker">
            <summary>
            方法执行委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Method.#ctor(System.Reflection.MethodInfo)">
            <summary>
            方法
            </summary>
            <param name="method">方法信息</param>
        </member>
        <member name="P:TouchSocket.Core.Method.HasReturn">
            <summary>
            是否具有返回值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.Info">
            <summary>
            方法信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.IsByRef">
            <summary>
            是否有引用类型
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.Name">
            <summary>
            获取方法名
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.ReturnType">
            <summary>
            返回值类型。
            <para>当方法为void或task时，为null</para>
            <para>当方法为task泛型时，为泛型元素类型</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.Static">
            <summary>
            是否为静态函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.TaskType">
            <summary>
            返回值的Task类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Method.Invoke(System.Object,System.Object[])">
            <summary>
            执行方法。
            <para>当方法为void或task时，会返回null</para>
            <para>当方法为task泛型时，会wait后的值</para>
            <para>注意：当调用方为UI主线程时，调用异步方法，则极有可能发生死锁。</para>
            </summary>
            <param name="instance">实例</param>
            <param name="parameters">参数</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.InvokeAsync(System.Object,System.Object[])">
            <summary>
            异步调用
            </summary>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.InvokeObjectAsync(System.Object,System.Object[])">
            <summary>
            调用异步结果
            </summary>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.CreateInvoker(System.Reflection.MethodInfo)">
            <summary>
            生成方法的调用委托
            </summary>
            <param name="method">方法成员信息</param>
            <exception cref="T:System.ArgumentException"></exception>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Property">
            <summary>
            表示属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_cached">
            <summary>
            类型属性的Setter缓存
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_geter">
            <summary>
            获取器
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_seter">
            <summary>
            设置器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Property.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            属性
            </summary>
            <param name="property">属性信息</param>
        </member>
        <member name="P:TouchSocket.Core.Property.CanRead">
            <summary>
            是否可以读取
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.CanWrite">
            <summary>
            是否可以写入
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.Info">
            <summary>
            获取属性信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.Name">
            <summary>
            获取属性名称
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Property.GetProperties(System.Type)">
            <summary>
            从类型的属性获取属性
            </summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Property.GetValue(System.Object)">
            <summary>
            获取属性的值
            </summary>
            <param name="instance">实例</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Property.SetValue(System.Object,System.Object)">
            <summary>
            设置属性的值
            </summary>
            <param name="instance">实例</param>
            <param name="value">值</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:TouchSocket.Core.EasyTask">
            <summary>
            易用组件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.DelayRun(System.TimeSpan,System.Action)">
            <summary>
            延迟执行
            </summary>
            <param name="action"></param>
            <param name="delayTimeSpan"></param>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.DelayRun``1(System.TimeSpan,``0,System.Action{``0})">
            <summary>
            延迟执行
            </summary>
            <param name="action"></param>
            <param name="delayTimeSpan"></param>
            <param name="status"></param>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.DelayRun(System.Int32,System.Action)">
            <summary>
            延迟执行
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.DelayRun``1(System.Int32,``0,System.Action{``0})">
            <summary>
            延迟执行
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
            <param name="status"></param>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.Run``1(``0,System.Action{``0})">
            <summary>
            Task异步
            </summary>
            <param name="statu"></param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.Run``1(System.Func{``0})">
            <summary>
            Task异步
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.Run(System.Action)">
            <summary>
            Task异步
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.EasyTask.CompletedTask">
            <summary>
            已完成的Task
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoopAction">
            <summary>
            循环动作
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.TimeSpan,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建可循环操作体
            </summary>
            <param name="count">循环次数，设为-1时一直循环</param>
            <param name="interval">每次循环间隔</param>
            <param name="action">执行委托</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.Int32,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建可循环操作体
            </summary>
            <param name="count">循环次数，设为-1时一直循环</param>
            <param name="intervalMS">每次循环间隔，毫秒</param>
            <param name="action">执行委托</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建可循环操作体
            </summary>
            <param name="count">循环次数，设为-1时一直循环</param>
            <param name="action">执行委托</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.TimeSpan,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建可循环操作体
            </summary>
            <param name="interval">每次循环间隔</param>
            <param name="action">执行委托</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建可循环操作体
            </summary>
            <param name="action">执行委托</param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.ExecutedCount">
            <summary>
            已执行次数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.Interval">
            <summary>
            执行间隔
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.LoopCount">
            <summary>
            循环次数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.ExecuteAction">
            <summary>
            执行委托
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.RunStatus">
            <summary>
            是否在运行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Run">
            <summary>
            运行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Rerun">
            <summary>
            重新运行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.RerunAsync">
            <summary>
            以异步重新运行
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.RunAsync">
            <summary>
            以异步运行
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Pause">
            <summary>
            暂停
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Resume">
            <summary>
            回复
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:TouchSocket.Core.RunStatus">
            <summary>
            运行状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Running">
            <summary>
            Running
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Completed">
            <summary>
            Completed
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Paused">
            <summary>
            Pause
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Disposed">
            <summary>
            Disposed
            </summary>
        </member>
        <member name="T:TouchSocket.Core.AppMessageAttribute">
            <summary>
            注册为消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessageAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessageAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:TouchSocket.Core.AppMessageAttribute.Token">
            <summary>
            标识
            </summary>
        </member>
        <member name="T:TouchSocket.Core.AppMessenger">
            <summary>
            消息通知类。内部全为弱引用。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AppMessenger.Default">
            <summary>
            默认单例实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AppMessenger.AllowMultiple">
            <summary>
            允许多广播注册
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Add(System.String,TouchSocket.Core.MessageInstance)">
            <summary>
            添加
            </summary>
            <param name="token"></param>
            <param name="messageInstance"></param>
            <exception cref="T:TouchSocket.Core.MessageRegisteredException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.CanSendMessage(System.String)">
            <summary>
            判断能否触发该消息，意味着该消息是否已经注册。
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Clear">
            <summary>
            清除所有消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.GetAllMessage">
            <summary>
            获取所有消息
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Remove(System.String)">
            <summary>
            移除
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Remove(TouchSocket.Core.IMessageObject)">
            <summary>
            按对象移除
            </summary>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.SendAsync(System.String,System.Object[])">
            <summary>
            发送消息
            </summary>
            <param name="token"></param>
            <param name="parameters"></param>
            <exception cref="T:TouchSocket.Core.MessageNotFoundException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.SendAsync``1(System.String,System.Object[])">
            <summary>
            发送消息，当多播时，只返回最后一个返回值
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
            <exception cref="T:TouchSocket.Core.MessageNotFoundException"></exception>
        </member>
        <member name="T:TouchSocket.Core.AppMessengerExtensions">
            <summary>
            AppMessengerExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``1(TouchSocket.Core.AppMessenger)">
            <summary>
            注册类的静态消息
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,System.Type)">
            <summary>
            注册类的静态消息
            </summary>
            <param name="appMessenger"></param>
            <param name="type"></param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject)">
            <summary>
            注册消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject,System.String,System.Reflection.MethodInfo)">
            <summary>
            注册消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
            <param name="token"></param>
            <param name="methodInfo"></param>
            <exception cref="T:TouchSocket.Core.MessageRegisteredException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,System.Action,System.String)">
            <summary>
            注册消息
            </summary>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``1(TouchSocket.Core.AppMessenger,System.Action{``0},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``2(TouchSocket.Core.AppMessenger,System.Action{``0,``1},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``3(TouchSocket.Core.AppMessenger,System.Action{``0,``1,``2},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``4(TouchSocket.Core.AppMessenger,System.Action{``0,``1,``2,``3},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``5(TouchSocket.Core.AppMessenger,System.Action{``0,``1,``2,``3,``4},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``2(TouchSocket.Core.AppMessenger,System.Func{``0,``1},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``3(TouchSocket.Core.AppMessenger,System.Func{``0,``1,``2},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``4(TouchSocket.Core.AppMessenger,System.Func{``0,``1,``2,``3},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``5(TouchSocket.Core.AppMessenger,System.Func{``0,``1,``2,``3,``4},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``6(TouchSocket.Core.AppMessenger,System.Func{``0,``1,``2,``3,``4,``5},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register``1(TouchSocket.Core.AppMessenger,System.Func{``0},System.String)">
            <summary>
            注册消息
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="appMessenger"></param>
            <param name="action"></param>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Unregister(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject)">
            <summary>
            卸载消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Unregister(TouchSocket.Core.AppMessenger,System.String)">
            <summary>
            移除注册
            </summary>
            <param name="appMessenger"></param>
            <param name="token"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.IMessageObject">
            <summary>
            限定消息的接口
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MessageInstance">
            <summary>
            MessageInstance
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageInstance.#ctor(System.Reflection.MethodInfo,System.Object)">
            <summary>
            MessageInstance
            </summary>
            <param name="method"></param>
            <param name="messageObject"></param>
        </member>
        <member name="P:TouchSocket.Core.MessageInstance.MessageObject">
            <summary>
            承载消息的实体
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MessageInstance.WeakReference">
            <summary>
            弱引用。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SingleTimer">
            <summary>
            不可重入的Timer
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleTimer.Pause">
            <summary>
            是否暂停执行。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleTimer.Count">
            <summary>
            自启动以来执行的次数。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action)">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.TimeSpan,System.Action)">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.TimeSpan,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.TimeSpan,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.Int32,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.Int32,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.IWaitResult">
            <summary>
            等待返回类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitResult.Sign">
            <summary>
            标记
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ValueWaitResult">
            <summary>
            ValueWaitResult
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Sign">
            <summary>
            标记号
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitData`1">
            <summary>
            等待数据对象
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitData`1.DelayModel">
            <summary>
            延迟模式
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitData`1.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitData`1.WaitResult">
            <summary>
            等待数据结果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Cancel">
            <summary>
            取消任务
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Reset">
            <summary>
            Reset。
            设置<see cref="P:TouchSocket.Core.WaitData`1.WaitResult"/>为null。然后重置状态为<see cref="F:TouchSocket.Core.WaitDataStatus.Default"/>，waitHandle.Reset()
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Set">
            <summary>
            使等待的线程继续执行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Set(`0)">
            <summary>
            使等待的线程继续执行
            </summary>
            <param name="waitResult">等待结果</param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.SetCancellationToken(System.Threading.CancellationToken)">
            <summary>
            加载取消令箭
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.SetResult(`0)">
            <summary>
            载入结果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Wait(System.TimeSpan)">
            <summary>
            等待指定时间
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Wait(System.Int32)">
            <summary>
            等待指定毫秒
            </summary>
            <param name="millisecond"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.WaitAsync(System.TimeSpan)">
            <summary>
            等待指定时间
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.WaitAsync(System.Int32)">
            <summary>
            等待指定毫秒
            </summary>
            <param name="millisecond"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Dispose(System.Boolean)">
            <summary>
            释放
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.WaitDataStatus">
            <summary>
            等待数据状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.SetRunning">
            <summary>
            收到信号运行
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Overtime">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Canceled">
            <summary>
            已取消
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Disposed">
            <summary>
            已释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitHandlePool`1">
            <summary>
            等待处理数据
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.Destroy(TouchSocket.Core.WaitData{`0})">
            <summary>
            销毁
            </summary>
            <param name="waitData"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.CancelAll">
            <summary>
            取消全部
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitHandlePool`1.DelayModel">
            <summary>
            延迟模式
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetWaitData(`0,System.Boolean)">
            <summary>
             获取一个可等待对象
            </summary>
            <param name="result"></param>
            <param name="autoSign">设置为false时，不会生成sign</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetReverseWaitData(`0,System.Boolean)">
            <summary>
             获取一个Sign为负数的可等待对象
            </summary>
            <param name="result"></param>
            <param name="autoSign">设置为false时，不会生成sign</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(System.Int64)">
            <summary>
            让等待对象恢复运行
            </summary>
            <param name="sign"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(System.Int64,`0)">
            <summary>
            让等待对象恢复运行
            </summary>
            <param name="sign"></param>
            <param name="waitResult"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(`0)">
            <summary>
            让等待对象恢复运行
            </summary>
            <param name="waitResult"></param>
        </member>
        <member name="T:TouchSocket.Core.WaitResult">
            <summary>
            等待返回类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Sign">
            <summary>
            标记号
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastConverterAttribute">
            <summary>
            FastConverterAttribute
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastConverterAttribute.#ctor(System.Type)">
            <summary>
            FastConverterAttribute
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:TouchSocket.Core.FastConverterAttribute.Type">
            <summary>
            转化器类型。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastNonSerializedAttribute">
            <summary>
            忽略的Fast序列化
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastSerializedAttribute">
            <summary>
            强制Fast序列化。一般当某个属性为只读时，使用该特性。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IFastBinaryConverter">
            <summary>
            FastBinary转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IFastBinaryConverter.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IFastBinaryConverter.Write(TouchSocket.Core.ByteBlock,System.Object)">
            <summary>
            写入
            </summary>
            <param name="byteBlock"></param>
            <param name="obj"></param>
        </member>
        <member name="T:TouchSocket.Core.FastBinaryConverter`1">
            <summary>
            FastBinary转换器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.Write(TouchSocket.Core.ByteBlock,`0)">
            <summary>
            写入
            </summary>
            <param name="byteBlock"></param>
            <param name="obj"></param>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.FastBinaryFormatter">
            <summary>
            快速二进制序列化。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter``2">
            <summary>
            添加转换器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter``1(TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            添加转换器。
            </summary>
            <typeparam name="TType"></typeparam>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter(System.Type,TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            添加转换器。
            </summary>
            <param name="type"></param>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Serialize``1(TouchSocket.Core.ByteBlock,``0)">
            <summary>
            序列化对象
            </summary>
            <param name="byteBlock">流</param>
            <param name="graph">对象</param>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize(System.Byte[],System.Int32,System.Type)">
            <summary>
            反序列化
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonFastConverter">
            <summary>
            Json高速转换
            <para>此代码来源：https://gitee.com/majorworld</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonFastConverter.TimeFormat">
            <summary>
            全局时间序列化样式，默认为yyyy-MM-dd HH:mm:ss
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonFastConverter.JsonFrom``1(System.String)">
            <summary>
            将Json字符串转为指定类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonFastConverter.JsonFrom(System.String,System.Type)">
            <summary>
            将Json字符串转为指定类型
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:TouchSocket.Core.JsonFastConverter.JsonFrom(System.String)">
            <summary>
            将Json字符串转为对象<br/>
            重载，当前数据类型速度最快
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonFastConverter.JsonTo``1(``0,System.String)">
            <summary>
            将对象转为Json字符串
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="timeFormat">时间序列化样式，默认为yyyy-MM-dd HH:mm:ss</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonFastIgnore">
            <summary>
            过滤不需要序列化的字段
            </summary>
        </member>
        <member name="T:TouchSocket.Core.JsonChange">
            <summary>
            转换为实体类对应的类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeArray(System.Type,System.Collections.IList)">
            <summary>
            处理数组类型
            https://gitee.com/majorworld
            </summary>
            <param name="type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeArrayList(System.Object)">
            <summary>
            转换ArrayList类型
            https://gitee.com/majorworld
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeColor(System.String)">
            <summary>
            转换Color类型
            https://gitee.com/majorworld
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeData(System.Type,System.Object)">
            <summary>
            转换为各种数据
            https://gitee.com/majorworld
            </summary>
            <param name="p"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeDictionary(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            处理字典类型
            https://gitee.com/majorworld
            </summary>
            <param name="type"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangeList(System.Type,System.Collections.Generic.List{System.Object})">
            <summary>
            处理集合类型
            https://gitee.com/majorworld
            </summary>
            <param name="type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ChangePoint(System.String)">
            <summary>
            转换Point类型
            https://gitee.com/majorworld
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ToDataTable``1(System.Collections.Generic.List{``0})">
            <summary>
            List转DataTable
            https://gitee.com/majorworld
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonChange.ToObject(System.Collections.Generic.Dictionary{System.String,System.Object},System.Type)">
            <summary>
            转换为对象
            https://gitee.com/majorworld
            </summary>
            <param name="dict"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonDecode">
            <summary>
            解析字符串为对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetArray(System.String,System.Int32@,System.Text.StringBuilder,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            解析集合
            https://gitee.com/majorworld
            </summary>
            <param name="index"></param>
            <param name="sb"></param>
            <param name="dict"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetObject(System.String,System.Int32@,System.Text.StringBuilder,System.Collections.Generic.List{System.Object})">
            <summary>
            解析对象
            https://gitee.com/majorworld
            </summary>
            <param name="index"></param>
            <param name="sb"></param>
            <param name="list"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetBool(System.String,System.Int32@,System.Boolean)">
            <summary>
            获取布尔数据
            https://gitee.com/majorworld
            </summary>
            <param name="index"></param>
            <param name="state"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetData(System.String,System.Char,System.Int32@,System.Text.StringBuilder,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.List{System.Object})">
            <summary>
            自动获取数据
            https://gitee.com/majorworld
            </summary>
            <param name="s"></param>
            <param name="c"></param>
            <param name="index"></param>
            <param name="sb"></param>
            <param name="dict"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetNull(System.String,System.Int32@)">
            <summary>
            获取空数据
            https://gitee.com/majorworld
            </summary>
            <param name="index"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetNumber(System.String,System.Int32@,System.Text.StringBuilder)">
            <summary>
            获取数字数据
            https://gitee.com/majorworld
            </summary>
            <param name="s"></param>
            <param name="index"></param>
            <param name="sb"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonDecode.GetString(System.String,System.Int32@,System.Text.StringBuilder)">
            <summary>
            获取字符串数据
            https://gitee.com/majorworld
            </summary>
            <param name="index"></param>
            <param name="sb"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonEncode">
            <summary>
            编码对象为字符串
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonEncode.InfoCache">
            <summary>
            缓存数据加速序列化速度，主要是减少不必要的GetCustomAttributes获取特性并过滤字段
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonEncode.CodeObject(System.Object,System.Text.StringBuilder,System.String)">
            <summary>
            序列化
            </summary>
            <param name="obj"></param>
            <param name="sb"></param>
            <param name="timeFormat"></param>
        </member>
        <member name="M:TouchSocket.Core.JsonEncode.GetCacheInfo(System.Type)">
            <summary>
            尝试获取缓存中的类型，排除忽略的字段
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonEncode.CodeDataTable(System.Data.DataTable,System.Text.StringBuilder,System.String)">
            <summary>
            序列化DataTable
            </summary>
            <param name="dt"></param>
            <param name="sb"></param>
            <param name="timeFormat">时间格式化样式，默认为yyyy-MM-dd HH:mm:ss</param>
        </member>
        <member name="T:TouchSocket.Core.JsonNet">
            <summary>
            提供Json.net无引用调用。
            <para>该代码来源：https://www.cnblogs.com/kewei/p/8228343.html</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonNet.jsonNetAssemblyName">
            <summary>
            Json.Net程序集名称
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonNet.jsonNetJsonConvertTypeName">
            <summary>
            JsonConvert类名
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonNet.serializeFunc">
            <summary>
            序列化方法的委托
            </summary>
        </member>
        <member name="F:TouchSocket.Core.JsonNet.deserializeFunc">
            <summary>
            反序列化方法的委托
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonNet.IsSupported">
            <summary>
            获取是否得到支持
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.#cctor">
            <summary>
            Json.net
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.SerializeObject(System.Object)">
            <summary>
            序列化对象
            </summary>
            <param name="obj">对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.DeserializeObject(System.String,System.Type)">
            <summary>
            反序列化为对象
            </summary>
            <param name="json">json文本</param>
            <param name="type">对象类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.InitJsonNet(System.Reflection.Assembly[])">
            <summary>
            初始化json.net
            </summary>
            <param name="assemblies">查找的程序集</param>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.CreateSerializeObjectFunc(System.Type)">
            <summary>
            创建SerializeObject方法的委托
            </summary>
            <param name="classType">JsonConvert类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonNet.CreateDeserializeObjectFunc(System.Type)">
            <summary>
            创建DeserializeObject方法的委托
            </summary>
            <param name="classType">JsonConvert类型</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SerializationType">
            <summary>
            序列化类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.FastBinary">
            <summary>
            内置快速二进制
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.Xml">
            <summary>
            Xml
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.SystemBinary">
            <summary>
            系统二进制。微软认为这是不安全的，所以谨慎使用。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SerializeConvert">
            <summary>
            高性能序列化器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerialize(System.Object)">
            <summary>
            普通二进制序列化对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerializeToFile(System.Object,System.String)">
            <summary>
            二进制序列化对象至文件
            </summary>
            <param name="obj">数据对象</param>
            <param name="path">路径</param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerialize(System.IO.Stream,System.Object)">
            <summary>
            二进制序列化对象
            </summary>
            <param name="stream"></param>
            <param name="obj"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[],System.Int32,System.Int32,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Byte[]中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize(System.Byte[],System.Int32,System.Int32,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            反序列化
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.IO.Stream,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Stream中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserializeFromFile``1(System.String)">
            <summary>
            将二进制文件数据反序列化为指定类型对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[])">
            <summary>
            将二进制数据反序列化为指定类型对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[],System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Byte[]中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FastBinarySerialize``1(TouchSocket.Core.ByteBlock,``0)">
            <summary>
            Fast二进制序列化对象
            </summary>
            <param name="stream"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FastBinarySerialize``1(``0)">
            <summary>
            Fast二进制序列化对象
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FastBinaryDeserialize``1(System.Byte[],System.Int32)">
            <summary>
            Fast反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FastBinaryDeserialize(System.Byte[],System.Int32,System.Type)">
            <summary>
            Fast反序列化
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FastBinaryDeserialize``1(System.Byte[])">
            <summary>
            从Byte[]中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToString(System.Object,System.Text.Encoding)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToString(System.Object)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToBytes(System.Object)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToFile(System.Object,System.String)">
            <summary>
            Xml序列化至文件
            </summary>
            <param name="obj"></param>
            <param name="path"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromBytes``1(System.Byte[])">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="datas">数据</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromBytes(System.Byte[],System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="datas"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromString``1(System.String,System.Text.Encoding)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="xmlString">xml字符串</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromString``1(System.String)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="json">xml字符串</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromFile``1(System.String)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="path">文件路径</param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.SerializeConvert.NewtonsoftJsonFirst">
            <summary>
            首先使用NewtonsoftJson.默认True。
            <para>
            当设置True时，json序列化会优先使用NewtonsoftJson（需要将dll加载到程序）。
            当设置为FALSE，或者NewtonsoftJson不可用时，netstandard2.0和net45平台将使用<see cref="T:TouchSocket.Core.JsonFastConverter"/>。
            其他平台将使用System.Text.Json。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SerializeConvert.NewtonsoftJsonIsSupported">
            <summary>
            判断是否支持NewtonsoftJson
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.LoadNewtonsoftJson(System.Type)">
            <summary>
            主动载入NewtonsoftJson。
            </summary>
            <param name="jsonConvertType">传入命名为JsonConvert的类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.ToJson(System.Object)">
            <summary>
            转换为Json
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FromJson(System.String,System.Type)">
            <summary>
            从字符串到json
            </summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FromJson``1(System.String)">
            <summary>
            从字符串到json
            </summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonSerializeToBytes(System.Object)">
            <summary>
            Json序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonSerializeToFile(System.Object,System.String)">
            <summary>
            Json序列化至文件
            </summary>
            <param name="obj"></param>
            <param name="path"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromBytes``1(System.Byte[])">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="datas">数据</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromBytes(System.Byte[],System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="datas"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromString``1(System.String)">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="json">json字符串</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromFile``1(System.String)">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="path">文件路径</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.HttpPluginsManagerExtension">
            <summary>
            HttpPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginsManagerExtension.UseDefaultHttpServicePlugin(TouchSocket.Core.IPluginsManager)">
            <summary>
            默认的Http服务。为Http做兜底拦截。该插件应该最后添加。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.WebSocketPluginsManagerExtension">
            <summary>
            WebSocketPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginsManagerExtension.UseWebSocket(TouchSocket.Core.IPluginsManager)">
            <summary>
            使用WebSocket插件
            </summary>
            <returns>插件类型实例</returns>
        </member>
        <member name="T:TouchSocket.Core.RpcConfigExtensions">
            <summary>
            RpcExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RpcConfigExtensions.RpcStoreProperty">
            <summary>
            指定RpcStore的创建。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RpcConfigExtensions.ConfigureRpcStore(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Rpc.RpcStore},TouchSocket.Rpc.RpcStore)">
            <summary>
            配置RpcStore的创建。
            </summary>
            <param name="config"></param>
            <param name="action">当RpcStore完成配置时回调</param>
            <param name="value">可以使用现有的值，如果赋值为null，则会重新创建。</param>
        </member>
        <member name="T:TouchSocket.Core.JsonRpcPluginsManagerExtension">
            <summary>
            JsonRpcPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonRpcPluginsManagerExtension.UseJsonRpc(TouchSocket.Core.IPluginsManager)">
            <summary>
            使用JsonRpc的插件。仅服务器可用。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchRpcPluginsManagerExtension">
            <summary>
            TouchRpcPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchRpcPluginsManagerExtension.UseRedis(TouchSocket.Core.IPluginsManager)">
            <summary>
            使用Redis插件。仅：TouchRpc组成员会生效。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchRpcPluginsManagerExtension.UseTouchRpcHeartbeat``1(TouchSocket.Core.IPluginsManager)">
            <summary>
            TouchRpc心跳。仅客户端适用。
            <para>
            默认心跳每3秒进行一次。最大失败3次即判定为断开连接。
            </para>
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.WebApiPluginsManagerExtension">
            <summary>
            WebApiPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WebApiPluginsManagerExtension.UseWebApi(TouchSocket.Core.IPluginsManager)">
            <summary>
            使用WebApi的插件。仅服务器可用。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.XmlRpcPluginsManagerExtension">
            <summary>
            XmlRpcPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.XmlRpcPluginsManagerExtension.UseXmlRpc(TouchSocket.Core.IPluginsManager)">
            <summary>
            使用XmlRpc的插件。仅服务器可用。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SocketPluginsManagerExtension">
            <summary>
            IPluginsManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SocketPluginsManagerExtension.UseReconnection(TouchSocket.Core.IPluginsManager,System.Int32,System.Boolean,System.Int32,System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            使用断线重连。
            <para>该效果仅客户端在完成首次连接，且为被动断开时有效。</para>
            </summary>
            <param name="pluginsManager"></param>
            <param name="successCallback">成功回调函数</param>
            <param name="tryCount">尝试重连次数，设为-1时则永远尝试连接</param>
            <param name="printLog">是否输出日志。</param>
            <param name="sleepTime">失败时，停留时间</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SocketPluginsManagerExtension.UseCheckClear(TouchSocket.Core.IPluginsManager)">
            <summary>
             检查连接客户端活性插件。
             <para>当在设置的周期内，没有接收/发送任何数据，则判定该客户端掉线。执行清理。默认配置：60秒为一个周期，同时检测发送和接收。</para>
             仅服务器适用。
            </summary>
            <param name="pluginsManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SocketPluginsManagerExtension.UseReconnection(TouchSocket.Core.IPluginsManager,System.Int32,System.Func{TouchSocket.Sockets.ITcpClient,System.Int32,System.Exception,System.Boolean},System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            使用断线重连。
            <para>该效果仅客户端在完成首次连接，且为被动断开时有效。</para>
            </summary>
            <param name="pluginsManager"></param>
            <param name="sleepTime">失败时间隔时间</param>
            <param name="failCallback">失败时回调（参数依次为：客户端，本轮尝试重连次数，异常信息）。如果回调为null或者返回false，则终止尝试下次连接。</param>
            <param name="successCallback">成功连接时回调。</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.FileCachePool">
            <summary>
            静态文件缓存池
            </summary>
        </member>
        <member name="T:TouchSocket.Http.FileCachePool.InsertHandler">
            <summary>
            添加委托
            </summary>
            <param name="cache"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Http.FileCachePool.Empty">
            <summary>
            Is the file cache empty?
            </summary>
        </member>
        <member name="P:TouchSocket.Http.FileCachePool.Size">
            <summary>
            Get the file cache size
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Add(System.String,System.Byte[],System.TimeSpan)">
            <summary>
            Add a new cache value with the given timeout into the file cache
            </summary>
            <param name="key">Key to add</param>
            <param name="value">Value to add</param>
            <param name="timeout">Cache timeout (default is 0 - no timeout)</param>
            <returns>'true' if the cache value was added, 'false' if the given key was not added</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Find(System.String,System.Byte[]@)">
            <summary>
            Try to find the cache value by the given key
            </summary>
            <param name="key">Key to find</param>
            <param name="data"></param>
            <returns>'true' and cache value if the cache value was found, 'false' if the given key was not found</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Remove(System.String)">
            <summary>
            Remove the cache value with the given key from the file cache
            </summary>
            <param name="key">Key to remove</param>
            <returns>'true' if the cache value was removed, 'false' if the given key was not found</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.InsertPath(System.String,System.String,System.String,System.TimeSpan,TouchSocket.Http.FileCachePool.InsertHandler)">
            <summary>
            Insert a new cache path with the given timeout into the file cache
            </summary>
            <param name="path">Path to insert</param>
            <param name="prefix">Cache prefix (default is "/")</param>
            <param name="filter">Cache filter (default is "*.*")</param>
            <param name="timeout">Cache timeout (default is 0 - no timeout)</param>
            <param name="handler">Cache insert handler (default is 'return cache.Add(key, value, timeout)')</param>
            <returns>'true' if the cache path was setup, 'false' if failed to setup the cache path</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.FindPath(System.String)">
            <summary>
            Try to find the cache path
            </summary>
            <param name="path">Path to find</param>
            <returns>'true' if the cache path was found, 'false' if the given path was not found</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.RemovePath(System.String)">
            <summary>
            Remove the cache path from the file cache
            </summary>
            <param name="path">Path to remove</param>
            <returns>'true' if the cache path was removed, 'false' if the given path was not found</returns>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Clear">
            <summary>
            Clear the memory cache
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Dispose(System.Boolean)">
            <summary>
            释放
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.FileCachePool.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpBase">
            <summary>
            Http基础头部
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.ServerVersion">
            <summary>
            服务器版本
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.m_contentLength">
            <summary>
            内容长度
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.CanWrite">
            <summary>
            能否写入。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Client">
            <summary>
            客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentComplated">
            <summary>
            内容填充完成
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentLen">
            <summary>
            int类型，内容长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentLength">
            <summary>
            内容长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentType">
            <summary>
            内容类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Flag">
            <summary>
            传递标识
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Headers">
            <summary>
            请求头集合
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Protocols">
            <summary>
            协议名称，默认HTTP
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ProtocolVersion">
            <summary>
            HTTP协议版本，默认1.1
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.RequestLine">
            <summary>
            请求行
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.GetHeader(System.String)">
            <summary>
            获取头值
            </summary>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.GetHeader(TouchSocket.Http.HttpHeaders)">
            <summary>
            获取头集合的值
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ParsingHeader(TouchSocket.Core.ByteBlock,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从Request中持续读取数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadHeaders(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从内存中读取
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.SetContent(System.Byte[])">
            <summary>
            设置一次性内容
            </summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.SetHeaderByKey(System.String,System.String)">
            <summary>
            设置请求头
            </summary>
            <param name="fieldName"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.TryGetContent(System.Byte[]@)">
            <summary>
            获取一次性内容。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.WriteContent(System.Byte[],System.Int32,System.Int32)">
            <summary>
            持续写入内容。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.LoadHeaderProterties">
            <summary>
            读取信息
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpContext">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContext.#ctor(TouchSocket.Http.HttpRequest)">
            <summary>
            构造函数
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpContext.#ctor(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            构造函数
            </summary>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Request">
            <summary>
            Http请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Response">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpProxy">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost)">
            <summary>
            不带基本验证的代理
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost,System.String,System.String)">
            <summary>
            带基本验证的代理
            </summary>
            <param name="host"></param>
            <param name="userName"></param>
            <param name="passWord"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Credential">
            <summary>
            验证代理
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Host">
            <summary>
            代理的地址
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRange">
            <summary>
            Range: bytes=0-499 表示第 0-499 字节范围的内容
            Range: bytes=500-999 表示第 500-999 字节范围的内容
            Range: bytes=-500 表示最后 500 字节的内容
            Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容
            Range: bytes=0-0,-1 表示第一个和最后一个字节
            Range: bytes=500-600,601-999 同时指定几个范围
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRanges(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRange(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Start">
            <summary>
            起始位置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRequest">
            <summary>
            HTTP请求定义
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor(TouchSocket.Sockets.ITcpClientBase,System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="client"></param>
            <param name="isServer"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.CanRead">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.CanWrite">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Client">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Forms">
            <summary>
            表单数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.KeepAlive">
            <summary>
            获取时候保持连接
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Method">
            <summary>
            HTTP请求方式。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Params">
            <summary>
            Body参数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Query">
            <summary>
            url参数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.RelativeURL">
            <summary>
            相对路径（不含参数）
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.URL">
            <summary>
            Url全地址，包含参数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.Build(TouchSocket.Core.ByteBlock)">
            <summary>
             构建响应数据。
            <para>当数据较大时，不建议这样操作，可直接<see cref="M:TouchSocket.Http.HttpRequest.WriteContent(System.Byte[],System.Int32,System.Int32)"/></para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.BuildAsBytes">
            <summary>
            构建数据为字节数组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetContent(System.Byte[])">
            <summary>
            设置内容
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetUrl(System.String,System.Boolean)">
            <summary>
            设置Url，必须以“/”开头，可带参数
            </summary>
            <param name="url"></param>
            <param name="justValue"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ToString">
            <summary>
            输出
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.TryGetContent(System.Byte[]@)">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.WriteContent(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.LoadHeaderProterties">
            <summary>
            从内存中读取
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.BuildHeader(TouchSocket.Core.ByteBlock)">
            <summary>
            构建响应头部
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpResponse">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.#ctor(TouchSocket.Sockets.ITcpClientBase,System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="client"></param>
            <param name="isServer"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.CanRead">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.CanWrite">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.Client">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.CloseConnection">
            <summary>
            关闭会话请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsChunk">
            <summary>
            是否分块
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsProxyAuthenticationRequired">
            <summary>
            是否代理权限验证。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsRedirect">
            <summary>
            是否重定向
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.Responsed">
            <summary>
            是否已经响应数据。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusCode">
            <summary>
            状态码，默认200
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusMessage">
            <summary>
            状态消息，默认Success
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.Answer">
            <summary>
            构建数据并回应。
            <para>该方法仅在具有Client实例时有效。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.Build(TouchSocket.Core.ByteBlock,System.Boolean)">
            <summary>
             构建响应数据。
            <para>当数据较大时，不建议这样操作，可直接<see cref="M:TouchSocket.Http.HttpResponse.WriteContent(System.Byte[],System.Int32,System.Int32)"/></para>
            </summary>
            <param name="byteBlock"></param>
            <param name="responsed"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.BuildAsBytes">
            <summary>
            构建数据为字节数组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.Complete">
            <summary>
            当传输模式是Chunk时，用于结束传输。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.SetContent(System.Byte[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.TryGetContent(System.Byte[]@)">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.WriteContent(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.LoadHeaderProterties">
            <summary>
            读取数据
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.BuildHeader(TouchSocket.Core.ByteBlock)">
            <summary>
            构建响应头部
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpTools">
            <summary>
            Http工具
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpTools.GetContentTypeFromExtension(System.String)">
            <summary>
            从扩展名获取ContentType
            </summary>
            <param name="extension"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.MultifileCollection">
            <summary>
            多文件集合
            </summary>
        </member>
        <member name="M:TouchSocket.Http.MultifileCollection.#ctor(TouchSocket.Http.HttpRequest)">
            <summary>
            多文件集合
            </summary>
            <param name="httpRequest"></param>
        </member>
        <member name="M:TouchSocket.Http.MultifileCollection.GetEnumerator">
            <summary>
            获取一个迭代器。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.TouchSocketHttpUtility">
            <summary>
            HttpUtility
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.NoCacheMaxSize">
            <summary>
            非缓存上限
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.Get">
            <summary>
            Get关键字
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.Post">
            <summary>
            Post关键字
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.Put">
            <summary>
            Put关键字
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.Delete">
            <summary>
            Delete关键字
            </summary>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationChallenge">
            <summary>
            处理代理认证凭证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.#ctor(System.String,TouchSocket.Http.NetworkCredential,System.UInt32)">
            <summary>
            构造
            </summary>
            <param name="value">服务器返回的凭证认证类型</param>
            <param name="credential">基本凭证用户名密码</param>
            <param name="nonceCount">暂时不知道是什么</param>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.NonceCount">
            <summary>
            暂时不知
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Parameters">
            <summary>
            其实用不用他都一样
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Type">
            <summary>
            凭证类型
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.ToString">
            <summary>
            转换成凭证本文
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationType">
            <summary>
            代理身份认证类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.None">
            <summary>
            不允许身份认证
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Digest">
            <summary>
            指定摘要身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Basic">
            <summary>
            指定基本身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Anonymous">
            <summary>
            指定匿名身份验证。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.NetworkCredential">
            <summary>
            代理身份认证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.NetworkCredential.#ctor(System.String,System.String,System.String,System.String[])">
            <summary>
            构造
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="domain">基本认证应该不需要这个</param>
            <param name="roles"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Username">
            <summary>
            凭证用户名
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Password">
            <summary>
            凭证密码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Domain">
            <summary>
            Domain
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Roles">
            <summary>
            Roles
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpClient">
            <summary>
            Http客户端
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpClientBase">
            <summary>
            Http客户端基类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.Request(TouchSocket.Http.HttpRequest,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="request"><inheritdoc/></param>
            <param name="onlyRequest"><inheritdoc/></param>
            <param name="timeout"><inheritdoc/></param>
            <param name="token"><inheritdoc/></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.RequestContent(TouchSocket.Http.HttpRequest,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="request"></param>
            <param name="onlyRequest"></param>
            <param name="timeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.Connect(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpService`1">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpService">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpSocketClient">
            <summary>
            http辅助类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSocketClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSocketClient.OnConnecting(TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpSocketClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpSocketClient.OnReceivedHttpRequest(TouchSocket.Http.HttpRequest)">
            <summary>
            当收到到Http请求时。覆盖父类方法将不会触发插件。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpClientDataHandlingAdapter">
            <summary>
            Http客户端数据处理适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpClientDataHandlingAdapter.tempByteBlock">
            <summary>
            缓存数据，如果需要手动释放，请先判断，然后到调用<see cref="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)"/>后，再置空；
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpClientDataHandlingAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpServerDataHandlingAdapter">
            <summary>
            Http服务器数据处理适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpServerDataHandlingAdapter.tempByteBlock">
            <summary>
            缓存数据，如果需要手动释放，请先判断，然后到调用<see cref="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)"/>后，再置空；
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpServerDataHandlingAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpHeaders">
            <summary>
            请求头枚举
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.CacheControl">
            <summary>
            Cache-Control 标头，指定请求/响应链上所有缓存控制机制必须服从的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Connection">
            <summary>
            Connection 标头，指定特定连接需要的选项。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Date">
            <summary>
            Date 标头，指定开始创建请求的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.KeepAlive">
            <summary>
            Keep-Alive 标头，指定用以维护持久性连接的参数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Pragma">
            <summary>
            Pragma 标头，指定可应用于请求/响应链上的任何代理的特定于实现的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Trailer">
            <summary>
            Trailer 标头，指定标头字段显示在以 chunked 传输编码方式编码的消息的尾部。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.TransferEncoding">
            <summary>
            Transfer-Encoding 标头，指定对消息正文应用的转换的类型（如果有）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Upgrade">
            <summary>
            Upgrade 标头，指定客户端支持的附加通信协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Via">
            <summary>
            Via 标头，指定网关和代理程序要使用的中间协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Warning">
            <summary>
            Warning 标头，指定关于可能未在消息中反映的消息的状态或转换的附加信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Allow">
            <summary>
            Allow 标头，指定支持的 HTTP 方法集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLength">
            <summary>
            Content-Length 标头，指定伴随正文数据的长度（以字节为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentType">
            <summary>
            Content-Type 标头，指定伴随正文数据的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentEncoding">
            <summary>
            Content-Encoding 标头，指定已应用于伴随正文数据的编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLanguage">
            <summary>
            Content-Langauge 标头，指定伴随正文数据的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLocation">
            <summary>
            Content-Location 标头，指定可从其中获得伴随正文的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentMd5">
            <summary>
            Content-MD5 标头，指定伴随正文数据的 MD5 摘要，用于提供端到端消息完整性检查。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentRange">
            <summary>
            Content-Range 标头，指定在完整正文中应用伴随部分正文数据的位置。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expires">
            <summary>
            Expires 标头，指定日期和时间，在此之后伴随的正文数据应视为陈旧的。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.LastModified">
            <summary>
            Last-Modified 标头，指定上次修改伴随的正文数据的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Accept">
            <summary>
            Accept 标头，指定响应可接受的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptCharset">
            <summary>
            Accept-Charset 标头，指定响应可接受的字符集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptEncoding">
            <summary>
            Accept-Encoding 标头，指定响应可接受的内容编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptLanguage">
            <summary>
            Accept-Langauge 标头，指定响应首选的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Authorization">
            <summary>
            Authorization 标头，指定客户端为向服务器验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Cookie">
            <summary>
            Cookie 标头，指定向服务器提供的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expect">
            <summary>
            Expect 标头，指定客户端要求的特定服务器行为。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.From">
            <summary>
            From 标头，指定控制请求用户代理的用户的 Internet 电子邮件地址。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Host">
            <summary>
            Host 标头，指定所请求资源的主机名和端口号。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfMatch">
            <summary>
            If-Match 标头，指定仅当客户端的指示资源的缓存副本是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfModifiedSince">
            <summary>
            If-Modified-Since 标头，指定仅当自指示的数据和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfNoneMatch">
            <summary>
            If-None-Match 标头，指定仅当客户端的指示资源的缓存副本都不是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfRange">
            <summary>
            If-Range 标头，指定如果客户端的缓存副本是最新的，仅发送指定范围的请求资源。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfUnmodifiedSince">
            <summary>
            If-Unmodified-Since 标头，指定仅当自指示的日期和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.MaxForwards">
            <summary>
            Max-Forwards 标头，指定一个整数，表示此请求还可转发的次数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthorization">
            <summary>
            Proxy-Authorization 标头，指定客户端为向代理验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Referer">
            <summary>
            Referer 标头，指定从中获得请求 URI 的资源的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Range">
            <summary>
            Range 标头，指定代替整个响应返回的客户端请求的响应的子范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Te">
            <summary>
            TE 标头，指定响应可接受的传输编码方式。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Translate">
            <summary>
            Translate 标头，与 WebDAV 功能一起使用的 HTTP 规范的 Microsoft 扩展。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.UserAgent">
            <summary>
            User-Agent 标头，指定有关客户端代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptRanges">
            <summary>
            Accept-Ranges 标头，指定服务器接受的范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Age">
            <summary>
            Age 标头，指定自起始服务器生成响应以来的时间长度（以秒为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ETag">
            <summary>
            Etag 标头，指定请求的变量的当前值。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Location">
            <summary>
            Location 标头，指定为获取请求的资源而将客户端重定向到的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthenticate">
            <summary>
            Proxy-Authenticate 标头，指定客户端必须对代理验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.RetryAfter">
            <summary>
            Retry-After 标头，指定某个时间（以秒为单位）或日期和时间，在此时间之后客户端可以重试其请求。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Server">
            <summary>
            Server 标头，指定关于起始服务器代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.SetCookie">
            <summary>
            Set-Cookie 标头，指定提供给客户端的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Vary">
            <summary>
            Vary 标头，指定用于确定缓存的响应是否为新响应的请求标头。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.WwwAuthenticate">
            <summary>
            WWW-Authenticate 标头，指定客户端必须对服务器验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Origin">
            <summary>
            Origin。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentDisposition">
            <summary>
            Content-Disposition
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpContextEventArgs">
            <summary>
            Http请求事件类
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContextEventArgs.Context">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContextEventArgs.#ctor(TouchSocket.Http.HttpContext)">
            <summary>
            构造函数
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpExtensions">
            <summary>
            Http扩展辅助
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetEnum``1(System.String,``0@)">
            <summary>
            根据字符串获取枚举
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromJson``1(``0,System.String)">
            <summary>
            从Json
            </summary>
            <param name="httpRequest"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromText``1(``0,System.String)">
            <summary>
            从文本
            </summary>
            <param name="httpRequest"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromXML``1(``0,System.String)">
            <summary>
            从Xml格式
            </summary>
            <param name="httpRequest"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBody(TouchSocket.Http.HttpBase)">
            <summary>
            获取Body的字符串
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBoundary(TouchSocket.Http.HttpBase)">
            <summary>
            当数据类型为multipart/form-data时，获取boundary
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContent``1(``0,System.String,System.Text.Encoding)">
            <summary>
            设置内容
            </summary>
            <param name="httpBase"></param>
            <param name="content"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentLength``1(``0,System.Int64)">
            <summary>
            设置数据体长度
            </summary>
            <param name="httpBase"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeByExtension``1(``0,System.String)">
            <summary>
            从扩展名设置内容类型，必须以“.”开头
            </summary>
            <param name="httpBase"></param>
            <param name="extension"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetHeader``1(``0,TouchSocket.Http.HttpHeaders,System.String)">
            <summary>
            设置头值
            </summary>
            <param name="httpBase"></param>
            <param name="header"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetHeader``1(``0,System.String,System.String)">
            <summary>
            设置头值
            </summary>
            <param name="httpBase"></param>
            <param name="fieldName"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.WriteContent``1(``0,System.Byte[])">
            <summary>
            写入
            </summary>
            <param name="httpBase"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetMultifileCollection``1(``0)">
            <summary>
            获取多文件集合。如果不存在，则返回null。
            </summary>
            <typeparam name="TRequest"></typeparam>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.InitHeaders``1(``0)">
            <summary>
            初始化常规的请求头。
            <para>包含：</para>
            <list type="number">
            <item>Connection:keep-alive</item>
            <item>Pragma:no-cache</item>
            <item>UserAgent:TouchSocket.Http</item>
            <item>Accept:*/*</item>
            <item>AcceptEncoding:deflate, br</item>
            </list>
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetHost``1(``0,System.String)">
            <summary>
            添加Host请求头
            </summary>
            <param name="request"></param>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlEquals``1(``0,System.String)">
            <summary>
            对比不包含参数的Url。其中有任意一方为null，则均返回False。
            </summary>
            <param name="httpRequest"></param>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsDelete``1(``0)">
            <summary>
            作为Delete访问
            </summary>
            <param name="httpRequest"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsGet``1(``0)">
            <summary>
            作为Get访问
            </summary>
            <param name="httpRequest"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsMethod``1(``0,System.String)">
            <summary>
            作为指定函数
            </summary>
            <param name="request"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPost``1(``0)">
            <summary>
            作为Post访问
            </summary>
            <param name="httpRequest"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPut``1(``0)">
            <summary>
            作为Put访问
            </summary>
            <param name="httpRequest"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlNotFind``1(``0)">
            <summary>
            路径文件没找到
            </summary>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFile``1(``0,System.String,TouchSocket.Http.HttpRequest,System.String,System.Int32,System.Int32)">
            <summary>
            从文件响应。
            <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
            <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
            </summary>
            <param name="response">响应</param>
            <param name="request">请求头，用于尝试续传，为null时则不续传。</param>
            <param name="filePath">文件路径</param>
            <param name="fileName">文件名，不设置时会获取路径文件名</param>
            <param name="maxSpeed">最大速度（仅企业版有效）。</param>
            <param name="bufferLen">读取长度。</param>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeFromFileName``1(``0,System.String)">
            <summary>
            设置文件类型。
            </summary>
            <param name="response"></param>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0,System.String,System.String)">
            <summary>
            设置状态，并且附带时间戳。
            </summary>
            <param name="response"></param>
            <param name="status"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpPlugin">
            <summary>
            Http接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnDelete(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Delete时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnDeleteAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Delete时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnGet(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Get时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnGetAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Get时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnPost(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Post时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnPostAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Post时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnPut(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Put时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnPutAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Put时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnReceivedOtherHttpRequest(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到其他Http请求时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnReceivedOtherHttpRequestAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到其他Http请求时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IFormFile">
            <summary>
            表单文件
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentDisposition">
            <summary>
            获取Content-Disposition
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentType">
            <summary>
            获取Content-Type
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Data">
            <summary>
            实际的数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.DataPair">
            <summary>
            数据对
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.FileName">
            <summary>
            获取file name
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Length">
            <summary>
            文件长度。在数据接收完成之前，该值为-1;
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Name">
            <summary>
             获取name字段
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpClientBase">
            <summary>
            Http终端基础接口
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSocketClient">
            <summary>
            Http服务器终端接口
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpClient">
            <summary>
            Http终端接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.Request(TouchSocket.Http.HttpRequest,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求
            </summary>
            <param name="request">请求体</param>
            <param name="onlyRequest">仅仅请求，而不等待结果</param>
            <param name="timeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.RequestContent(TouchSocket.Http.HttpRequest,System.Boolean,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求，并获取数据体
            </summary>
            <param name="request">请求体</param>
            <param name="onlyRequest">仅仅请求，而不等待结果</param>
            <param name="timeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpService">
            <summary>
            HttpService接口
            </summary>
        </member>
        <member name="T:TouchSocket.Http.DefaultHttpServicePlugin">
            <summary>
            默认的Http服务。为Http做兜底拦截。该插件应该最后添加。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.#ctor">
            <summary>
            默认的Http服务。为Http做兜底拦截。该插件应该最后添加。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnLoadingConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnGet(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnPost(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnPut(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnDelete(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnReceivedOtherHttpRequest(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpPluginBase">
            <summary>
            Http扩展基类
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpPluginBase`1">
            <summary>
            Http扩展基类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnDelete(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Http.IHttpPlugin.OnDelete(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnDeleteAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Delete时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnGet(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Http.IHttpPlugin.OnGet(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnGetAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Get时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnPost(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Http.IHttpPlugin.OnPost(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnPostAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Post时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnPut(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Http.IHttpPlugin.OnPut(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnPutAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
             在收到Put时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnReceivedOtherHttpRequest(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Http.IHttpPlugin.OnReceivedOtherHttpRequest(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)"/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpPluginBase`1.OnReceivedOtherHttpRequestAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到其他Http请求时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpStaticPagePlugin">
            <summary>
            Http静态内容插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.FileCache">
            <summary>
            静态文件缓存。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加静态
            </summary>
            <param name="path">Static content path</param>
            <param name="prefix">Cache prefix (default is "/")</param>
            <param name="filter">Cache filter (default is "*.*")</param>
            <param name="timeout">Refresh cache timeout (default is 1 hour)</param>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.ClearFolder">
            <summary>
            Clear static content cache
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.RemoveFolder(System.String)">
            <summary>
            Remove static content cache
            </summary>
            <param name="path">Static content path</param>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.OnGet(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrame">
            <summary>
            WebSocket数据帧
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.FIN">
            <summary>
            是否为最后数据帧。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV1">
            <summary>
            标识RSV-1。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV2">
            <summary>
            标识RSV-2。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV3">
            <summary>
            标识RSV-3。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Opcode">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Mask">
            <summary>
            计算掩码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadLength">
            <summary>
            有效载荷数据长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.MaskingKey">
            <summary>
            掩码值
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadData">
            <summary>
            有效数据
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Build(TouchSocket.Core.ByteBlock,System.Boolean)">
            <summary>
            构建数据
            </summary>
            <param name="byteBlock"></param>
            <param name="masked"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Dispose">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSTools">
            <summary>
            WSTools
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSTools.acceptMask">
            <summary>
            应答。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.Build(TouchSocket.Core.ByteBlock,TouchSocket.Http.WebSockets.WSDataFrame,System.Byte[],System.Int32,System.Int32)">
            <summary>
            构建数据
            </summary>
            <param name="byteBlock"></param>
            <param name="dataFrame"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CalculateBase64Key(System.String)">
            <summary>
            计算Base64值
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CreateBase64Key">
            <summary>
            获取Base64随即字符串。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.DoMask(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            掩码运算
            </summary>
            <param name="storeBuf"></param>
            <param name="sOffset"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="masks"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.GetWSRequest(System.String,System.String,System.String,System.String@)">
            <summary>
            获取WS的请求头
            </summary>
            <param name="host"></param>
            <param name="url"></param>
            <param name="version"></param>
            <param name="base64Key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.TryGetResponse(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            获取响应
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClient">
            <summary>
            WebSocketClient用户终端简单实现。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Received">
            <summary>
            收到WebSocket数据
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnHandleWSDataFrame(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="dataFrame"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClientBase">
            <summary>
            WebSocket用户终端。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.Connect(System.Int32)">
            <summary>
            请求连接到WebSocket。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.Connect(System.Threading.CancellationToken,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="timeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.ConnectAsync(System.Threading.CancellationToken,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="token"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.Handshaking">
            <summary>
            表示在即将握手连接时。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.Handshaked">
            <summary>
            表示完成握手后。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnHandshaking(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnHandshaked(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnHandleWSDataFrame(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="dataFrame"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter">
            <summary>
            WebSocket适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_surPlusLength">
            <summary>
            数据包剩余长度
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_tempByteBlock">
            <summary>
            临时包
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.DecodingFromBytes(System.Byte[],System.Int32@,System.Int32,TouchSocket.Http.WebSockets.WSDataFrame@)">
            <summary>
            解码
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="dataFrame"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当发送数据前处理数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.SplitPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            分解包
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventHandler`1">
            <summary>
            收到WebSocket数据
            </summary>
            <param name="client"></param>
            <param name="dataFrame"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataType">
            <summary>
            WebSocket数据类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Cont">
            <summary>
            表示一个中间数据包，denotes a continuation frame
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Text">
            <summary>
            表示一个text类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Binary">
            <summary>
            表示一个binary类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Close">
            <summary>
            表示一个断开连接类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Ping">
            <summary>
            表示一个ping类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Pong">
            <summary>
            表示一个pong类型数据包
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventArgs">
            <summary>
            WS数据事件类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.#ctor(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构造函数
            </summary>
            <param name="dataFrame"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.DataFrame">
            <summary>
            WS数据帧。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketConnectException">
            <summary>
            WebSocket连接异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketConnectException.#ctor(System.String,TouchSocket.Http.HttpContext)">
             <summary>
            构造函数
             </summary>
             <param name="mes"></param>
             <param name="context"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketConnectException.Context">
            <summary>
            HttpContext
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketExtensions">
            <summary>
            WebSocketExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketExtensions.HeartbeatTimerProperty">
            <summary>
            心跳Timer
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketServerExtensions">
            <summary>
            WebSocketServerExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerExtensions.SwitchProtocolToWebSocket``1(``0,TouchSocket.Http.HttpContext)">
            <summary>
            转化Protocol协议标识为<see cref="F:TouchSocket.Sockets.Protocol.WebSocket"/>
            </summary>
            <param name="client"></param>
            <param name="httpContext">Http上下文</param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerExtensions.SwitchProtocolToWebSocketAsync``1(``0,TouchSocket.Http.HttpContext)">
            <summary>
            转化Protocol协议标识为<see cref="F:TouchSocket.Sockets.Protocol.WebSocket"/>
            </summary>
            <param name="client"></param>
            <param name="httpContext">Http上下文</param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSClientExtensions">
            <summary>
            IWSClientBase辅助扩展
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.GetHandshaked(TouchSocket.Http.IHttpClientBase)">
            <summary>
            是否已经完成握手
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.GetWebSocketVersion(TouchSocket.Http.IHttpClientBase)">
            <summary>
            获取WebSocket版本号。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SetWebSocketVersion(TouchSocket.Http.IHttpClientBase,System.String)">
            <summary>
            设置WebSocket版本号。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.Ping(TouchSocket.Http.HttpClientBase)">
            <summary>
            发送Ping报文。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.Pong(TouchSocket.Http.HttpClientBase)">
            <summary>
            发送Pong报文。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.CloseWithWS(TouchSocket.Http.HttpClientBase,System.String)">
            <summary>
            发送Close报文。
            </summary>
            <param name="client"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32,System.Int32)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpClientBase,TouchSocket.Core.ByteBlock)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpClientBase,System.Byte[])">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpClientBase,System.String)">
            <summary>
            采用WebSocket协议，发送文本数据。
            </summary>
            <param name="client"></param>
            <param name="text"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpClientBase,TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            采用WebSocket协议，发送WS数据。
            </summary>
            <param name="client"></param>
            <param name="dataFrame"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32,System.Int32)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpClientBase,TouchSocket.Core.ByteBlock)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpClientBase,System.Byte[])">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpClientBase,System.String)">
            <summary>
            采用WebSocket协议，发送文本数据。
            </summary>
            <param name="client"></param>
            <param name="text"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpClientBase,TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            采用WebSocket协议，发送WS数据。
            </summary>
            <param name="client"></param>
            <param name="dataFrame"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpClientBase,TouchSocket.Core.ByteBlock,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpClientBase,System.Byte[],System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpClientBase,TouchSocket.Core.ByteBlock,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.Ping(TouchSocket.Http.HttpSocketClient)">
            <summary>
            发送Ping报文。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.Pong(TouchSocket.Http.HttpSocketClient)">
            <summary>
            发送Pong报文。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.CloseWithWS(TouchSocket.Http.HttpSocketClient,System.String)">
            <summary>
            发送Close报文。
            </summary>
            <param name="client"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32,System.Int32)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpSocketClient,TouchSocket.Core.ByteBlock)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpSocketClient,System.Byte[])">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpSocketClient,System.String)">
            <summary>
            采用WebSocket协议，发送文本数据。
            </summary>
            <param name="client"></param>
            <param name="text"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWS(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            采用WebSocket协议，发送WS数据。
            </summary>
            <param name="client"></param>
            <param name="dataFrame"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32,System.Int32)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpSocketClient,TouchSocket.Core.ByteBlock)">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpSocketClient,System.Byte[])">
            <summary>
            采用WebSocket协议，发送二进制流数据。
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpSocketClient,System.String)">
            <summary>
            采用WebSocket协议，发送文本数据。
            </summary>
            <param name="client"></param>
            <param name="text"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SendWithWSAsync(TouchSocket.Http.HttpSocketClient,TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            采用WebSocket协议，发送WS数据。
            </summary>
            <param name="client"></param>
            <param name="dataFrame"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWS(TouchSocket.Http.HttpSocketClient,TouchSocket.Core.ByteBlock,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpSocketClient,System.Byte[],System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="buffer"></param>
            <param name="packageSize"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSClientExtensions.SubSendWithWSAsync(TouchSocket.Http.HttpSocketClient,TouchSocket.Core.ByteBlock,System.Int32)">
            <summary>
            分包发送。
            <para>
            按packageSize的值，每次发送数据包。
            </para>
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
            <param name="packageSize"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameExtensions">
            <summary>
            WSDataFrame辅助扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.AppendText(TouchSocket.Http.WebSockets.WSDataFrame,System.String,System.Text.Encoding)">
            <summary>
            追加文本
            </summary>
            <param name="dataFrame"></param>
            <param name="text"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.AppendBinary(TouchSocket.Http.WebSockets.WSDataFrame,System.Byte[],System.Int32,System.Int32)">
            <summary>
            追加二进制流
            </summary>
            <param name="dataFrame"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.BuildRequest(TouchSocket.Http.WebSockets.WSDataFrame,TouchSocket.Core.ByteBlock)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame"></param>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.BuildRequestToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.BuildResponse(TouchSocket.Http.WebSockets.WSDataFrame,TouchSocket.Core.ByteBlock)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame"></param>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.BuildResponseToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.SetMaskString(TouchSocket.Http.WebSockets.WSDataFrame,System.String)">
            <summary>
            设置Mask。
            </summary>
            <param name="dataFrame"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameExtensions.ToText(TouchSocket.Http.WebSockets.WSDataFrame,System.Text.Encoding)">
            <summary>
            当<see cref="F:TouchSocket.Http.WebSockets.WSDataType.Text"/>时，转换为Text消息。
            </summary>
            <param name="dataFrame"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClient">
            <summary>
            用户终端接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClient.Connect(System.Threading.CancellationToken,System.Int32)">
            <summary>
            连接到ws服务器
            </summary>
            <param name="token"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClient.ConnectAsync(System.Threading.CancellationToken,System.Int32)">
            <summary>
            异步连接到ws服务器
            </summary>
            <param name="token"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketPlugin">
            <summary>
            WebSocket插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnClosing(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnClosingAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandleWSDataFrame(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandleWSDataFrameAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandshaked(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandshakedAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandshaking(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketPlugin.OnHandshakingAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin">
            <summary>
            WebSocketHeartbeatPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin.#ctor(System.Int32)">
            <summary>
            初始化一个适用于WebSocket的心跳插件
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin.OnHandshaked(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin.OnDisconnected(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketPluginBase">
            <summary>
            WS插件基类
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketPluginBase`1">
            <summary>
            WS插件基类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnClosing(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnClosingAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandleWSDataFrame(`0,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            处理WS数据帧。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandleWSDataFrameAsync(`0,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            处理WS数据帧。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandshaked(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandshakedAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandshaking(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            <para>在此处拒绝操作，则会返回403 Forbidden。</para>
            <para>也可以向<see cref="P:TouchSocket.Http.HttpContextEventArgs.Context"/>注入更多信息。</para>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketPluginBase`1.OnHandshakingAsync(`0,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketServerPlugin">
            <summary>
            基于Http的WebSocket的扩展。
            <para>此组件只能挂载在<see cref="T:TouchSocket.Http.HttpService"/>中</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketServerPlugin.HandshakedProperty">
            <summary>
            表示是否完成WS握手
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketServerPlugin.WebSocketVersionProperty">
            <summary>
            表示WebSocketVersion
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.#ctor(TouchSocket.Core.IPluginsManager)">
            <summary>
            WebSocketServerPlugin
            </summary>
            <param name="pluginsManager"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketServerPlugin.AutoClose">
            <summary>
            是否默认处理Close报文。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketServerPlugin.HandleWSDataFrameCallback">
            <summary>
            处理WS数据的回调
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketServerPlugin.WSUrl">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.NoAutoClose">
            <summary>
            不处理Close报文。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.SetCallback(System.Action{TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs})">
            <summary>
            设置处理WS数据的回调。
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.SetWSUrl(System.String)">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.OnGet(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.OnHandleWSDataFrame(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            处理WS数据帧。覆盖父类方法将不会触发<see cref="P:TouchSocket.Http.WebSockets.WebSocketServerPlugin.HandleWSDataFrameCallback"/>回调和插件。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketServerPlugin.OnReceivedData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSCommandLinePlugin">
            <summary>
            WS命令行插件。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSCommandLinePlugin.Converter">
            <summary>
            字符串转换器，默认支持基础类型和Json。可以自定义。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSCommandLinePlugin.ReturnException">
            <summary>
            是否返回执行异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSCommandLinePlugin.NoReturnException">
            <summary>
            当有执行异常时，不返回异常。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSCommandLinePlugin.#ctor(TouchSocket.Core.ILog)">
            <summary>
            WSCommandLinePlugin
            </summary>
            <param name="logger"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSCommandLinePlugin.OnHandleWSDataFrame(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Sockets.HttpConfigExtensions">
            <summary>
            HttpConfigExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.BuildWithHttpClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Http类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.BuildWithHttpClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Http类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.BuildWithHttpService``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Http类服务器，并启动。
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.BuildWithHttpService(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Http类服务器，并启动。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.HttpConfigExtensions.HttpProxyProperty">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.SetHttpProxy(TouchSocket.Core.TouchSocketConfig,TouchSocket.Http.HttpProxy)">
             <summary>
            设置Http代理
             </summary>
             <param name="config"></param>
             <param name="value"></param>
             <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.WebSocketConfigExtensions">
            <summary>
            WebSocketConfigExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WebSocketConfigExtensions.BuildWithWebSocketClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建WebSocketClient类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.WebSocketConfigExtensions.BuildWithWebSocketClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建WebSocketClient类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.JsonRpcConfigExtensions">
            <summary>
            JsonRpcConfigExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.JsonRpcConfigExtensions.BuildWithJsonRpcClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建JsonRpc类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.JsonRpcConfigExtensions.BuildWithJsonRpcClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建JsonRpc类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Sockets.JsonRpcConfigExtensions.TcpJsonRpc">
            <summary>
            TcpJsonRpc
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.JsonRpcConfigExtensions.SwitchProtocolToTcpJsonRpc(TouchSocket.Sockets.ITcpClientBase)">
            <summary>
            转化Protocol协议标识
            </summary>
            <param name="client"></param>
        </member>
        <member name="F:TouchSocket.Sockets.JsonRpcConfigExtensions.JRPTProperty">
            <summary>
            设置JsonRpc的协议。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.JsonRpcConfigExtensions.SetJRPT(TouchSocket.Core.TouchSocketConfig,TouchSocket.Rpc.JsonRpc.JRPT)">
            <summary>
            设置JsonRpc的协议。默认为<see cref="F:TouchSocket.Rpc.JsonRpc.JRPT.Tcp"/>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.WebApiConfigExtensions">
            <summary>
            WebApiConfigExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WebApiConfigExtensions.BuildWithWebApiClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建WebApiClient类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.WebApiConfigExtensions.BuildWithWebApiClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
             构建WebApiClient类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.XmlRpcConfigExtensions">
            <summary>
            XmlRpcConfigExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.XmlRpcConfigExtensions.BuildWithXmlRpcClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建XmlRpcClient类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.XmlRpcConfigExtensions.BuildWithXmlRpcClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建XmlRpcClient类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.BaseSocket">
            <summary>
            通讯基类
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.BaseSocket.#ctor">
            <summary>
            通讯基类
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.BaseSocket.BufferLength">
            <summary>
            数据交互缓存池限制，min=1024 byte
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.BaseSocket.SyncRoot">
            <summary>
            同步根。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.BaseSocket.Logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.DelaySender">
            <summary>
            延迟发送器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DelaySender.#ctor(System.Net.Sockets.Socket,System.Int32,System.Action{System.Exception})">
            <summary>
            延迟发送器
            </summary>
            <param name="socket"></param>
            <param name="queueLength"></param>
            <param name="onError"></param>
        </member>
        <member name="P:TouchSocket.Sockets.DelaySender.DelayLength">
            <summary>
            延迟包最大尺寸，默认1024*512字节。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DelaySender.Sending">
            <summary>
            是否处于发送状态
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DelaySender.Send(TouchSocket.Core.QueueDataBytes)">
            <summary>
            发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DelaySender.Dispose(System.Boolean)">
            <summary>
            释放
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Sockets.IPHost">
            <summary>
            IP解析映射
            <para>
            支持端口，ip，域名等。具体格式如下：
            <list type=" number">
            <item>端口：直接按<see cref="T:System.Int32"/>入参，该操作一般在监听时使用。</item>
            <item>ip：按127.0.0.1:7789入参。</item>
            <item>域名：按tcp://127.0.0.1:7789、或者http://baidu.com入参。</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.#ctor(System.String)">
            <summary>
            IP解析映射
            <para>
            支持端口，ip，域名等。具体格式如下：
            <list type=" number">
            <item>端口：直接按<see cref="T:System.Int32"/>入参，该操作一般在监听时使用。</item>
            <item>ip：按127.0.0.1:7789入参。</item>
            <item>域名：按tcp://127.0.0.1:7789、或者http://baidu.com入参。</item>
            </list>
            </para>
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            从IPAddress和端口号
            </summary>
            <param name="iPAddress"></param>
            <param name="port"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.#ctor(System.Int32)">
            <summary>
            从端口号创建。
            </summary>
            <param name="port"></param>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.AddressFamily">
            <summary>
            寻址方案
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.EndPoint">
            <summary>
            终结点
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.Host">
            <summary>
            具有端口信息的host
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.IP">
            <summary>
            IP
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.IsUri">
            <summary>
            是否为Uri
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.Port">
            <summary>
            端口号
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IPHost.Uri">
            <summary>
            统一资源标识
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.ParseIPHosts(System.String[])">
            <summary>
            解析一个组的地址。
            </summary>
            <param name="strs"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.GetUrlPath">
            <summary>
            获取Url全路径
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.IPHost.ToString">
            <summary>
            返回EndPoint字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.KeepAliveValue">
            <summary>
            保活机制
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.KeepAliveValue.KeepAliveTime">
            <summary>
            保活机制
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.KeepAliveValue.Enable">
            <summary>
            是否启用保活。默认为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.KeepAliveValue.Interval">
            <summary>
            发送间隔，默认20*1000ms
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.KeepAliveValue.AckInterval">
            <summary>
            确认间隔，默认2*1000ms
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.NetworkMonitor">
            <summary>
            网络监听器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NetworkMonitor.#ctor(TouchSocket.Sockets.IPHost,System.Net.Sockets.Socket)">
            <summary>
            构造函数
            </summary>
            <param name="iPHost"></param>
            <param name="socket"></param>
        </member>
        <member name="P:TouchSocket.Sockets.NetworkMonitor.IPHost">
            <summary>
            监听地址组
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.NetworkMonitor.Socket">
            <summary>
            Socket组件
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientSslOption">
            <summary>
            客户端Ssl验证
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientSslOption.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientSslOption.TargetHost">
            <summary>
            目标Host
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientSslOption.ClientCertificates">
            <summary>
            验证组合
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.DelaySenderOption">
            <summary>
            DelaySenderOption
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DelaySenderOption.QueueLength">
            <summary>
            延迟队列最大尺寸，默认1024*1024*10字节。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DelaySenderOption.DelayLength">
            <summary>
            延迟包最大尺寸，默认1024*512字节。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ServiceSslOption">
            <summary>
            服务器Ssl设置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ServiceSslOption.Certificate">
            <summary>
            证书
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ServiceSslOption.ClientCertificateRequired">
            <summary>
            该值指定是否向客户端请求证书用于进行身份验证。 请注意，这只是一个请求 - 如果没有提供任何证书，服务器仍然可接受连接请求
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.SslOption">
            <summary>
            Ssl配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SslOption.SslProtocols">
            <summary>
            协议版本
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SslOption.CheckCertificateRevocation">
            <summary>
            该值指定身份验证期间是否检查证书吊销列表
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SslOption.CertificateValidationCallback">
            <summary>
            SSL验证回调。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.Protocol">
            <summary>
            协议类
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.value">
            <summary>
            值
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.None">
            <summary>
            表示无协议
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.Http">
            <summary>
            获取http协议
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.TCP">
            <summary>
            TCP协议
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.UDP">
            <summary>
            UDP协议
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.Protocol.WebSocket">
            <summary>
            获取WebSocket协议
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.#ctor(System.String)">
            <summary>
            表示
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.ToString">
            <summary>
            转换为字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.GetHashCode">
            <summary>
            获取哈希码
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.Equals(System.Object)">
            <summary>
            比较是否和目标相等
            </summary>
            <param name="obj">目标</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.op_Equality(TouchSocket.Sockets.Protocol,TouchSocket.Sockets.Protocol)">
            <summary>
            等于
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.Protocol.op_Inequality(TouchSocket.Sockets.Protocol,TouchSocket.Sockets.Protocol)">
            <summary>
            不等于
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.SocketClientCollection">
            <summary>
            客户端集合
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClientCollection.Count">
            <summary>
            数量
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClientCollection.Item(System.String)">
            <summary>
            获取SocketClient
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClientCollection.GetClients">
            <summary>
            获取所有的客户端
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClientCollection.GetIDs">
            <summary>
            获取ID集合
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClientCollection.SocketClientExist(System.String)">
            <summary>
            根据ID判断SocketClient是否存在
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClientCollection.TryGetSocketClient(System.String,TouchSocket.Sockets.ISocketClient@)">
            <summary>
            尝试获取实例
            </summary>
            <param name="id"></param>
            <param name="socketClient"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClientCollection.TryGetSocketClient``1(System.String,``0@)">
            <summary>
            尝试获取实例
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="id"></param>
            <param name="socketClient"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.TouchSocketUtility">
            <summary>
            TouchSocketUtility
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketUtility.IsURL(System.String)">
            <summary>
            判断输入的字符串是否是一个超链接
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketUtility.IsIPv4(System.String)">
            <summary>
            判断输入的字符串是否是表示一个IP地址
            </summary>
            <param name="input">被比较的字符串</param>
            <returns>是IP地址则为True</returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketUtility.IsIPV6(System.String)">
            <summary>
            判断输入的字符串是否是合法的IPV6 地址
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketUtility.BigDataBoundary">
            <summary>
            大数据边界
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientFactory`1">
            <summary>
            Client工厂
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.#ctor">
            <summary>
            Client工厂
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.CreatedClients">
            <summary>
            已创建的客户端安全列表，一般不要直接操作。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.FreeClients">
            <summary>
            空闲客户端的安全队列，一般不要直接操作。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.MainClient">
            <summary>
            主通信客户端。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.MainConfig">
            <summary>
            主客户端配置
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.MaxCount">
            <summary>
            最大客户端数量。默认10。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ClientFactory`1.MinCount">
            <summary>
            池中维护的最小客户端数量。默认0。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.CheckStatus(System.Boolean)">
            <summary>
            检验主通信状态。最好在每次操作时都调用。
            </summary>
            <param name="tryInit">如果状态异常，是否进行再次初始化</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.Clear">
            <summary>
            清理池中的所有客户端。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.DisposeClient(`0)">
            <summary>
            释放客户端最后的调用。
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.GetAvailableCount">
            <summary>
            获取空闲可用的客户端数量。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.GetTransferClient(System.TimeSpan)">
            <summary>
            获取用于传输的客户端。在此处返回的结果，必须完成基本初始化，例如连接等。
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.IsAlive(`0)">
            <summary>
            判断客户端是不是存活状态。
            </summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.ReleaseTransferClient(`0)">
            <summary>
            释放使用完成的客户端
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.ClientFactory`1.GetTransferConfig">
            <summary>
            获取用于传输的客户端配置
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.TcpClientFactory`1">
            <summary>
            适用于Tcp客户端的连接工厂。
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.#ctor">
            <summary>
            适用于Tcp客户端的连接工厂。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientFactory`1.ConnectTimeout">
            <summary>
            连接超时设定
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientFactory`1.MainClient">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientFactory`1.OnGetTransferConfig">
            <summary>
            获取传输的客户端配置
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.CheckStatus(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.OnMainClientSetuping">
            <summary>
            在主客户端加载配置之前
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.DisposeClient(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.GetAvailableCount">
            <summary>
            获取可以使用的客户端数量。
            <para>
            注意：该值不一定是<see cref="P:TouchSocket.Sockets.ClientFactory`1.FreeClients"/>的长度，当已创建数量小于设定的最大值时，也会累加未创建的值。
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.GetTransferClient(System.Int32)">
            <summary>
            获取一个空闲的连接对象，如果等待超出设定的时间，则会创建新的连接。
            </summary>
            <param name="waitTime">指定毫秒数</param>
            <returns></returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.GetTransferClient">
            <summary>
            获取一个空闲的连接对象，如果等待超出1秒的时间，则会创建新的连接。
            </summary>
            <returns></returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.GetTransferClient(System.TimeSpan)">
            <summary>
            获取一个空闲的连接对象，如果等待超出设定的时间，则会创建新的连接。
            </summary>
            <param name="waitTime"></param>
            <returns></returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.IsAlive(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.ReleaseTransferClient(`0)">
            <summary>
            归还使用完的连接。
            <para>
            首先内部会判定存活状态，如果不再活动状态，会直接调用<see cref="M:TouchSocket.Sockets.TcpClientFactory`1.DisposeClient(`0)"/>。
            其次会计算是否可以进入缓存队列，如果队列数量超出<see cref="P:TouchSocket.Sockets.ClientFactory`1.MaxCount"/>，也会直接调用<see cref="M:TouchSocket.Sockets.TcpClientFactory`1.DisposeClient(`0)"/>
            </para>
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientFactory`1.GetTransferConfig">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Sockets.TcpClientFactory">
            <summary>
             适用于基于<see cref="T:TouchSocket.Sockets.TcpClient"/>的连接工厂。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.NATService">
            <summary>
            TCP端口转发服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NATService.GetClientInstence">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.NATService.OnNATReceived(TouchSocket.Sockets.NATSocketClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            在NAT服务器收到数据时。
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
            <returns>需要转发的数据。</returns>
        </member>
        <member name="M:TouchSocket.Sockets.NATService.OnReceived(TouchSocket.Sockets.NATSocketClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NATService.OnTargetClientDisconnected(TouchSocket.Sockets.NATSocketClient,TouchSocket.Sockets.ITcpClient,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            当目标客户端断开。
            </summary>
            <param name="socketClient"></param>
            <param name="tcpClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NATService.OnTargetClientReceived(TouchSocket.Sockets.NATSocketClient,TouchSocket.Sockets.ITcpClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            在目标客户端收到数据时。
            </summary>
            <param name="socketClient"></param>
            <param name="tcpClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.NATSocketClient">
            <summary>
            端口转发辅助
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NATSocketClient.AddTargetClient(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            添加转发客户端。
            </summary>
            <param name="config">配置文件</param>
            <param name="setupAction">当完成配置，但是还未连接时回调。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.NATSocketClient.AddTargetClientAsync(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            添加转发客户端。
            </summary>
            <param name="config">配置文件</param>
            <param name="setupAction">当完成配置，但是还未连接时回调。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.NATSocketClient.GetTargetClients">
            <summary>
            获取所有目标客户端
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.NATSocketClient.SendToTargetClient(System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送数据到全部转发端。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NATSocketClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Sockets.SocketClient">
            <summary>
            服务器辅助类
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.IsClient">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.CanSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.CanSetDataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Config">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.DataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.ID">
            <summary>
            用于索引的ID
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.IP">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.MainSocket">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Online">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Port">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Protocol">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.ReceiveType">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Service">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.UsePlugin">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.UseSsl">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Disconnected">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.Disconnecting">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnDisconnecting(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnConnected(TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            当客户端完整建立TCP连接，如果覆盖父类方法，则不会触发插件。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnConnecting(TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            客户端正在连接，如果覆盖父类方法，则不会触发插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnDelaySenderError(System.Exception)">
            <summary>
            在延迟发生错误
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            客户端已断开连接，如果从Connecting中拒绝连接，则不会触发。如果覆盖父类方法，则不会触发插件。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.OnInitialized">
            <summary>
            当初始化完成时，执行在<see cref="M:TouchSocket.Sockets.SocketClient.OnConnecting(TouchSocket.Sockets.OperationEventArgs)"/>之前。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.LastReceivedTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.LastSendTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.OnHandleRawBuffer">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.OnHandleReceivedData">
             <summary>
            <inheritdoc/>
             </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.ServiceIP">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SocketClient.ServicePort">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Close">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Close(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.GetStream">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.DirectResetID(System.String)">
            <summary>
            直接重置内部ID。
            </summary>
            <param name="newId"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.ResetID(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="newId"></param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SetDataHandlingAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理已接收到的数据。
            <para>根据不同的数据处理适配器，会传递不同的数据</para>
            </summary>
            <param name="byteBlock">以二进制流形式传递</param>
            <param name="requestInfo">以解析的数据对象传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.HandleSendingData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当即将发送时，如果覆盖父类方法，则不会触发插件。
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <returns>返回值表示是否允许发送</returns>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SetAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            设置适配器，该方法不会检验<see cref="P:TouchSocket.Sockets.SocketClient.CanSetDataHandlingAdapter"/>的值。
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.DefaultSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.DefaultSendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"><inheritdoc/></param>
            <param name="offset"><inheritdoc/></param>
            <param name="length"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Send(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            IOCP发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SendAsync(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Send(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节流
            </summary>
            <param name="id">用于检索TcpSocketClient</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.Send(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SendAsync(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节流
            </summary>
            <param name="id">用于检索TcpSocketClient</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.SocketClient.SendAsync(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpClient">
            <summary>
            简单TCP客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClient.Received">
            <summary>
            接收到数据
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            接收数据
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpClientBase">
            <summary>
            TCP客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Connected">
            <summary>
            成功连接到服务器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Connecting">
            <summary>
            准备连接的时候，此时已初始化Socket，但是并未建立Tcp连接
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Disconnected">
            <summary>
            断开连接。在客户端未设置连接状态时，不会触发
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Disconnecting">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.OnConnected(TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            已经建立Tcp连接
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.OnConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <summary>
            准备连接的时候，此时已初始化Socket，但是并未建立Tcp连接
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            断开连接。在客户端未设置连接状态时，不会触发
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.OnDisconnecting(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.LastReceivedTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.LastSendTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.OnHandleRawBuffer">
            <summary>
            处理未经过适配器的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.OnHandleReceivedData">
            <summary>
            处理经过适配器后的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.CanSetDataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Config">
            <summary>
            客户端配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.IP">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.MainSocket">
            <summary>
            主通信器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.CanSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Online">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Port">
            <summary>
            端口号
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.ReceiveType">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.UsePlugin">
            <summary>
            是否已启用插件
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.UseSsl">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.Protocol">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.RemoteIPHost">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpClientBase.IsClient">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Close">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Close(System.String)">
            <summary>
            中断终端，传递中断消息。
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.TcpConnect(System.Int32)">
            <summary>
            建立Tcp的连接。
            </summary>
            <param name="timeout"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.TimeoutException"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Connect(System.Int32)">
            <summary>
            请求连接到服务器。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.ConnectAsync(System.Int32)">
            <summary>
            异步连接服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.GetStream">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.SetDataHandlingAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            设置数据处理适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Setup(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="ipHost"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            配置服务器
            </summary>
            <param name="config"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理已接收到的数据。
            </summary>
            <param name="byteBlock">以二进制流形式传递</param>
            <param name="requestInfo">以解析的数据对象传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.HandleSendingData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当即将发送时，如果覆盖父类方法，则不会触发插件。
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <returns>返回值表示是否允许发送</returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.OnDelaySenderError(System.Exception)">
            <summary>
            在延迟发生错误
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.SetAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            设置适配器，该方法不会检验<see cref="P:TouchSocket.Sockets.TcpClientBase.CanSetDataHandlingAdapter"/>的值。
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.HandleBuffer(TouchSocket.Core.ByteBlock)">
            <summary>
            处理数据
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Send(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"><inheritdoc/></param>
            <param name="offset"><inheritdoc/></param>
            <param name="length"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"><inheritdoc/></param>
            <param name="offset"><inheritdoc/></param>
            <param name="length"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.SendAsync(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.DefaultSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"><inheritdoc/></param>
            <param name="offset"><inheritdoc/></param>
            <param name="length"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpClientBase.DefaultSendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"><inheritdoc/></param>
            <param name="offset"><inheritdoc/></param>
            <param name="length"><inheritdoc/></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"><inheritdoc/></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"><inheritdoc/></exception>
            <exception cref="T:System.Exception"><inheritdoc/></exception>
        </member>
        <member name="T:TouchSocket.Sockets.TcpService`1">
            <summary>
            TCP泛型服务器，由客户自己指定<see cref="T:TouchSocket.Sockets.SocketClient"/>类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Config">
            <summary>
            获取服务器配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.GetDefaultNewID">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.MaxCount">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Monitors">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.ServerName">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.ServerState">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.SocketClients">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.UsePlugin">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.UseSsl">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Connected">
            <summary>
            用户连接完成
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Connecting">
            <summary>
            有用户连接的时候
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Disconnected">
            <summary>
            有用户断开连接
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.Disconnecting">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService`1.IDChanged">
            <summary>
            当客户端ID被修改时触发。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnClientConnected(TouchSocket.Sockets.ISocketClient,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnClientConnecting(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnClientDisconnected(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnClientDisconnecting(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnClientReceivedData(TouchSocket.Sockets.ISocketClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnConnected(`0,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            客户端连接完成，覆盖父类方法将不会触发事件。
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnConnecting(`0,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            客户端请求连接，覆盖父类方法将不会触发事件。
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnDisconnected(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            客户端断开连接，覆盖父类方法将不会触发事件。
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnDisconnecting(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnReceived(`0,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            当收到适配器数据。
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Clear">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.GetClients">
            <summary>
            获取当前在线的所有客户端
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.ResetID(System.String,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="oldID"></param>
            <param name="newID"></param>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Setup(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.SocketClientExist(System.String)">
             <summary>
            <inheritdoc/>
             </summary>
             <param name="id"></param>
             <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Start">
            <summary>
            <inheritdoc/>
            </summary>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Stop">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.TryGetSocketClient(System.String,`0@)">
            <summary>
            尝试获取TClient
            </summary>
            <param name="id">ID</param>
            <param name="socketClient">TClient</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.GetClientInstence">
            <summary>
            初始化客户端实例，默认实现为<see cref="M:TouchSocket.Core.Container.Resolve(System.Type,System.Object[],System.String)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.OnAuthenticatingError(System.Exception)">
            <summary>
            在验证Ssl发送错误时。
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService`1.PreviewBind(System.Net.Sockets.Socket)">
            <summary>
            在Socket初始化对象后，Bind之前调用。
            可用于设置Socket参数。
            父类方法可覆盖。
            </summary>
            <param name="socket"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpService">
            <summary>
            TCP服务器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpService.Received">
            <summary>
            处理数据
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpService.OnReceived(TouchSocket.Sockets.SocketClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpServiceBase">
            <summary>
            Tcp服务器基类
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.Config">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.Count">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.Monitors">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.PluginsManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.ServerName">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.ServerState">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.SocketClients">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.UseSsl">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.GetDefaultNewID">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.MaxCount">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpServiceBase.UsePlugin">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Clear">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.GetIDs">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.ResetID(System.String,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="oldID"></param>
            <param name="newID"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="serverConfig"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Setup(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Start">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Stop">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.OnClientConnected(TouchSocket.Sockets.ISocketClient,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            客户端连接完成
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.OnClientConnecting(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            客户端请求连接
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.OnClientDisconnected(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            客户端断开连接
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.OnClientDisconnecting(TouchSocket.Sockets.ISocketClient,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.OnClientReceivedData(TouchSocket.Sockets.ISocketClient,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            收到数据时
            </summary>
            <param name="socketClient"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Send(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节流
            </summary>
            <param name="id">用于检索TcpSocketClient</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.Send(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.SendAsync(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节流
            </summary>
            <param name="id">用于检索TcpSocketClient</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.SendAsync(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpServiceBase.SocketClientExist(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.UdpSession">
            <summary>
            简单UDP会话。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSession.Received">
            <summary>
            当收到数据时
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSession.HandleReceivedData(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:TouchSocket.Sockets.UdpSessionBase">
            <summary>
            UDP基类服务器。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.OnHandleRawBuffer">
            <summary>
            处理未经过适配器的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.OnHandleReceivedData">
            <summary>
            处理经过适配器后的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.CanSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.CanSetDataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.Config">
            <summary>
            获取配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.LastReceivedTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.LastSendTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.Monitor">
            <summary>
            监听器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.Protocol">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.RemoteIPHost">
            <summary>
            默认远程节点
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.ServerName">
            <summary>
            服务器名称
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.ServerState">
            <summary>
            获取服务器状态
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionBase.UsePlugin">
            <summary>
            是否已启用插件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.DropMulticastGroup(System.Net.IPAddress)">
            <summary>
            退出组播
            </summary>
            <param name="multicastAddr"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.JoinMulticastGroup(System.Net.IPAddress)">
            <summary>
            加入组播。
            <para>组播地址为 224.0.0.0 ~ 239.255.255.255，其中 224.0.0.0~224.255.255.255 不建议在用户程序中使用，因为它们一般都有特殊用途。</para>
            </summary>
            <param name="multicastAddr"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SetDataHandlingAdapter(TouchSocket.Sockets.UdpDataHandlingAdapter)">
            <summary>
            设置数据处理适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Setup(System.Int32)">
            <summary>
            通过端口配置
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Start">
            <summary>
            启动服务
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Stop">
            <summary>
            停止服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.HandleReceivedData(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理已接收到的数据。
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock">以二进制流形式传递</param>
            <param name="requestInfo">以解析的数据对象传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.HandleSendingData(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            当即将发送时，如果覆盖父类方法，则不会触发插件。
            </summary>
            <param name="endPoint"></param>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <returns>返回值表示是否允许发送</returns>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.PreviewBind(System.Net.Sockets.Socket)">
            <summary>
            在Socket初始化对象后，Bind之前调用。
            可用于设置Socket参数。
            父类方法可覆盖。
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SetAdapter(TouchSocket.Sockets.UdpDataHandlingAdapter)">
            <summary>
            设置适配器，该方法不会检验<see cref="P:TouchSocket.Sockets.UdpSessionBase.CanSetDataHandlingAdapter"/>的值。
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            向默认终结点发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Send(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            IOCP发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SendAsync(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Send(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向设置的远程同步发送
            </summary>
            <param name="remoteEP"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SendAsync(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向设置的远程异步发送
            </summary>
            <param name="remoteEP"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException"></exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.DefaultSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.DefaultSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.DefaultSendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.DefaultSendAsync(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.Send(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionBase.SendAsync(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TouchSocketConfigExtension">
            <summary>
            TouchSocketConfigBuilder配置扩展
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.BufferLengthProperty">
            <summary>
            接收缓存容量，默认1024*64，其作用有两个：
            <list type="number">
            <item>指示单次可接受的最大数据量</item>
            <item>指示常规申请内存块的长度</item>
            </list>
            所需类型<see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.DataHandlingAdapterProperty">
            <summary>
            数据处理适配器，默认为获取<see cref="T:TouchSocket.Sockets.NormalDataHandlingAdapter"/>
            所需类型<see cref="T:System.Func`1"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.ReceiveTypeProperty">
            <summary>
            接收类型，默认为<see cref="F:TouchSocket.Sockets.ReceiveType.Auto"/>
            <para><see cref="F:TouchSocket.Sockets.ReceiveType.Auto"/>为自动接收数据，然后主动触发。</para>
            <para><see cref="F:TouchSocket.Sockets.ReceiveType.None"/>为不投递IO接收申请，用户可通过<see cref="M:TouchSocket.Sockets.ITcpClientBase.GetStream"/>，获取到流以后，自己处理接收。注意：连接端不会感知主动断开</para>
            所需类型<see cref="T:TouchSocket.Sockets.ReceiveType"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.UdpDataHandlingAdapterProperty">
            <summary>
            数据处理适配器，默认为获取<see cref="T:TouchSocket.Sockets.UdpDataHandlingAdapter"/>
            所需类型<see cref="T:System.Func`1"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetBufferLength(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            接收缓存容量，默认1024*64，其作用有两个：
            <list type="number">
            <item>指示单次可接受的最大数据量</item>
            <item>指示常规申请内存块的长度</item>
            </list>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetDataHandlingAdapter(TouchSocket.Core.TouchSocketConfig,System.Func{TouchSocket.Sockets.DataHandlingAdapter})">
            <summary>
            设置(Tcp系)数据处理适配器。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetReceiveType(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.ReceiveType)">
            <summary>
            接收类型，默认为<see cref="F:TouchSocket.Sockets.ReceiveType.Auto"/>
            <para><see cref="F:TouchSocket.Sockets.ReceiveType.Auto"/>为自动接收数据，然后主动触发。</para>
            <para><see cref="F:TouchSocket.Sockets.ReceiveType.None"/>为不投递IO接收申请，用户可通过<see cref="M:TouchSocket.Sockets.ITcpClientBase.GetStream"/>，获取到流以后，自己处理接收。注意：连接端不会感知主动断开</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetUdpDataHandlingAdapter(TouchSocket.Core.TouchSocketConfig,System.Func{TouchSocket.Sockets.UdpDataHandlingAdapter})">
            <summary>
            设置(Udp系)数据处理适配器。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.ServerNameProperty">
            <summary>
            服务名称，用于标识，无实际意义，所需类型<see cref="T:System.String"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.ThreadCountProperty">
            <summary>
            多线程数量。默认-1缺省。
            <para>TCP模式中，该值等效于<see cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)"/></para>
            <para>UDP模式中，该值为重叠IO并发数</para>
            所需类型<see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetServerName(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            服务名称，用于标识，无实际意义
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetThreadCount(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            多线程数量，默认为-1缺省，实际上在tcp中相当于值10，udp中相当于1。
            <para>TCP模式中，该值等效于<see cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)"/></para>
            <para>UDP模式中，该值为重叠IO并发数</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.CacheTimeoutEnableProperty">
            <summary>
            适配器数据包缓存启用。默认为缺省（null），如果有正常值会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetCacheTimeoutEnable(TouchSocket.Core.TouchSocketConfig,System.Boolean)">
            <summary>
            适配器数据包缓存启用。默认为缺省（null），如果有正常值会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeoutEnable"/>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.CacheTimeoutProperty">
            <summary>
            适配器数据包缓存时长。默认为缺省（<see cref="F:System.TimeSpan.Zero"/>）。当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetCacheTimeout(TouchSocket.Core.TouchSocketConfig,System.TimeSpan)">
            <summary>
            适配器数据包缓存时长。默认为缺省（<see cref="F:System.TimeSpan.Zero"/>）。当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout"/>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.UpdateCacheTimeWhenRevProperty">
            <summary>
            适配器数据包缓存策略。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.UpdateCacheTimeWhenRev"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetUpdateCacheTimeWhenRev(TouchSocket.Core.TouchSocketConfig,System.Boolean)">
            <summary>
            适配器数据包缓存策略。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.UpdateCacheTimeWhenRev"/>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.MaxPackageSizeProperty">
            <summary>
            适配器数据包最大值。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.MaxPackageSize"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetMaxPackageSize(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            适配器数据包最大值。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.MaxPackageSize"/>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.BindIPHostProperty">
            <summary>
            TCP固定端口绑定，
            所需类型<see cref="T:TouchSocket.Sockets.IPHost"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.KeepAliveValueProperty">
            <summary>
            在Socket配置KeepAlive属性，这个是操作tcp底层的，如果你对底层不了解，建议不要动。
            所需类型<see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.NoDelayProperty">
            <summary>
            设置Socket不使用Delay算法，
            所需类型<see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.RemoteIPHostProperty">
            <summary>
            远程目标地址，所需类型<see cref="T:TouchSocket.Sockets.IPHost"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.SslOptionProperty">
            <summary>
            Ssl配置，为Null时则不启用
            所需类型<see cref="T:TouchSocket.Sockets.SslOption"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.DelaySenderProperty">
            <summary>
            是否使用延迟合并发送。默认null。不开启
            所需类型<see cref="T:TouchSocket.Sockets.DelaySenderOption"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.UseDelaySender(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.DelaySenderOption)">
            <summary>
            使用默认配置延迟合并发送。
            所需类型<see cref="T:TouchSocket.Sockets.DelaySenderOption"/>
            </summary>
            <param name="config"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetBindIPHost(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.IPHost)">
            <summary>
            固定端口绑定。
            <para>在<see cref="T:TouchSocket.Sockets.UdpSessionBase"/>中表示本地监听地址</para>
            <para>在<see cref="T:TouchSocket.Sockets.TcpClientBase"/>中表示固定客户端端口号。</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetBindIPHost(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            固定端口绑定。
            <para>在<see cref="T:TouchSocket.Sockets.UdpSessionBase"/>中表示本地监听地址</para>
            <para>在<see cref="T:TouchSocket.Sockets.TcpClientBase"/>中表示固定客户端端口号。</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetBindIPHost(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            固定端口绑定。
            <para>在<see cref="T:TouchSocket.Sockets.UdpSessionBase"/>中表示本地监听地址</para>
            <para>在<see cref="T:TouchSocket.Sockets.TcpClientBase"/>中表示固定客户端端口号。</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetClientSslOption(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.ClientSslOption)">
            <summary>
            设置客户端Ssl配置，为Null时则不启用。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetKeepAliveValue(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.KeepAliveValue)">
            <summary>
            在Socket的KeepAlive属性。
            <para>注意：这个是操作tcp底层的，如果你对底层不了解，建议不要动。</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetRemoteIPHost(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.IPHost)">
            <summary>
            设置远程目标地址。在<see cref="T:TouchSocket.Sockets.UdpSessionBase"/>中，表示默认发送时的目标地址。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetRemoteIPHost(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            设置远程目标地址。在<see cref="T:TouchSocket.Sockets.UdpSessionBase"/>中，表示默认发送时的目标地址。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.UseNoDelay(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            设置Socket的NoDelay属性，默认false。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.BacklogProperty">
            <summary>
            挂起连接队列的最大长度，所需类型<see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.GetDefaultNewIDProperty">
            <summary>
            设置默认ID的获取方式，所需类型<see cref="T:System.Func`2"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.ListenIPHostsProperty">
            <summary>
            服务器负责监听的地址组。所需类型<see cref="T:TouchSocket.Sockets.IPHost"/>数组
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.MaxCountProperty">
            <summary>
            最大可连接数，默认为10000，所需类型<see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.ReuseAddressProperty">
            <summary>
            端口复用，默认为false，所需类型<see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.UseReuseAddress(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            启用端口复用。
            <para>该配置可在服务器、或客户端在监听端口时，运行监听同一个端口。可以一定程度缓解端口来不及释放的问题</para>
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetBacklog(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            挂起连接队列的最大长度，默认100。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetClearInterval(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            设置清理无数据交互的SocketClient，默认60*1000 ms。如果不想清除，可使用-1
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetClearType(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.CheckClearType)">
            <summary>
            清理统计类型。
            <para><see cref="F:TouchSocket.Sockets.CheckClearType.OnlyReceive"/>为在收到数据时，刷新统计，如果一直有数据接收，则不会被主动清理断开</para>
            <para><see cref="F:TouchSocket.Sockets.CheckClearType.OnlySend"/>为在发送数据时，刷新统计，如果一直有数据发送，则不会被主动清理断开</para>
            <para>二者可叠加使用。</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetGetDefaultNewID(TouchSocket.Core.TouchSocketConfig,System.Func{System.String})">
            <summary>
            设置默认ID的获取方式。仅服务器生效。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetListenIPHosts(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.IPHost[])">
            <summary>
            服务器负责监听的地址组。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetMaxCount(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            最大可连接数，默认为10000。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.SetServiceSslOption(TouchSocket.Core.TouchSocketConfig,TouchSocket.Sockets.ServiceSslOption)">
            <summary>
            设置客户端Ssl配置，为Null时则不启用。
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Sockets.TouchSocketConfigExtension.EnableBroadcastProperty">
            <summary>
            该值指定 System.Net.Sockets.Socket可以发送或接收广播数据包。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.UseBroadcast(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            该值指定 System.Net.Sockets.Socket可以发送或接收广播数据包。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithTcpClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Tcp类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithTcpClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Tcp类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithTcpService``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Tcp类服务器，并启动。
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithTcpService(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建Tcp类服务器，并启动。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithUdpSession``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建UDP类，并启动。
            </summary>
            <typeparam name="TSession"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TouchSocketConfigExtension.BuildWithUdpSession(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建UDP类，并启动。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.CacheDataHandlingAdapter">
            <summary>
            CacheDataHandlingAdapter
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CacheDataHandlingAdapter.m_cacheByteBlock">
            <summary>
            缓存数据，如果需要手动释放，请先判断，然后到调用<see cref="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)"/>后，再置空；
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CacheDataHandlingAdapter.Cache(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将数据缓存起来
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.CacheDataHandlingAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CacheDataHandlingAdapter.TryGetCache(System.Byte[]@)">
            <summary>
            获取当前缓存，
            如果缓存超时，或者不存在，均会返回false。
            如果获取成功，则会清空内部缓存。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CacheDataHandlingAdapter.TryGetCache(TouchSocket.Core.ByteBlock@)">
            <summary>
            获取缓存，注意：获取的ByteBlock需要手动释放。
            </summary>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1">
            <summary>
            区间数据包处理适配器，支持以任意字符、字节数组起始与结尾的数据包。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1.StartCode">
            <summary>
            起始字符，不可以为null，可以为0长度
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1.MinSize">
            <summary>
            即使找到了终止因子，也不会结束，默认0
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1.EndCode">
            <summary>
            结束字符，不可以为null，不可以为0长度，必须具有有效值。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1.Filter(TouchSocket.Core.ByteBlock,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到指定位置，然后返回<see cref="F:TouchSocket.Sockets.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomBetweenAndDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IBetweenAndRequestInfo">
            <summary>
            区间类型的适配器数据模型接口。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IBetweenAndRequestInfo.OnParsingStartCode(System.Byte[])">
            <summary>
            当解析到起始字符时。
            </summary>
            <param name="startCode"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.IBetweenAndRequestInfo.OnParsingBody(System.Byte[])">
            <summary>
            当解析数据体。
            <para>在此方法中，您必须手动保存Body内容</para>
            </summary>
            <param name="body"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IBetweenAndRequestInfo.OnParsingEndCode(System.Byte[])">
            <summary>
            当解析到起始字符时。
            </summary>
            <param name="endCode"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.CustomBigFixedHeaderDataHandlingAdapter`1">
            <summary>
            大数据用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomBigFixedHeaderDataHandlingAdapter`1.HeaderLength">
            <summary>
            固定包头的长度。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CustomBigFixedHeaderDataHandlingAdapter`1.Filter(TouchSocket.Core.ByteBlock,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到指定位置，然后返回<see cref="F:TouchSocket.Sockets.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomBigFixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IBigFixedHeaderRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IBigFixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IBigFixedHeaderRequestInfo.OnParsingHeader(System.Byte[])">
            <summary>
            当收到数据，由框架封送固定协议头。
            <para>您需要在此函数中，解析自己的固定包头，并且对<see cref="P:TouchSocket.Sockets.IBigFixedHeaderRequestInfo.BodyLength"/>赋值后续数据的长度，然后返回True。</para>
            <para>如果返回false，则意味着放弃本次解析</para>
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.IBigFixedHeaderRequestInfo.OnAppendBody(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当收到数据，由框架封送数据。
            <para>您需要将有效数据自行保存。该方法可能会多次调用。</para>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns>是否成功有效</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IBigFixedHeaderRequestInfo.OnFinished">
            <summary>
            当完成数据接收时调用。
            <para>当返回False时，将不会把该对象向Received传递。</para>
            </summary>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Sockets.CustomDataHandlingAdapter`1">
            <summary>
            用户自定义数据处理适配器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，
            同时<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将实现为TRequest，发送数据直接发送。
            <para>此处设计思路借鉴SuperSocket。</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CustomDataHandlingAdapter`1.TempByteBlock">
            <summary>
            缓存数据，如果需要手动释放，请先判断，然后到调用<see cref="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)"/>后，再置空；
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CustomDataHandlingAdapter`1.TempRequest">
            <summary>
            缓存对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomDataHandlingAdapter`1.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomDataHandlingAdapter`1.CanSplicingSend">
            <summary>
            默认不支持拼接发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.Filter(TouchSocket.Core.ByteBlock,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到指定位置，然后返回<see cref="F:TouchSocket.Sockets.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.OnReceivedSuccess(`0)">
            <summary>
            成功执行接收以后。
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.OnReceivingSuccess(`0)">
            <summary>
            即将执行<see cref="M:TouchSocket.Sockets.DataHandlingAdapter.GoReceived(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)"/>。
            </summary>
            <param name="request"></param>
            <returns>返回值标识是否继续执行</returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.CustomDataHandlingAdapter`1.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.CustomFixedHeaderDataHandlingAdapter`1">
            <summary>
            用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CustomFixedHeaderDataHandlingAdapter`1.HeaderLength">
            <summary>
            固定包头的长度。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CustomFixedHeaderDataHandlingAdapter`1.Filter(TouchSocket.Core.ByteBlock,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到指定位置，然后返回<see cref="F:TouchSocket.Sockets.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomFixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IFixedHeaderRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IFixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IFixedHeaderRequestInfo.OnParsingHeader(System.Byte[])">
            <summary>
            当收到数据，由框架封送固定协议头。
            <para>您需要在此函数中，解析自己的固定包头，并且对<see cref="P:TouchSocket.Sockets.IFixedHeaderRequestInfo.BodyLength"/>赋值后续数据的长度，然后返回True。</para>
            <para>如果返回false，则意味着放弃本次解析</para>
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.IFixedHeaderRequestInfo.OnParsingBody(System.Byte[])">
            <summary>
            当收到数据，由框架封送有效载荷数据。
            <para>如果返回false，意味着放弃本次解析的所有数据，包括已经解析完成的Header</para>
            </summary>
            <param name="body">载荷数据</param>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Sockets.CustomUnfixedHeaderDataHandlingAdapter`1">
            <summary>
            用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将实现为TUnfixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CustomUnfixedHeaderDataHandlingAdapter`1.Filter(TouchSocket.Core.ByteBlock,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到指定位置，然后返回<see cref="F:TouchSocket.Sockets.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Sockets.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CustomUnfixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IUnfixedHeaderRequestInfo">
            <summary>
            用户自定义不固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IUnfixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IUnfixedHeaderRequestInfo.OnParsingHeader(TouchSocket.Core.ByteBlock)">
            <summary>
            当收到数据，由框架封送数据，您需要在此函数中，解析自己的数据包头。
            <para>如果满足包头的解析，请返回True，并且递增整个包头的长度到<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>，然后赋值<see cref="P:TouchSocket.Sockets.IUnfixedHeaderRequestInfo.BodyLength"/></para>
            <para>如果返回false，意味着缓存剩余数据，此时如果仅仅是因为长度不足，则不必修改其他。</para>
            <para>但是如果是因为数据错误，则需要修改<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>到正确位置，如果都不正确，则设置<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>等于<see cref="P:TouchSocket.Core.ByteBlock.Len"/></para>
            </summary>
            <param name="byteBlock"></param>
            <returns>是否满足解析包头</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IUnfixedHeaderRequestInfo.OnParsingBody(System.Byte[])">
            <summary>
            当收到数据，由框架封送有效载荷数据。
            <para>如果返回false，意味着放弃本次解析的所有数据，包括已经解析完成的Header</para>
            </summary>
            <param name="body">载荷数据</param>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Sockets.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.LastCacheTime">
            <summary>
            最后缓存的时间
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.UpdateCacheTimeWhenRev">
            <summary>
            是否在收到数据时，即刷新缓存时间。默认true。
            <list type="number">
            <item>当设为true时，将弱化<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout"/>的作用，只要一直有数据，则缓存不会过期。</item>
            <item>当设为false时，则在<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout"/>的时效内。必须完成单个缓存的数据。</item>
            </list>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeout">
            <summary>
            缓存超时时间。默认1秒。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.CacheTimeoutEnable">
            <summary>
            是否启用缓存超时。默认true。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.OnLoaded(TouchSocket.Sockets.ITcpClientBase)">
            <summary>
            当插件在被第一次加载时调用。
            </summary>
            <param name="client"></param>
            <exception cref="T:System.Exception">此适配器已被其他终端使用，请重新创建对象。</exception>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.CanSplicingSend">
            <summary>
            拼接发送
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.CanSendRequestInfo">
            <summary>
            是否允许发送<see cref="T:TouchSocket.Sockets.IRequestInfo"/>对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.MaxPackageSize">
            <summary>
            获取或设置适配器能接收的最大数据包长度。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.Client">
            <summary>
            适配器拥有者。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.ReceivedCallBack">
            <summary>
            当接收数据处理完成后，回调该函数执行接收
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.DataHandlingAdapter.SendCallBack">
            <summary>
            当接收数据处理完成后，回调该函数执行发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.ReceivedInput(TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.SendInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.SendInput(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.SendInput(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.GoReceived(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理已经经过预先处理后的数据
            </summary>
            <param name="byteBlock">以二进制形式传递</param>
            <param name="requestInfo">以解析实例传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.GoSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送已经经过预先处理后的数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.OnError(System.String,System.Boolean,System.Boolean)">
            <summary>
            在解析时发生错误。
            </summary>
            <param name="error">错误异常</param>
            <param name="reset">是否调用<see cref="M:TouchSocket.Sockets.DataHandlingAdapter.Reset"/></param>
            <param name="log">是否记录日志</param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据后预先处理数据,然后调用<see cref="M:TouchSocket.Sockets.DataHandlingAdapter.GoReceived(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)"/>处理数据
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当发送数据前预先处理数据
            </summary>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            当发送数据前预先处理数据
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            组合发送预处理数据，
            当属性SplicingSend实现为True时，系统才会调用该方法。
            </summary>
            <param name="transferBytes">代发送数据组合</param>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.Reset">
            <summary>
            重置解析器到初始状态，一般在<see cref="M:TouchSocket.Sockets.DataHandlingAdapter.OnError(System.String,System.Boolean,System.Boolean)"/>被触发时，由返回值指示是否调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DataHandlingAdapter.Dispose(System.Boolean)">
            <summary>
            该方法被触发时，一般说明<see cref="P:TouchSocket.Sockets.DataHandlingAdapter.Client"/>已经断开连接。
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Sockets.NormalDataHandlingAdapter">
            <summary>
            普通TCP数据处理器，该适配器不对数据做任何处理。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.NormalDataHandlingAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.NormalDataHandlingAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NormalDataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalDataHandlingAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalDataHandlingAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalDataHandlingAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalDataHandlingAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.FixedHeaderPackageAdapter">
            <summary>
            固定包头数据包处理适配器，支持Byte、UShort、Int三种类型作为包头。使用<see cref="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType"/>大小端设置。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedHeaderPackageAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedHeaderPackageAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedHeaderPackageAdapter.FixedHeaderType">
            <summary>
            设置包头类型，默认为int
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedHeaderPackageAdapter.MinPackageSize">
            <summary>
            获取或设置包数据的最小值（默认为0）
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            当发送数据前处理数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.SeamPackage(System.Byte[],System.Int32)">
            <summary>
            缝合包
            </summary>
            <param name="buffer"></param>
            <param name="r"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedHeaderPackageAdapter.SplitPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            分解包
            </summary>
            <param name="dataBuffer"></param>
            <param name="index"></param>
            <param name="r"></param>
        </member>
        <member name="T:TouchSocket.Sockets.FixedSizePackageAdapter">
            <summary>
            固定长度数据包处理适配器。
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FixedSizePackageAdapter.m_surPlusLength">
            <summary>
            包剩余长度
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FixedSizePackageAdapter.m_tempByteBlock">
            <summary>
            临时包
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="fixedSize">数据包的长度</param>
        </member>
        <member name="P:TouchSocket.Sockets.FixedSizePackageAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedSizePackageAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.FixedSizePackageAdapter.FixedSize">
            <summary>
            获取已设置的数据包的长度
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            预处理
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            预处理
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.FixedSizePackageAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.TerminatorPackageAdapter">
            <summary>
            终止字符数据包处理适配器，支持以任意字符、字节数组结尾的数据包。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="terminator"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.#ctor(System.String,System.Text.Encoding)">
            <summary>
            构造函数
            </summary>
            <param name="terminator"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.#ctor(System.Int32,System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="minSize"></param>
            <param name="terminatorCode"></param>
        </member>
        <member name="P:TouchSocket.Sockets.TerminatorPackageAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TerminatorPackageAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TerminatorPackageAdapter.MinSize">
            <summary>
            即使找到了终止因子，也不会结束，默认0
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TerminatorPackageAdapter.ReserveTerminatorCode">
            <summary>
            保留终止因子
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            预处理
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.PreviewSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            预处理
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.PreviewSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TerminatorPackageAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.Pipeline">
            <summary>
            Pipeline读取管道
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.Pipeline.#ctor(TouchSocket.Sockets.ITcpClientBase)">
            <summary>
            Pipeline读取管道
            </summary>
            <param name="client"></param>
        </member>
        <member name="P:TouchSocket.Sockets.Pipeline.Client">
            <summary>
            当前支持此管道的客户端。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.PipelineDataHandlingAdapter">
            <summary>
            管道数据处理适配器。
            使用该适配器后，<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将为<see cref="T:TouchSocket.Sockets.Pipeline"/>.
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.PipelineDataHandlingAdapter.#ctor">
            <summary>
            管道数据处理适配器。
            使用该适配器后，<see cref="T:TouchSocket.Sockets.IRequestInfo"/>将为<see cref="T:TouchSocket.Sockets.Pipeline"/>.
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.PipelineDataHandlingAdapter.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Sockets.PipelineDataHandlingAdapter.PreviewReceived(TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.InternalPipeline.#ctor(TouchSocket.Sockets.ITcpClientBase)">
            <summary>
            Pipeline读取管道
            </summary>
            <param name="client"></param>
        </member>
        <member name="T:TouchSocket.Sockets.DataAdapterTester">
            <summary>
            数据处理适配器测试
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DataAdapterTester.CreateTester(TouchSocket.Sockets.DataHandlingAdapter,System.Int32,System.Action{TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo})">
            <summary>
            获取测试器
            </summary>
            <param name="adapter">待测试适配器</param>
            <param name="receivedCallBack">收到数据回调</param>
            <param name="bufferLength">缓存数据长度</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.DataAdapterTester.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟测试运行发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="timeout">超时</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.DataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟发送
            </summary>
            <param name="buffer"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="timeout">超时</param>
        </member>
        <member name="T:TouchSocket.Sockets.UdpDataAdapterTester">
            <summary>
            Udp数据处理适配器测试
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataAdapterTester.CreateTester(TouchSocket.Sockets.UdpDataHandlingAdapter,System.Int32,System.Action{TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo})">
            <summary>
            获取测试器
            </summary>
            <param name="adapter">待测试适配器</param>
            <param name="multiThread">并发多线程数量</param>
            <param name="receivedCallBack">收到数据回调</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataAdapterTester.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟测试运行发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="timeout">超时</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟发送
            </summary>
            <param name="buffer"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="timeout">超时</param>
        </member>
        <member name="T:TouchSocket.Sockets.NormalUdpDataHandlingAdapter">
            <summary>
            常规UDP数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.PreviewReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.PreviewSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.PreviewSend(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NormalUdpDataHandlingAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.UdpDataHandlingAdapter">
            <summary>
            Udp数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.CanSendRequestInfo">
            <summary>
            是否允许发送<see cref="T:TouchSocket.Sockets.IRequestInfo"/>对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.CanSplicingSend">
            <summary>
            拼接发送
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.MaxPackageSize">
            <summary>
            获取或设置适配器能接收的最大数据包长度。默认1024*1024 Byte。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.Owner">
            <summary>
            适配器拥有者。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.ReceivedCallBack">
            <summary>
            当接收数据处理完成后，回调该函数执行接收
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpDataHandlingAdapter.SendCallBack">
            <summary>
            当接收数据处理完成后，回调该函数执行发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.ReceivedInput(System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.SendInput(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.SendInput(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.SendInput(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.GoReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理已经经过预先处理后的数据
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock">以二进制形式传递</param>
            <param name="requestInfo">以解析实例传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.GoSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送已经经过预先处理后的数据
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.OnError(System.String,System.Boolean,System.Boolean)">
            <summary>
            在解析时发生错误。
            </summary>
            <param name="error">错误异常</param>
            <param name="reset">是否调用<see cref="M:TouchSocket.Sockets.UdpDataHandlingAdapter.Reset"/></param>
            <param name="log">是否记录日志</param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.PreviewReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据后预先处理数据,然后调用<see cref="M:TouchSocket.Sockets.UdpDataHandlingAdapter.GoReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)"/>处理数据
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            当发送数据前预先处理数据
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.PreviewSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            当发送数据前预先处理数据
            </summary>
            <param name="endPoint"></param>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.PreviewSend(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            组合发送预处理数据，
            当属性SplicingSend实现为True时，系统才会调用该方法。
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes">代发送数据组合</param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpDataHandlingAdapter.Reset">
            <summary>
            重置解析器到初始状态，一般在<see cref="M:TouchSocket.Sockets.UdpDataHandlingAdapter.OnError(System.String,System.Boolean,System.Boolean)"/>被触发时，由返回值指示是否调用。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.UdpKcpPackageAdapter">
            <summary>
            UdpKcpPackageAdapter
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpKcpPackageAdapter.PreviewReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Sockets.UdpFrame">
            <summary>
            UDP数据帧
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpFrame.Crc">
            <summary>
            Crc校验
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpFrame.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpFrame.FIN">
            <summary>
            是否为终结帧
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpFrame.ID">
            <summary>
            数据ID
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpFrame.SN">
            <summary>
            帧序号
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpFrame.Parse(System.Byte[],System.Int32,System.Int32)">
            <summary>
            解析
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.UdpPackage">
            <summary>
            UDP数据包
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackage.#ctor(System.Int64,System.Int32,System.Collections.Concurrent.ConcurrentDictionary{System.Int64,TouchSocket.Sockets.UdpPackage})">
            <summary>
            构造函数
            </summary>
            <param name="id"></param>
            <param name="timeout"></param>
            <param name="revStore"></param>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.Count">
            <summary>
            当前长度
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.Crc">
            <summary>
            Crc
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.ID">
            <summary>
            包唯一标识
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.IsComplated">
            <summary>
            是否已完成
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.Length">
            <summary>
            当前数据长度
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.MTU">
            <summary>
            MTU
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackage.TotalCount">
            <summary>
            总长度，在收到最后一帧之前，为-1。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackage.Add(TouchSocket.Sockets.UdpFrame)">
            <summary>
            添加帧
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackage.TryGetData(TouchSocket.Core.ByteBlock)">
            <summary>
            获得数据
            </summary>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.UdpPackageAdapter">
            <summary>
            UDP数据包的适配器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackageAdapter.CanSendRequestInfo">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackageAdapter.CanSplicingSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackageAdapter.MTU">
            <summary>
            最大传输单元
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpPackageAdapter.Timeout">
            <summary>
            接收超时时间，默认5000ms
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.PreviewReceived(System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="remoteEndPoint"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.PreviewSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.PreviewSend(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="endPoint"></param>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.PreviewSend(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpPackageAdapter.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.CheckClearType">
            <summary>
            检查清理类型
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CheckClearType.OnlySend">
            <summary>
            仅统计发送
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CheckClearType.OnlyReceive">
            <summary>
            仅统计接收
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.CheckClearType.All">
            <summary>
            全部
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.FilterResult">
            <summary>
            过滤结果
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FilterResult.Cache">
            <summary>
            缓存后续所有<see cref="P:TouchSocket.Core.ByteBlock.CanReadLen"/>数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FilterResult.Success">
            <summary>
            操作成功
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FilterResult.GoOn">
            <summary>
            继续操作，一般原因是本次数据有部分无效，但已经调整了<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>属性，所以继续后续解析。
            <para>或者想放弃当前数据的操作，直接设置<see cref="P:TouchSocket.Core.ByteBlock.Pos"/>与<see cref="P:TouchSocket.Core.ByteBlock.Len"/>相等即可。</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.FixedHeaderType">
            <summary>
            固定包头类型
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FixedHeaderType.Byte">
            <summary>
            以1Byte标识长度，最长接收255
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FixedHeaderType.Ushort">
            <summary>
            以2Byte标识长度，最长接收65535
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.FixedHeaderType.Int">
            <summary>
            以4Byte标识长度，最长接收2147483647
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ReceiveType">
            <summary>
            接收类型
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ReceiveType.Auto">
            <summary>
            该模式下会自动接收数据，然后主动触发。
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ReceiveType.None">
            <summary>
            在该模式下，不会投递接收申请，用户可通过<see cref="M:TouchSocket.Sockets.ITcpClientBase.GetStream"/>，获取到流以后，自己处理接收。
            <para>注意：连接端不会感知主动断开</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ServerState">
            <summary>
            服务器状态
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ServerState.None">
            <summary>
            无状态，指示为初建
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ServerState.Running">
            <summary>
            正在运行
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ServerState.Stopped">
            <summary>
            已停止
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.ServerState.Disposed">
            <summary>
            已释放
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ByteBlockEventArgs">
            <summary>
            字节事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ByteBlockEventArgs.#ctor(TouchSocket.Core.ByteBlock)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ByteBlockEventArgs.ByteBlock">
            <summary>
            数据块
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.BytesEventArgs">
            <summary>
            字节事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.BytesEventArgs.#ctor(System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:TouchSocket.Sockets.BytesEventArgs.ReceivedDataBytes">
            <summary>
            字节数组
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ConfigEventArgs">
            <summary>
            ConfigEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ConfigEventArgs.#ctor(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            实例化2ConfigEventArgs
            </summary>
            <param name="config"></param>
        </member>
        <member name="P:TouchSocket.Sockets.ConfigEventArgs.Config">
            <summary>
            具体配置
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientConnectingEventArgs">
            <summary>
            ClientConnectingEventArgs
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ConnectingEventArgs">
            <summary>
            客户端连接事件。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ConnectingEventArgs.#ctor(System.Net.Sockets.Socket)">
            <summary>
            构造函数
            </summary>
            <param name="socket"></param>
        </member>
        <member name="P:TouchSocket.Sockets.ConnectingEventArgs.Socket">
            <summary>
            新初始化的通信器
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.DisconnectEventArgs">
            <summary>
            断开连接事件参数
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.DisconnectEventArgs.#ctor(System.Boolean,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="manual"></param>
            <param name="mes"></param>
        </member>
        <member name="P:TouchSocket.Sockets.DisconnectEventArgs.Manual">
            <summary>
            是否为主动行为。
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientDisconnectedEventArgs">
            <summary>
            ClientDisconnectedEventArgs
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.IDChangedEventArgs">
            <summary>
            IDChangedEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IDChangedEventArgs.#ctor(System.String,System.String)">
            <summary>
            IDChangedEventArgs
            </summary>
            <param name="oldID"></param>
            <param name="newID"></param>
        </member>
        <member name="P:TouchSocket.Sockets.IDChangedEventArgs.OldID">
            <summary>
            旧ID
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IDChangedEventArgs.NewID">
            <summary>
            新ID
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.MsgEventArgs">
            <summary>
            消息事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.MsgEventArgs.#ctor(System.String)">
            <summary>
             构造函数
            </summary>
            <param name="mes"></param>
        </member>
        <member name="M:TouchSocket.Sockets.MsgEventArgs.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.MsgEventArgs.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientOperationEventArgs">
            <summary>
            ClientOperationEventArgs
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.OperationEventArgs">
            <summary>
            Client消息操作事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.OperationEventArgs.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.OperationEventArgs.ID">
            <summary>
            客户端ID
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ReceivedDataEventArgs">
            <summary>
            插件处理事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ReceivedDataEventArgs.#ctor(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            构造函数
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="P:TouchSocket.Sockets.ReceivedDataEventArgs.RequestInfo">
            <summary>
            对象载体
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.SendingEventArgs">
            <summary>
            发送事件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SendingEventArgs.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="P:TouchSocket.Sockets.SendingEventArgs.Buffer">
            <summary>
            数据缓存区，该属性获取来自于内存池，所以最好不要引用该对象，可以同步使用该对象
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SendingEventArgs.Offset">
            <summary>
            缓存偏移
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.SendingEventArgs.Length">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.UdpReceivedDataEventArgs">
            <summary>
            Udp接收消息
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpReceivedDataEventArgs.#ctor(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            构造函数
            </summary>
            <param name="endPoint"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="P:TouchSocket.Sockets.UdpReceivedDataEventArgs.EndPoint">
            <summary>
            接收终结点
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ClientNotFindException">
            <summary>
            没有找到ID对应的客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientNotFindException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientNotFindException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientNotFindException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientNotFindException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Sockets.NotConnectedException">
            <summary>
            未连接异常
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NotConnectedException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.NotConnectedException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NotConnectedException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Sockets.NotConnectedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Sockets.OverlengthException">
            <summary>
            超长异常
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.OverlengthException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.OverlengthException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Sockets.OverlengthException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Sockets.OverlengthException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Sockets.ClientExtension">
            <summary>
            客户端扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.GetInfo``1(``0)">
             <summary>
             获取相关信息。格式：
            <para>IPPort=IP:Port,ID=id,Protocol=Protocol</para>
             </summary>
             <typeparam name="T"></typeparam>
             <param name="client"></param>
             <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.GetOtherIDs``1(``0)">
            <summary>
            获取服务器中，除自身以外的所有客户端id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.GetLastActiveTime``1(``0)">
            <summary>
            获取最后活动时间。即<see cref="P:TouchSocket.Sockets.IClient.LastReceivedTime"/>与<see cref="P:TouchSocket.Sockets.IClient.LastSendTime"/>的最近值。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.TryShutdown``1(``0,System.Net.Sockets.SocketShutdown)">
            <summary>
            安全性发送关闭报文
            </summary>
            <typeparam name="T"></typeparam>
            <param name="client"></param>
            <param name="how"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.SafeClose``1(``0,System.String)">
            <summary>
            安全性关闭。不会抛出异常。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="client"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.GetIPPort``1(``0)">
            <summary>
            获取IP和端口。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.TryConnect``1(``0,System.Int32)">
            <summary>
            尝试连接。不会抛出异常。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ClientExtension.TryConnectAsync``1(``0,System.Int32)">
            <summary>
            尝试连接。不会抛出异常。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.SenderExtension">
            <summary>
            SenderExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.Byte[])">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,TouchSocket.Core.ByteBlock)">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.String)">
            <summary>
            以UTF-8的编码同步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.Byte[])">
            <summary>
            异步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.String)">
            <summary>
            以UTF-8的编码异步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSend``1(``0,System.String)">
            <summary>
            以UTF-8的编码同步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSend``1(``0,System.Byte[])">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSend``1(``0,TouchSocket.Core.ByteBlock)">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSendAsync``1(``0,System.String)">
            <summary>
            以UTF-8的编码异步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSendAsync``1(``0,System.Byte[])">
            <summary>
            异步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.String,System.String)">
            <summary>
            以UTF-8的编码同步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="id"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.String,System.Byte[])">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="id"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.String,TouchSocket.Core.ByteBlock)">
            <summary>
            同步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="id"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.String,System.String)">
            <summary>
            以UTF-8的编码异步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="id"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.String,System.Byte[])">
            <summary>
            异步发送数据。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="id"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSend``1(``0,System.Net.EndPoint,System.String)">
            <summary>
            以UTF-8的编码同步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="endPoint"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSend``1(``0,System.Net.EndPoint,System.Byte[])">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据区</param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSendAsync``1(``0,System.Net.EndPoint,System.String)">
            <summary>
            以UTF-8的编码异步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="endPoint"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSendAsync``1(``0,System.Net.EndPoint,System.Byte[])">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据缓存区</param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.DefaultSendAsync``1(``0,System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="byteBlock"></param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.Net.EndPoint,System.String)">
            <summary>
            以UTF-8的编码同步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="endPoint"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.Net.EndPoint,System.Byte[])">
            <summary>
            发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据区</param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.Send``1(``0,System.Net.EndPoint,TouchSocket.Core.ByteBlock)">
            <summary>
            发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="byteBlock">数据区</param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.Net.EndPoint,System.String)">
            <summary>
            以UTF-8的编码异步发送字符串。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="endPoint"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Sockets.SenderExtension.SendAsync``1(``0,System.Net.EndPoint,System.Byte[])">
            <summary>
            发送字节流
            </summary>
            <param name="client"></param>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据缓存区</param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.SocketExtension">
            <summary>
            SocketExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.SocketExtension.AbsoluteSend(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            会使用同步锁，保证所有数据上缓存区。
            </summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Sockets.IClient">
            <summary>
            终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.OnHandleRawBuffer">
            <summary>
            处理未经过适配器的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.OnHandleReceivedData">
            <summary>
            处理经过适配器后的数据。返回值表示是否继续向下传递。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.Logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.Protocol">
            <summary>
            终端协议
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.Container">
            <summary>
            简单IOC容器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.LastReceivedTime">
            <summary>
            最后一次接收到数据的时间
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IClient.LastSendTime">
            <summary>
            最后一次发送数据的时间
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.INATSocketClient">
            <summary>
            INATSocketClient
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.INATSocketClient.AddTargetClient(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            添加转发客户端。
            </summary>
            <param name="config">配置文件</param>
            <param name="setupAction">当完成配置，但是还未连接时回调。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.INATSocketClient.AddTargetClientAsync(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Sockets.ITcpClient})">
            <summary>
            添加转发客户端。
            </summary>
            <param name="config">配置文件</param>
            <param name="setupAction">当完成配置，但是还未连接时回调。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.INATSocketClient.GetTargetClients">
            <summary>
            获取所有目标客户端
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.INATSocketClient.SendToTargetClient(System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送数据到全部转发端。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Sockets.IRequestInfo">
             <summary>
             请求解析对象接口。
            <para>此处接口设计借鉴SuperSocket，只为大家更好理解</para>
             </summary>
        </member>
        <member name="T:TouchSocket.Sockets.IClientSender">
            <summary>
            客户端发送接口
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IClientSender.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            同步组合发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="transferBytes">组合数据</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IClientSender.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            异步组合发送数据。
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="transferBytes">组合数据</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IDefaultSender">
            <summary>
            具有直接发送功能
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IDefaultSender.DefaultSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IDefaultSender.DefaultSendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IIDRequsetInfoSender">
            <summary>
            IIDRequsetInfoSender
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IIDRequsetInfoSender.Send(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            同步发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="id"></param>
            <param name="requestInfo">解析对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IIDRequsetInfoSender.SendAsync(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            异步发送数据。
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClient"/>时，如果使用独立线程发送，则不会触发异常。</para>
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClientBase"/>时，相当于<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)"/>。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="id"></param>
            <param name="requestInfo">解析对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IIDSender">
            <summary>
            通过ID发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IIDSender.Send(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="id">目标ID</param>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IIDSender.SendAsync(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="id">目标ID</param>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IIDSender.Send(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="id">目标ID</param>
            <param name="requestInfo">数据对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IIDSender.SendAsync(System.String,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="id">目标ID</param>
            <param name="requestInfo">数据对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IRequsetInfoSender">
            <summary>
            IRequsetInfoSend
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IRequsetInfoSender.Send(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            同步发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="requestInfo">解析对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IRequsetInfoSender.SendAsync(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            异步发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="requestInfo">解析对象</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.ISender">
            <summary>
            具有发送功能的接口
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ISender.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            同步发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.ISender.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            异步发送数据。
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClient"/>时，如果使用独立线程发送，则不会触发异常。</para>
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClientBase"/>时，相当于<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)"/>。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.ISenderBase">
            <summary>
            具有发送动作的基类。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISenderBase.CanSend">
            <summary>
            表示对象能否顺利执行发送操作。
            <para>由于高并发，当该值为True时，也不一定完全能执行。</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.IUdpClientSender">
            <summary>
            具有Udp终结点的发送
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpClientSender.Send(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            同步组合发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="endPoint">远程终结点</param>
            <param name="transferBytes">组合数据</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpClientSender.SendAsync(System.Net.EndPoint,System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            异步组合发送数据。
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClient"/>时，如果使用独立线程发送，则不会触发异常。</para>
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClientBase"/>时，相当于<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)"/>。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="endPoint">远程终结点</param>
            <param name="transferBytes">组合数据</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpClientSender.Send(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            同步组合发送数据。
            <para>内部已经封装Ssl和发送长度检测，即：调用完成即表示数据全部发送完毕。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="endPoint">远程终结点</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpClientSender.SendAsync(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            异步组合发送数据。
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClient"/>时，如果使用独立线程发送，则不会触发异常。</para>
            <para>在<see cref="T:TouchSocket.Sockets.ITcpClientBase"/>时，相当于<see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)"/>。</para>
            <para>该发送会经过适配器封装，具体封装内容由适配器决定。</para>
            </summary>
            <param name="endPoint">远程终结点</param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IUdpDefaultSender">
            <summary>
            具有直接发送功能
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpDefaultSender.DefaultSend(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpDefaultSender.DefaultSendAsync(System.Net.EndPoint,System.Byte[],System.Int32,System.Int32)">
            <summary>
            绕过适配器，直接发送字节流
            </summary>
            <param name="endPoint">目的终结点</param>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移量</param>
            <param name="length">数据长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Sockets.IWaitSender">
            <summary>
            发送等待接口
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturn(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturn(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturn(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送流中的有效数据
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturnAsync(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturnAsync(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitSender.SendThenReturnAsync(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="T:TouchSocket.Sockets.IService">
            <summary>
            服务器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IService.ServerState">
            <summary>
            服务器状态
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IService.Config">
            <summary>
            获取服务器配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IService.ServerName">
            <summary>
            名称
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IService.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            配置服务器
            </summary>
            <param name="serverConfig">配置</param>
            <exception cref="T:System.Exception"></exception>
            <returns>设置的服务实例</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IService.Setup(System.Int32)">
            <summary>
            配置服务器
            </summary>
            <param name="port"></param>
            <exception cref="T:System.Exception"></exception>
            <returns>设置的服务实例</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IService.Start">
            <summary>
            启动
            </summary>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns>设置的服务实例</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IService.Stop">
            <summary>
            停止
            </summary>
            <exception cref="T:System.Exception"></exception>
            <returns>设置的服务实例</returns>
        </member>
        <member name="T:TouchSocket.Sockets.ISocket">
            <summary>
            Socket基接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISocket.BufferLength">
            <summary>
            数据交互缓存池限制
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISocket.Logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ISocketClient">
            <summary>
            服务器辅助类接口
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ISocketClient.ResetID(System.String)">
            <summary>
            重新设置ID
            </summary>
            <param name="newID"></param>
        </member>
        <member name="P:TouchSocket.Sockets.ISocketClient.ID">
            <summary>
            用于索引的ID
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISocketClient.Service">
            <summary>
            包含此辅助类的主服务器类
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISocketClient.ServiceIP">
            <summary>
            接收此客户端的服务器IP地址
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ISocketClient.ServicePort">
            <summary>
            接收此客户端的服务器端口
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.ITcpClient">
            <summary>
            TCP客户端终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClient.Connected">
            <summary>
            成功连接到服务器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClient.Connecting">
            <summary>
            准备连接的时候
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClient.RemoteIPHost">
            <summary>
            远程IPHost。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClient.Connect(System.Int32)">
            <summary>
            连接服务器
            </summary>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClient.ConnectAsync(System.Int32)">
            <summary>
            异步连接服务器
            </summary>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClient.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            配置服务器
            </summary>
            <param name="config"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClient.Setup(System.String)">
            <summary>
            配置服务器
            </summary>
            <param name="ipHost"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.ITcpClientBase">
            <summary>
            TCP终端基础接口。
            <para>
            注意：该接口并不仅表示客户端。<see cref="T:TouchSocket.Sockets.SocketClient"/>也实现了该接口。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.BufferLength">
            <summary>
            缓存池大小
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.CanSetDataHandlingAdapter">
            <summary>
            是否允许自由调用<see cref="M:TouchSocket.Sockets.ITcpClientBase.SetDataHandlingAdapter(TouchSocket.Sockets.DataHandlingAdapter)"/>进行赋值。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.Config">
            <summary>
            客户端配置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.Disconnected">
            <summary>
            断开连接
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.Disconnecting">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.IP">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.IsClient">
            <summary>
            表示是否为客户端。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.MainSocket">
            <summary>
            主通信器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.Online">
            <summary>
            判断是否在线
            <para>该属性仅表示TCP状态是否在线</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.Port">
            <summary>
            端口号
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.ReceiveType">
            <summary>
            接收模式
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpClientBase.UseSsl">
            <summary>
            使用Ssl加密
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClientBase.Close">
            <summary>
            中断终端
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClientBase.Close(System.String)">
            <summary>
            中断终端，传递中断消息
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClientBase.GetStream">
            <summary>
            获取流，在正常模式下为<see cref="T:System.Net.Sockets.NetworkStream"/>，在Ssl模式下为<see cref="T:System.Net.Security.SslStream"/>。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpClientBase.SetDataHandlingAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            设置数据处理适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="T:TouchSocket.Sockets.ITcpService`1">
            <summary>
            TCP系列服务器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService`1.Connected">
            <summary>
            用户连接完成
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService`1.Connecting">
            <summary>
            有用户连接的时候
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService`1.Disconnected">
            <summary>
            有用户断开连接
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpService`1.TryGetSocketClient(System.String,`0@)">
            <summary>
            尝试获取TClient
            </summary>
            <param name="id">ID</param>
            <param name="socketClient">TClient</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.ITcpService">
            <summary>
            TCP服务器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.Count">
            <summary>
            当前在线客户端数量
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.GetDefaultNewID">
            <summary>
            获取默认新ID。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.MaxCount">
            <summary>
            获取最大可连接数
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.Monitors">
            <summary>
            网络监听集合
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.SocketClients">
            <summary>
            获取当前连接的所有客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ITcpService.UseSsl">
            <summary>
            使用Ssl加密
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpService.Clear">
            <summary>
            清理当前已连接的所有客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpService.GetIDs">
            <summary>
            获取当前在线的所有ID集合
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpService.ResetID(System.String,System.String)">
            <summary>
            重置ID
            </summary>
            <param name="oldID"></param>
            <param name="newID"></param>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpService.SocketClientExist(System.String)">
            <summary>
            根据ID判断SocketClient是否存在
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IUdpSession">
            <summary>
            UDP会话
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IUdpSession.PluginsManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IUdpSession.BufferLength">
            <summary>
            缓存池大小
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IUdpSession.CanSetDataHandlingAdapter">
            <summary>
            是否允许自由调用<see cref="M:TouchSocket.Sockets.IUdpSession.SetDataHandlingAdapter(TouchSocket.Sockets.UdpDataHandlingAdapter)"/>进行赋值。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IUdpSession.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpSession.SetDataHandlingAdapter(TouchSocket.Sockets.UdpDataHandlingAdapter)">
            <summary>
            设置数据处理适配器
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="T:TouchSocket.Sockets.IConfigPlugin">
            <summary>
            当配置Config时触发。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IConfigPlugin.OnLoadingConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当载入配置时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IConfigPlugin.OnLoadingConfigAsync(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当载入配置时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IConfigPlugin.OnLoadedConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当完成配置载入时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.IConfigPlugin.OnLoadedConfigAsync(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当完成配置载入时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.ITcpPlugin">
            <summary>
            Tcp系插件接口
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnConnected(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            客户端连接成功后触发
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnConnectedAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            客户端连接成功后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnConnecting(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.OperationEventArgs)">
             <summary>
            在即将完成连接时触发。
             </summary>
             <param name="client">客户端</param>
             <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnConnectingAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            在即将完成连接时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnDisconnected(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            会话断开后触发
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnDisconnectedAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            会话断开后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnDisconnecting(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnDisconnectingAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            即将断开连接(仅主动断开时有效)。
            <para>
            当主动调用Close断开时，可通过<see cref="P:TouchSocket.Core.TouchSocketEventArgs.IsPermitOperation"/>终止断开行为。
            </para>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnIDChanged(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.IDChangedEventArgs)">
            <summary>
            当Client的ID被更改后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnIDChangedAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.IDChangedEventArgs)">
            <summary>
            当Client的ID被更改后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnReceivedData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnReceivedDataAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnReceivingData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ByteBlockEventArgs)">
            <summary>
            在刚收到数据时触发，即在适配器之前。
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnReceivingDataAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ByteBlockEventArgs)">
            <summary>
            在刚收到数据时触发，即在适配器之前。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnSendingData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.SendingEventArgs)">
            <summary>
            当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.ITcpPlugin.OnSendingDataAsync(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.SendingEventArgs)">
            <summary>
            当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IUdpSessionPlugin">
            <summary>
            Udp会话插件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpSessionPlugin.OnReceivedData(TouchSocket.Sockets.IUdpSession,TouchSocket.Sockets.UdpReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.IUdpSessionPlugin.OnReceivedDataAsync(TouchSocket.Sockets.IUdpSession,TouchSocket.Sockets.UdpReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.CheckClearPlugin">
            <summary>
            检查清理连接插件。服务器适用。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CheckClearPlugin.CheckClearType">
            <summary>
            清理统计类型。默认为：<see cref="F:TouchSocket.Sockets.CheckClearType.All"/>。当设置为<see cref="F:TouchSocket.Sockets.CheckClearType.OnlySend"/>时，
            则只检验发送方向是否有数据流动。没有的话则会断开连接。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.CheckClearPlugin.Duration">
            <summary>
            获取或设置清理无数据交互的Client，默认60秒。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.CheckClearPlugin.SetCheckClearType(TouchSocket.Sockets.CheckClearType)">
            <summary>
            清理统计类型。默认为：<see cref="F:TouchSocket.Sockets.CheckClearType.All"/>。当设置为<see cref="F:TouchSocket.Sockets.CheckClearType.OnlySend"/>时，
            则只检验发送方向是否有数据流动。没有的话则会断开连接。
            </summary>
            <param name="clearType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CheckClearPlugin.SetDuration(System.TimeSpan)">
            <summary>
            设置清理无数据交互的Client，默认60秒。
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.CheckClearPlugin.OnLoadedConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Sockets.ReconnectionPlugin`1">
            <summary>
            重连插件
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ReconnectionPlugin`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            初始化一个重连插件
            </summary>
            <param name="tryCon">无论如何，只要返回True，则结束本轮尝试</param>
        </member>
        <member name="M:TouchSocket.Sockets.ReconnectionPlugin`1.OnDisconnected(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpCommandLinePlugin">
            <summary>
            TCP命令行插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpCommandLinePlugin.#ctor(TouchSocket.Core.ILog)">
            <summary>
            TCP命令行插件。
            </summary>
            <param name="logger"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:TouchSocket.Sockets.TcpCommandLinePlugin.Converter">
            <summary>
            字符串转换器，默认支持基础类型和Json。可以自定义。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpCommandLinePlugin.ReturnException">
            <summary>
            是否返回执行异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpCommandLinePlugin.NoReturnException">
            <summary>
            当有执行异常时，不返回异常。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpCommandLinePlugin.OnReceivedData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Sockets.TcpPluginBase">
            <summary>
            插件实现基类
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.TcpPluginBase`1">
            <summary>
            插件实现基类
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.TcpPluginBase`1.Order">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnDisconnecting(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <inheritdoc cref="P:TouchSocket.Sockets.ITcpClientBase.Disconnecting"/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnDisconnectingAsync(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <inheritdoc cref="P:TouchSocket.Sockets.ITcpClientBase.Disconnecting"/>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnConnected(`0,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            成功建立连接
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnConnectedAsync(`0,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            客户端连接成功后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnConnecting(`0,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            在请求连接时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnConnectingAsync(`0,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            在即将完成连接时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnDisconnected(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            在断开连接时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnDisconnectedAsync(`0,TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            会话断开后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnIDChanged(`0,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            当Client的ID被更改后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnIDChangedAsync(`0,TouchSocket.Core.TouchSocketEventArgs)">
            <summary>
            当Client的ID被更改后触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnLoadedConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当载入配置时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnLoadedConfigAsync(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当完成配置载入时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnLoadingConfig(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当完成配置载入时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnLoadingConfigAsync(System.Object,TouchSocket.Sockets.ConfigEventArgs)">
            <summary>
            当载入配置时
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnReceivedData(`0,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数，当设置e.Handled=true时，终止向下传递</param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnReceivedDataAsync(`0,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnReceivingData(`0,TouchSocket.Sockets.ByteBlockEventArgs)">
            <summary>
            在刚收到数据时触发，即在适配器之前。
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnReceivingDataAsync(`0,TouchSocket.Sockets.ByteBlockEventArgs)">
            <summary>
            在刚收到数据时触发，即在适配器之前。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnSending(`0,TouchSocket.Sockets.SendingEventArgs)">
            <summary>
            当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数，当设置e.IsPermitOperation=false时，中断发送。</param>
        </member>
        <member name="M:TouchSocket.Sockets.TcpPluginBase`1.OnSendingDataAsync(`0,TouchSocket.Sockets.SendingEventArgs)">
            <summary>
            当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.UdpSessionPluginBase">
            <summary>
            UdpSessionPluginBase
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.UdpSessionPluginBase`1">
            <summary>
            Udp插件实现类
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionPluginBase`1.Logger">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionPluginBase`1.Order">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.UdpSessionPluginBase`1.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionPluginBase`1.TouchSocket#Sockets#IUdpSessionPlugin#OnReceivedData(TouchSocket.Sockets.IUdpSession,TouchSocket.Sockets.UdpReceivedDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionPluginBase`1.OnReceivedData(`0,TouchSocket.Sockets.UdpReceivedDataEventArgs)">
            <summary>
            收到数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Sockets.UdpSessionPluginBase`1.OnReceivedDataAsync(`0,TouchSocket.Sockets.UdpReceivedDataEventArgs)">
            <summary>
            在收到数据时触发
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.IWaitingClient`1">
            <summary>
            等待型客户端。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IWaitingClient`1.WaitingOptions">
            <summary>
            等待设置。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.IWaitingClient`1.Client">
            <summary>
            客户端终端
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponse(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponse(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponse(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送流中的有效数据
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponseAsync(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponseAsync(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.IWaitingClient`1.SendThenResponseAsync(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="T:TouchSocket.Sockets.ResponsedData">
            <summary>
            响应数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.ResponsedData.#ctor(System.Byte[],TouchSocket.Sockets.IRequestInfo)">
            <summary>
            构造函数
            </summary>
            <param name="data"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="P:TouchSocket.Sockets.ResponsedData.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.ResponsedData.RequestInfo">
            <summary>
            RequestInfo
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponse(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponse(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponse(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送流中的有效数据
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponseAsync(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponseAsync(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenResponseAsync(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturn(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturn(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送字节流
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturn(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发送流中的有效数据
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturnAsync(System.Byte[],System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturnAsync(System.Byte[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="buffer">数据缓存区</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.SendThenReturnAsync(TouchSocket.Core.ByteBlock,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送
            </summary>
            <param name="byteBlock">数据块载体</param>
            <param name="timeout">超时时间</param>
            <param name="token">取消令箭</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">客户端没有连接</exception>
            <exception cref="T:TouchSocket.Sockets.OverlengthException">发送数据超长</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回的数据</returns>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClient`1.OnHandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:TouchSocket.Sockets.WaitingClientExtension">
            <summary>
            WaitingClientExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WaitingClientExtension.GetWaitingClient``1(``0,TouchSocket.Sockets.WaitingOptions)">
            <summary>
            获取可等待的客户端。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="waitingOptions"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.WaitingOptions">
            <summary>
            等待设置
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.WaitingOptions.ThrowBreakException">
            <summary>
            当Client为Tcp系时。是否在断开连接时以异常返回结果。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.WaitingOptions.BreakTrigger">
            <summary>
            当Client为Tcp系时。是否在断开连接时立即触发结果。默认会返回null。当<see cref="P:TouchSocket.Sockets.WaitingOptions.ThrowBreakException"/>为<see langword="true"/>时，会触发异常。
            </summary>
        </member>
        <member name="P:TouchSocket.Sockets.WaitingOptions.AdapterFilter">
            <summary>
            适配器筛选
            </summary>
        </member>
        <member name="T:TouchSocket.Sockets.AdapterFilter">
            <summary>
            适配器筛选
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.AdapterFilter.AllAdapter">
            <summary>
            发送和接收都经过适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.AdapterFilter.SendAdapter">
            <summary>
            发送经过适配器，接收不经过
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.AdapterFilter.WaitAdapter">
            <summary>
            发送不经过适配器，接收经过
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.AdapterFilter.NoneAll">
            <summary>
            全都不经过适配器。
            </summary>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketStatus">
            <summary>
            TouchSocket资源枚举
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.UnknownError">
            <summary>
            未知错误
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.Success">
            <summary>
            操作成功
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.Overtime">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.Canceled">
            <summary>
            用户主动取消操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.ArgumentNull">
            <summary>
            参数‘{0}’为空。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.Exception">
             <summary>
            发生异常，信息：{0}。
             </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.RoutingNotAllowed">
            <summary>
            不允许路由该包，信息：{0}。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.RpcMethodNotFind">
            <summary>
            未找到该公共方法，或该方法未标记为Rpc
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.RpcMethodDisable">
            <summary>
            方法已被禁用
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.RpcInvokeException">
            <summary>
            函数执行异常，详细信息：{0}
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.GetEventArgsFail">
            <summary>
            事件操作器异常
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.SetChannelFail">
            <summary>
            通道设置失败。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.ChannelExisted">
            <summary>
            ID为{0}的通道已存在。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.RemoteRefuse">
            <summary>
            远程终端拒绝该操作，反馈信息：{0}。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.CreateWriteStreamFail">
            <summary>
            从‘{0}’创建写入流失败，信息：{1}。"
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.StreamNotFind">
             <summary>
            没有找到路径‘{0}’对应的流文件。
             </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.ClientNotFind">
            <summary>
            没有找到ID为{0}的客户端。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.StreamReferencing">
            <summary>
            路径‘{0}’对应的流文件，仍然被‘{1}’对象应用。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.StreamBucketNull">
            <summary>
            接收流容器为空
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.LoadStreamFail">
            <summary>
            从‘{0}’路径加载流异常，信息：‘{1}’。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.DirectoryExisted">
            <summary>
            目录‘{0}’已存在。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.FileExisted">
            <summary>
            文件‘{0}’已存在。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.FileNotExists">
            <summary>
            文件‘{0}’不存在。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.DirectoryNotExists">
            <summary>
            目录‘{0}’不存在。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.EventExisted">
            <summary>
            名称为“{0}”的事件已存在
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.EventNotExist">
            <summary>
            名称为“{0}”的事件不存在
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.ResourceHandleNotFind">
            <summary>
            资源句柄{0}对应的资源没有找到，可能操作已超时。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.HasUnFinished">
            <summary>
            还有{0}个资源没有完成。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.FileLengthTooLong">
            <summary>
            文件长度太长。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.LengthErrorWhenRead">
            <summary>
            读取文件长度错误。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.NotFindAnyTargetId">
            <summary>
            没有找到任何可用的目标Id。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.TokenExisted">
            <summary>
            Token消息为‘{0}’的已注册。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.MessageNotFound">
            <summary>
            Token消息为‘{0}’的未注册。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.NullDataAdapter">
            <summary>
            数据处理适配器为空，可能客户端已掉线。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.NotConnected">
            <summary>
            客户端没有连接
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketStatus.LicenceKeyInvalid">
            <summary>
            授权密钥无效，程序将在5秒后退出。请检查密钥，或者不使用企业版功能。
            </summary>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketStatusExtension">
            <summary>
            StatusExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Resources.TouchSocketStatusExtension.ToStatus(System.Byte)">
            <summary>
            转为状态字
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Resources.TouchSocketStatusExtension.ToValue(TouchSocket.Resources.TouchSocketStatus)">
            <summary>
            转为数值
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.IRpcActionFilter">
            <summary>
            RPC行为过滤器。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.Executed(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <summary>
            成功执行Rpc后。
            <para>如果修改<paramref name="invokeResult"/>的InvokeStatus，或Result。则会影响RPC最终结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.ExecutedAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <summary>
            成功执行Rpc后。
            <para>如果修改<paramref name="invokeResult"/>的InvokeStatus，或Result。则会影响RPC最终结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.ExecutException(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@,System.Exception)">
            <summary>
            执行Rpc遇见异常。
            <para>如果修改<paramref name="invokeResult"/>的InvokeStatus，或Result。则会影响RPC最终结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.ExecutExceptionAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@,System.Exception)">
            <summary>
            执行Rpc遇见异常。
            <para>如果修改<paramref name="invokeResult"/>的InvokeStatus，或Result。则会影响RPC最终结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.Executing(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <summary>
            在执行Rpc之前。
            <para>当<paramref name="invokeResult"/>的InvokeStatus不为<see cref="F:TouchSocket.Rpc.InvokeStatus.Ready"/>。则不会执行RPC</para>
            <para>同时，当<paramref name="invokeResult"/>的InvokeStatus为<see cref="F:TouchSocket.Rpc.InvokeStatus.Success"/>。会直接返回结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcActionFilter.ExecutingAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <summary>
            在执行Rpc之前。
            <para>当<paramref name="invokeResult"/>的InvokeStatus不为<see cref="F:TouchSocket.Rpc.InvokeStatus.Ready"/>。则不会执行RPC</para>
            <para>同时，当<paramref name="invokeResult"/>的InvokeStatus为<see cref="F:TouchSocket.Rpc.InvokeStatus.Success"/>。会直接返回结果</para>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
        </member>
        <member name="T:TouchSocket.Rpc.RpcActionFilterAttribute">
            <summary>
            RpcActionFilterAttribute
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.Executed(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.ExecutedAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.ExecutException(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.ExecutExceptionAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.Executing(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.RpcActionFilterAttribute.ExecutingAsync(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.RpcAttribute">
            <summary>
            Rpc方法属性基类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.InvokenKey">
            <summary>
            调用键。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.ClassCodeGenerator">
            <summary>
            类生成器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.Exceptions">
            <summary>
            异常提示
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.GeneratorFlag">
            <summary>
            生成代码
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.MethodFlags">
            <summary>
            函数标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcAttribute.MethodName">
            <summary>
            重新指定生成的函数名称。可以使用类似“JsonRpc_{0}”的模板格式。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetCannotInvoke(TouchSocket.Rpc.MethodInstance)">
            <summary>
            当使用TryCanInvoke不能调用时，执行的代码。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetDescription(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取注释信息
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetExtensionsMethodProxyCode(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取扩展的代理代码
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetGenericInterfaceTypes">
            <summary>
            获取生成的函数泛型限定名称。默认<see cref="T:TouchSocket.Rpc.IRpcClient"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetInstanceProxyCode(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取生成实体类时的代码块
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetInterfaceProxyCode(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取接口的代理代码
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetInvokenKey(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取调用键
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetInvokeOption">
            <summary>
            获取调用配置
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetMethodName(TouchSocket.Rpc.MethodInstance,System.Boolean)">
            <summary>
            获取生成的函数名称
            </summary>
            <param name="methodInstance"></param>
            <param name="isAsync"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetParameters(TouchSocket.Rpc.MethodInstance,System.Boolean@,System.Boolean@,System.Reflection.ParameterInfo[]@)">
            <summary>
            获取参数生成
            </summary>
            <param name="methodInstance"></param>
            <param name="isOut"></param>
            <param name="isRef"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetProxyParameterName(System.Reflection.ParameterInfo)">
            <summary>
            从类型获取代理名
            </summary>
            <param name="parameterInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcAttribute.GetReturn(TouchSocket.Rpc.MethodInstance,System.Boolean)">
            <summary>
            获取返回值
            </summary>
            <param name="methodInstance"></param>
            <param name="isAsync"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.RpcProxyAttribute">
            <summary>
            代理类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcProxyAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="className"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcProxyAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcProxyAttribute.ClassName">
            <summary>
            代理类名
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.ClassCellCode">
            <summary>
            属性单元代码。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ClassCellCode.Name">
            <summary>
            属性名
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ClassCellCode.Code">
            <summary>
            代码本体
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.ClassCodeGenerator">
            <summary>
            代码辅助类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.ClassCodeGenerator.#ctor(System.Reflection.Assembly[])">
            <summary>
            构造函数
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="P:TouchSocket.Rpc.ClassCodeGenerator.Assembly">
            <summary>
            程序集
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ClassCodeGenerator.GenericTypeDic">
            <summary>
            泛型类型字典
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ClassCodeGenerator.PropertyDic">
            <summary>
            属性类型字典。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.ClassCodeGenerator.GetClassCellCodes">
            <summary>
            获取类单元参数
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ClassCodeGenerator.GetTypeFullName(System.Type)">
            <summary>
            获取类型全名
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ClassCodeGenerator.GetTypeFullName(System.Reflection.ParameterInfo)">
            <summary>
            获取类型全名
            </summary>
            <param name="parameterInfo"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.CodeGenerator">
            <summary>
            代码生成器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.AddIgnoreProxyAssembly(System.Reflection.Assembly)">
            <summary>
            添加不需要代理的程序集
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.AddIgnoreProxyType(System.Type)">
            <summary>
            添加不需要代理的类型
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.AddProxyAssembly(System.Reflection.Assembly)">
            <summary>
            添加需要代理的程序集
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.AddProxyType(System.Type,System.Boolean)">
            <summary>
            添加代理类型
            </summary>
            <param name="type"></param>
            <param name="deepSearch"></param>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.AddProxyType``1(System.Boolean)">
            <summary>
            添加代理类型
            </summary>
            <typeparam name="T"></typeparam>
            <param name="deepSearch"></param>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.ContainsType(System.Type)">
            <summary>
            是否包含类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.ConvertToCode(System.String,TouchSocket.Rpc.ServerCellCode[])">
            <summary>
            转换为cs代码。
            </summary>
            <param name="namespace"></param>
            <param name="serverCodes"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.Generator``2">
            <summary>
            生成代码代理
            </summary>
            <typeparam name="TServer">服务类型</typeparam>
            <typeparam name="TAttribute">属性标签</typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.Generator(System.Type,System.Type)">
            <summary>
            生成代码代理
            </summary>
            <param name="serverType">服务类型</param>
            <param name="attributeType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.GetMethodInstances``1">
            <summary>
            从类型获取函数实例
            </summary>
            <typeparam name="TServer"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.GetProxyCodes(System.String,System.Type[],System.Type[])">
            <summary>
            生成代理代码
            </summary>
            <param name="namespace"></param>
            <param name="serverTypes"></param>
            <param name="attributeTypes"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.GetMethodInstances(System.Type)">
            <summary>
            从类型获取函数实例
            </summary>
            <param name="serverType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.CodeGenerator.TryGetProxyTypeName(System.Type,System.String@)">
            <summary>
            获取类型代理名称
            </summary>
            <param name="type"></param>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.MethodCellCode">
            <summary>
            生成的代码单元
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodCellCode.Name">
            <summary>
            方法名
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodCellCode.CodeTemple">
            <summary>
            代码本体
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodCellCode.InterfaceTemple">
            <summary>
            接口代码。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodCellCode.ExtensionsTemple">
            <summary>
            扩展代码
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.ServerCellCode">
            <summary>
            服务单元代码
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.ServerCellCode.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.IncludeInterface">
            <summary>
            包含接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.IncludeInstance">
            <summary>
            包含实例
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.IncludeExtension">
            <summary>
            包含扩展
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.Name">
            <summary>
            服务名
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.Methods">
            <summary>
            方法集合
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ServerCellCode.ClassCellCodes">
            <summary>
            类参数集合。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.ActionMap">
            <summary>
            服务映射图
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ActionMap.ActionKeys">
            <summary>
            服务键集合
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.Add(System.String,TouchSocket.Rpc.MethodInstance)">
            <summary>
            添加调用
            </summary>
            <param name="actionKey"></param>
            <param name="methodInstance"></param>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.GetAllMethodInstances">
            <summary>
            获取所有服务函数实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.GetEnumerator">
            <summary>
            返回迭代器
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.GetMethodInstance(System.String)">
            <summary>
            通过actionKey获取函数实例
            </summary>
            <param name="actionKey"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.Remove(System.String,TouchSocket.Rpc.MethodInstance@)">
            <summary>
            移除
            </summary>
            <param name="actionKey"></param>
            <param name="methodInstance"></param>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.Remove(System.String)">
            <summary>
            移除
            </summary>
            <param name="actionKey"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.ActionMap.TryGetMethodInstance(System.String,TouchSocket.Rpc.MethodInstance@)">
            <summary>
            通过actionKey获取函数实例
            </summary>
            <param name="actionKey"></param>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.FeedbackType">
            <summary>
            反馈类型
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.FeedbackType.OnlySend">
            <summary>
            仅发送
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.FeedbackType.WaitSend">
            <summary>
            等待，直到发送抵达
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.FeedbackType.WaitInvoke">
            <summary>
            等待，直到调用完成
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.InvokeResult">
            <summary>
            调用结果
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.InvokeResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.InvokeResult.Message">
            <summary>
            信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.InvokeResult.Result">
            <summary>
            执行返回值结果
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.MethodInstance">
            <summary>
            Rpc函数实例
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.MethodInstance.#ctor(System.Reflection.MethodInfo)">
            <summary>
            构造函数
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.ServerFactory">
            <summary>
            服务实例工厂
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.Description">
            <summary>
            描述属性
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.Filters">
            <summary>
            筛选器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.IsEnable">
            <summary>
            是否可用
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.IsSingleton">
            <summary>
            是否为单例
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.MethodFlags">
            <summary>
            函数标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.ParameterNames">
            <summary>
            参数名集合
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.Parameters">
            <summary>
            参数集合
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.ParameterTypes">
            <summary>
            参数类型集合，已处理out及ref，无参数时为空集合，
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.RpcAttributes">
            <summary>
            Rpc属性集合
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.MethodInstance.ServerType">
            <summary>
            实例类型
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.MethodInstance.GetAttribute``1">
            <summary>
            获取指定类型属性标签
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.MethodInstance.GetAttribute(System.Type)">
            <summary>
            获取指定类型属性标签
            </summary>
            <param name="attributeType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.RpcServer">
            <summary>
            Rpc范围类
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.RpcServerFactory">
            <summary>
            RpcServerFactory
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcServerFactory.#ctor(TouchSocket.Core.IContainer)">
            <summary>
            构造函数
            </summary>
            <param name="container"></param>
        </member>
        <member name="T:TouchSocket.Rpc.RpcStore">
            <summary>
            Rpc仓库
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.RpcStore.Namespace">
            <summary>
            命名空间
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.RpcStore.ProxyKey">
            <summary>
            代理键
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.#ctor(TouchSocket.Core.IContainer)">
            <summary>
            实例化一个Rpc仓库。
            <para>需要指定<see cref="T:TouchSocket.Core.IContainer"/>容器。一般和对应的服务器、客户端共用一个容器比较好。</para>
            <para>如果，仅仅是只有一个解析器的话，可以考虑从配置<see cref="T:TouchSocket.Core.TouchSocketConfig"/>中，调用<see cref="M:TouchSocket.Core.RpcConfigExtensions.ConfigureRpcStore(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Rpc.RpcStore},TouchSocket.Rpc.RpcStore)"/></para>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.ProxyAttributeMap">
            <summary>
            代理属性映射。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.Container">
            <summary>
            内置IOC容器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.RpcParsers">
            <summary>
            解析器集合。
            <para>如果想快速获得对象，请使用<see cref="M:TouchSocket.Rpc.RpcStore.TryGetRpcParser(System.String,TouchSocket.Rpc.IRpcParser@)"/>，一般key为对象类型名称，或自定义的。</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.OnRequestProxy">
            <summary>
            请求代理。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.ProxyUrl">
            <summary>
            代理路径。默认为“/proxy”。
            <para>必须以“/”开头</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.ServerTypes">
            <summary>
            服务类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.RpcStore.Item(System.String)">
            <summary>
            获取IRpcParser
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetProxyInfo(System.String)">
            <summary>
            从远程获取代理
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.AddRpcParser(System.String,TouchSocket.Rpc.IRpcParser,System.Boolean)">
            <summary>
            添加Rpc解析器
            </summary>
            <param name="key">名称</param>
            <param name="parser">解析器实例</param>
            <param name="applyServer">是否应用已注册服务</param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetServerMethodInstances(System.Type)">
            <summary>
            获取服务类型对应的服务方法。
            </summary>
            <param name="serverType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.Execute(TouchSocket.Rpc.IRpcServer,System.Object[],TouchSocket.Rpc.ICallContext)">
            <summary>
            执行Rpc
            </summary>
            <param name="rpcServer"></param>
            <param name="ps"></param>
            <param name="callContext"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetAllMethods">
            <summary>
            获取所有已注册的函数。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.System#Collections#Generic#IEnumerable{TouchSocket#Rpc#IRpcParser}#GetEnumerator">
            <summary>
            返回枚举对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetProxyCodes(System.String,System.Type[])">
            <summary>
            本地获取代理
            </summary>
            <param name="namespace"></param>
            <param name="attrbuteTypes"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetProxyCodes(System.String)">
            <summary>
            本地获取代理
            </summary>
            <param name="namespace"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetProxyInfo">
            <summary>
            从本地获取代理
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.GetProxyInfo(System.Type[])">
            <summary>
            从本地获取代理
            </summary>
            <param name="attrbuteType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.RemoveRpcParser(System.String,TouchSocket.Rpc.IRpcParser@)">
            <summary>
            移除Rpc解析器
            </summary>
            <param name="parserName"></param>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.RemoveRpcParser(System.String)">
            <summary>
            移除Rpc解析器
            </summary>
            <param name="parserName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.ShareProxy(TouchSocket.Sockets.IPHost)">
            <summary>
            分享代理。
            </summary>
            <param name="iPHost"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.StopShareProxy">
            <summary>
            关闭分享中心
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.TryGetRpcParser(System.String,TouchSocket.Rpc.IRpcParser@)">
            <summary>
            获取IRpcParser
            </summary>
            <param name="key"></param>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.UnregisterServer(TouchSocket.Rpc.IRpcServer)">
            <summary>
            移除注册服务
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.UnregisterServer(System.Type)">
            <summary>
            移除注册服务
            </summary>
            <param name="providerType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.UnregisterServer``1">
            <summary>
            移除注册服务
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.RegisterServer(System.Type,TouchSocket.Rpc.IRpcServer)">
            <summary>
            注册为单例服务
            </summary>
            <param name="serverFromType"></param>
            <param name="rpcServer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStore.RegisterServer(System.Type,System.Type)">
            <summary>
            注册服务
            </summary>
            <param name="serverFromType"></param>
            <param name="serverToType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TransientRpcServer`1">
            <summary>
            TransientRpcServer
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TransientRpcServer`1.CallContext">
            <summary>
            调用上下文。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TransientRpcServer">
            <summary>
            TransientRpcServer
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TransientRpcServer.CallContext">
            <summary>
            调用上下文。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.CodeGeneratorFlag">
            <summary>
            代码生成标识
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.Sync">
            <summary>
            生成同步代码
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.Async">
            <summary>
            生成异步代码
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.ExtensionSync">
            <summary>
            生成扩展同步代码
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.ExtensionAsync">
            <summary>
            生成扩展异步代码
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.IncludeInterface">
            <summary>
            包含接口
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.IncludeInstance">
            <summary>
            包含实例
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.CodeGeneratorFlag.IncludeExtension">
            <summary>
            包含扩展
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.InvokeStatus">
            <summary>
            调用状态
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.Ready">
            <summary>
            就绪
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.UnFound">
            <summary>
            未找到服务
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.UnEnable">
            <summary>
            不可用
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.Success">
            <summary>
            成功调用
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.InvocationException">
            <summary>
            调用内部异常
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.InvokeStatus.Exception">
            <summary>
            其他异常
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.MethodFlags">
            <summary>
            函数标识
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.MethodFlags.None">
            <summary>
            空
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.MethodFlags.IncludeCallContext">
            <summary>
            包含调用上下文
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.RpcException">
            <summary>
            Rpc异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcException.#ctor">
             <summary>
            构造函数
             </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcException.#ctor(System.String,System.Exception)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
             <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            构造函数
             </summary>
             <param name="info"></param>
             <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.RpcInvokeException">
            <summary>
            Rpc调用异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcInvokeException.#ctor">
             <summary>
            构造函数
             </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcInvokeException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcInvokeException.#ctor(System.String,System.Exception)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
             <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcInvokeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            构造函数
             </summary>
             <param name="info"></param>
             <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.RpcParserExtensions">
            <summary>
            RpcParserExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.GetProxyCodes(TouchSocket.Rpc.IRpcParser,System.String,System.Type[])">
            <summary>
            获取本地代理
            </summary>
            <param name="rpcParser"></param>
            <param name="namespace"></param>
            <param name="attrbuteTypes"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.GetProxyCodes(TouchSocket.Rpc.IRpcParser,System.String)">
            <summary>
             获取本地代理
            </summary>
            <param name="rpcParser"></param>
            <param name="namespace"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterAllServer(TouchSocket.Rpc.IRpcParser)">
            <summary>
            注册所有服务
            </summary>
            <returns>返回搜索到的服务数</returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer``2(TouchSocket.Rpc.IRpcParser)">
            <summary>
            注册所有服务
            </summary>
            <returns>返回注册实例</returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer(TouchSocket.Rpc.IRpcParser,System.Type,System.Type)">
            <summary>
            注册服务
            </summary>
            <param name="rpcParser"></param>
            <param name="providerInterfaceType"></param>
            <param name="providerType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer``1(TouchSocket.Rpc.IRpcParser,``0)">
            <summary>
            注册为单例服务
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="rpcParser"></param>
            <param name="serverProvider"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer(TouchSocket.Rpc.IRpcParser,System.Type,TouchSocket.Rpc.IRpcServer)">
            <summary>
            注册为单例服务
            </summary>
            <param name="rpcParser"></param>
            <param name="providerInterfaceType"></param>
            <param name="serverProvider"></param>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer``1(TouchSocket.Rpc.IRpcParser)">
            <summary>
            注册服务
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.RegisterServer(TouchSocket.Rpc.IRpcParser,System.Type)">
            <summary>
            注册服务
            </summary>
            <param name="rpcParser"></param>
            <param name="fromType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.UnregisterServer(TouchSocket.Rpc.IRpcParser,TouchSocket.Rpc.IRpcServer)">
            <summary>
            移除注册服务
            </summary>
            <param name="rpcParser"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.UnregisterServer(TouchSocket.Rpc.IRpcParser,System.Type)">
            <summary>
            移除注册服务
            </summary>
            <param name="rpcParser"></param>
            <param name="providerType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcParserExtensions.UnregisterServer``1(TouchSocket.Rpc.IRpcParser)">
            <summary>
            移除注册服务
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.RpcStoreExtensions">
            <summary>
            RpcStoreExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStoreExtensions.RegisterAllServer(TouchSocket.Rpc.RpcStore)">
            <summary>
            注册所有服务
            </summary>
            <returns>返回搜索到的服务数</returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStoreExtensions.RegisterServer``1(TouchSocket.Rpc.RpcStore)">
            <summary>
            注册服务
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStoreExtensions.RegisterServer(TouchSocket.Rpc.RpcStore,System.Type)">
            <summary>
            注册服务
            </summary>
            <param name="rpcStore"></param>
            <param name="providerType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStoreExtensions.RegisterServer``2(TouchSocket.Rpc.RpcStore)">
            <summary>
            注册服务
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.RpcStoreExtensions.RegisterServer``1(TouchSocket.Rpc.RpcStore,``0)">
            <summary>
            注册为单例服务
            </summary>
            <typeparam name="TFrom"></typeparam>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.ICallContext">
            <summary>
            调用上下文
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ICallContext.Caller">
            <summary>
            调用此服务的主体。
            <para>
            <list type="bullet">
            <item>当该服务在<see cref="T:TouchSocket.Sockets.ITcpService"/>及派生中调用时，该值一般为<see cref="T:TouchSocket.Sockets.ISocketClient"/>对象。</item>
            <item>当该服务在<see cref="T:TouchSocket.Sockets.ITcpClient"/>及派生中调用时，该值一般为<see cref="T:TouchSocket.Sockets.ITcpClient"/>对象。</item>
            <item>当该服务在<see cref="T:TouchSocket.Sockets.IUdpSession"/>及派生中调用时，该值一般为<see cref="T:TouchSocket.Rpc.TouchRpc.UdpCaller"/>对象。</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ICallContext.MethodInstance">
            <summary>
            本次调用的<see cref="P:TouchSocket.Rpc.ICallContext.MethodInstance"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ICallContext.TokenSource">
            <summary>
            可取消的调用令箭
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.IInvokeOption">
            <summary>
            调用配置接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IInvokeOption.Token">
            <summary>
            可以取消的调用令箭
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IInvokeOption.FeedbackType">
            <summary>
            调用反馈
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IInvokeOption.Timeout">
            <summary>
            调用超时
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.IRemoteServer">
            <summary>
            远程服务接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IRemoteServer.Client">
            <summary>
            客户端
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.IRpcClient">
            <summary>
            Rpc接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IRpcClient.TryCanInvoke">
            <summary>
            检验能否执行Rpc调用
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            <para>如果调用端为客户端，则会调用服务器Rpc服务。</para>
            <para>如果调用端为服务器，则会反向调用客户端Rpc服务。</para>
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            <para>如果调用端为客户端，则会调用服务器Rpc服务。</para>
            <para>如果调用端为服务器，则会反向调用客户端Rpc服务。</para>
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>服务器返回结果</returns>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            <para>如果调用端为客户端，则会调用服务器Rpc服务。</para>
            <para>如果调用端为服务器，则会反向调用客户端Rpc服务。</para>
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="types">对应类型集合</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回值</returns>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            <para>如果调用端为客户端，则会调用服务器Rpc服务。</para>
            <para>如果调用端为服务器，则会反向调用客户端Rpc服务。</para>
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            <para>如果调用端为客户端，则会调用服务器Rpc服务。</para>
            <para>如果调用端为服务器，则会反向调用客户端Rpc服务。</para>
            </summary>
            <param name="invokeKey">调用键</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">Rpc服务器未注册</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>服务器返回结果</returns>
        </member>
        <member name="T:TouchSocket.Rpc.IRpcParser">
            <summary>
            Rpc解析器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.IRpcParser.RpcStore">
            <summary>
            RPC仓库。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcParser.SetRpcStore(TouchSocket.Rpc.RpcStore)">
            <summary>
            设置此解析器的服务器实例
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcParser.OnRegisterServer(TouchSocket.Rpc.MethodInstance[])">
            <summary>
            注册服务
            </summary>
            <param name="methodInstances"></param>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcParser.OnUnregisterServer(TouchSocket.Rpc.MethodInstance[])">
            <summary>
            取消注册服务
            </summary>
            <param name="methodInstances"></param>
        </member>
        <member name="T:TouchSocket.Rpc.IRpcServer">
            <summary>
            Rpc服务接口
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.IRpcServerFactory">
            <summary>
            IRpcServerFactory
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.IRpcServerFactory.Create(TouchSocket.Rpc.ICallContext,System.Object[])">
            <summary>
            创建rpc实例
            </summary>
            <param name="callContext"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.ITransientRpcServer">
            <summary>
            Rpc服务接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.ITransientRpcServer.CallContext">
            <summary>
            调用上下文
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute">
            <summary>
            适用于JsonRpc的标记
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute.#ctor(System.Boolean)">
            <summary>
             适用于JsonRpc的标记.
             <para>是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。</para>
            </summary>
            <param name="methodInvoke"></param>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute.#ctor(System.String)">
            <summary>
            适用于JsonRpc的标记.
            </summary>
            <param name="invokenKey"></param>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute.MethodInvoke">
            <summary>
            是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute.GetGenericInterfaceTypes">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcAttribute.GetInvokenKey(TouchSocket.Rpc.MethodInstance)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonResponseContext">
            <summary>
            JsonRpc响应器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonResponseContext.jsonrpc">
            <summary>
            jsonrpc
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonResponseContext.result">
            <summary>
            result
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonResponseContext.error">
            <summary>
            error
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonResponseContext.id">
            <summary>
            id
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.error">
            <summary>
            错误
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.error.code">
            <summary>
            code
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.error.message">
            <summary>
            message
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext">
            <summary>
            JsonRpc调用上下文
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.JsonString">
            <summary>
            Json字符串
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.Caller">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.JsonRpcContext">
            <summary>
            JsonRpc上下文
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.MethodInstance">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.TokenSource">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.HttpContext">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcCallContext.JRPT">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcContext">
            <summary>
            JsonRpcPackage
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcContext.parameters">
            <summary>
            parameters
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcContext.needResponse">
            <summary>
            needResponse
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcRequest">
            <summary>
            JsonRpcRequest
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcRequest.jsonrpc">
            <summary>
            jsonrpc
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcRequest.method">
            <summary>
            method
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcRequest.params">
            <summary>
            @params
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcRequest.id">
            <summary>
            id
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcSuccessResponse">
            <summary>
            JsonRpcSuccessResponse
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcSuccessResponse.jsonrpc">
            <summary>
            jsonrpc
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcSuccessResponse.result">
            <summary>
            result
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcSuccessResponse.id">
            <summary>
            id
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcErrorResponse">
            <summary>
            JsonRpcErrorResponse
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcErrorResponse.jsonrpc">
            <summary>
            jsonrpc
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcErrorResponse.error">
            <summary>
            error
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JsonRpcErrorResponse.id">
            <summary>
            id
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcClient">
            <summary>
            JsonRpc客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.BufferLength">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.CanSend">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.CanSetDataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Client">
            <summary>
            内部客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Config">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Connected">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Connecting">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Container">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.DataHandlingAdapter">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Disconnected">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Disconnecting">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.IP">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.IsClient">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.JRPT">
            <summary>
            协议类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.LastReceivedTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.LastSendTime">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Logger">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.MainSocket">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.OnHandleRawBuffer">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.OnHandleReceivedData">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Online">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.PluginsManager">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Port">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Protocol">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.ReceiveType">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.RemoteIPHost">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.TryCanInvoke">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.UsePlugin">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcClient.UseSsl">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Close">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Close(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Connect(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.ConnectAsync(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.DefaultSend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.DefaultSendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.GetStream">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.GetValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Send(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.SendAsync(TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.SetDataHandlingAdapter(TouchSocket.Sockets.DataHandlingAdapter)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Setup(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.SetValue``1(TouchSocket.Core.IDependencyProperty{``0},``0)">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            处理数据
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.HasValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">函数名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">方法名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.RpcException">Rpc异常</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>服务器返回结果</returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcClient.RemoveValue``1(TouchSocket.Core.IDependencyProperty{``0})">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JRPT">
            <summary>
            JsonRpc协议类型
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JRPT.Tcp">
            <summary>
            普通TCP协议
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JRPT.Http">
            <summary>
            Http协议
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.JsonRpc.JRPT.Websocket">
            <summary>
            Websocket协议
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.IJsonRpcCallContext">
            <summary>
            IJsonRpcCallContext
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.IJsonRpcCallContext.JsonString">
            <summary>
            Json字符串
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.IJsonRpcCallContext.JsonRpcContext">
            <summary>
            JsonRpc数据包
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.IJsonRpcCallContext.JRPT">
            <summary>
            表明当前的调用协议。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.IJsonRpcClient">
            <summary>
            IJsonRpcClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin">
            <summary>
            JsonRpcParser解析器插件
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.#ctor(TouchSocket.Rpc.RpcStore)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.ActionMap">
            <summary>
            JsonRpc的调用键。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.AutoSwitch">
            <summary>
            自动转换协议
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.JsonRpcUrl">
            <summary>
            当挂载在<see cref="T:TouchSocket.Http.HttpService"/>时，匹配Url然后响应。当设置为null或空时，会全部响应。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.RpcStore">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.NoSwitchProtocol">
            <summary>
            不需要自动转化协议。
            <para>仅当服务器是TCP时生效。此时如果携带协议为TcpJsonRpc时才会解释为jsonRpc。</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.SetJsonRpcUrl(System.String)">
            <summary>
            当挂载在<see cref="T:TouchSocket.Http.HttpService"/>时，匹配Url然后响应。当设置为null或空时，会全部响应。
            </summary>
            <param name="jsonRpcUrl"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.OnConnecting(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.OnHandleWSDataFrame(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.OnPost(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.JsonRpc.JsonRpcParserPlugin.OnReceivedData(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Sockets.ReceivedDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcAttribute">
            <summary>
            TouchRpc方法标记属性类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcAttribute.#ctor(System.Boolean)">
            <summary>
             适用于TouchRpc的标记.
             <para>是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。</para>
            </summary>
            <param name="methodInvoke"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcAttribute.#ctor(System.String)">
            <summary>
            适用于TouchRpc的标记.
            </summary>
            <param name="invokenKey"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcAttribute.MethodInvoke">
            <summary>
            是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcAttribute.GetInvokenKey(TouchSocket.Rpc.MethodInstance)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.Channel">
            <summary>
            通道
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.Available">
            <summary>
            是否具有数据可读
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.CacheCapacity">
            <summary>
            缓存容量
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.CanMoveNext">
            <summary>
            判断当前通道能否调用<see cref="M:TouchSocket.Rpc.TouchRpc.Channel.MoveNext"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.CanWrite">
            <summary>
            能否写入
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.ID">
            <summary>
            通道ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.LastOperationMes">
            <summary>
            最后一次操作时显示消息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.TargetId">
            <summary>
            目的ID地址。仅当该通道由两个客户端打通时有效。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.Timeout">
            <summary>
            超时时间，默认1000*10ms。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.Channel.Using">
            <summary>
            是否被使用
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.Cancel(System.String)">
            <summary>
            取消
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.CancelAsync(System.String)">
            <summary>
            异步取消
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.Complete(System.String)">
            <summary>
            完成操作
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.CompleteAsync(System.String)">
            <summary>
            异步完成操作
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.GetCurrent">
            <summary>
            获取当前的数据
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.HoldOn(System.String)">
            <summary>
            继续。
            <para>调用该指令时，接收方会跳出接收，但是通道依然可用，所以接收方需要重新调用<see cref="M:TouchSocket.Rpc.TouchRpc.Channel.MoveNext"/></para>
            </summary>
            <param name="operationMes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.HoldOnAsync(System.String)">
            <summary>
            异步调用继续
            </summary>
            <param name="operationMes"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.MoveNext">
            <summary>
            转向下个元素
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.MoveNextAsync">
            <summary>
            转向下个元素
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.ReadAsync">
            <summary>
            阻塞读取数据，直到有数据，或者超时。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.TryWrite(System.Byte[],System.Int32,System.Int32)">
            <summary>
            尝试写入。
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.TryWrite(System.Byte[])">
            <summary>
            尝试写入
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.TryWriteAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            异步尝试写入
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.TryWriteAsync(System.Byte[])">
            <summary>
            异步尝试写入
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入通道
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.Write(System.Byte[])">
            <summary>
            写入通道
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.WriteAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入通道
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.Channel.WriteAsync(System.Byte[])">
            <summary>
            写入通道
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.Available">
            <summary>
            是否具有数据可读
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.CacheCapacity">
            <summary>
            缓存容量
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.CanMoveNext">
            <summary>
            判断当前通道能否调用<see cref="M:TouchSocket.Rpc.TouchRpc.InternalChannel.MoveNext"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.CanWrite">
            <summary>
            能否写入
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.ID">
            <summary>
            ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.LastOperationMes">
            <summary>
            最后一次操作时显示消息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.TargetId">
            <summary>
            目的ID地址。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InternalChannel.Using">
            <summary>
            是否被使用
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.Cancel(System.String)">
            <summary>
            取消
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.Complete(System.String)">
            <summary>
            完成操作
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.HoldOn(System.String)">
            <summary>
            继续。
            <para>调用该指令时，接收方会跳出接收，但是通道依然可用，所以接收方需要重新调用<see cref="M:TouchSocket.Rpc.TouchRpc.InternalChannel.MoveNext"/></para>
            </summary>
            <param name="operationMes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.GetCurrent">
            <summary>
            获取当前的数据
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.MoveNext">
            <summary>
            转向下个元素
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InternalChannel.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入通道
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ChannelStatus">
            <summary>
            通道状态
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Moving">
            <summary>
            继续下移
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Overtime">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.HoldOn">
            <summary>
            继续
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Cancel">
            <summary>
            取消
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Completed">
            <summary>
            完成
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.ChannelStatus.Disposed">
            <summary>
            已释放
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitCreateChannelPackage">
            <summary>
            WaitCreateChannel
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitCreateChannelPackage.Random">
            <summary>
            随机ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitCreateChannelPackage.ChannelID">
            <summary>
            通道ID
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.FlowOperator">
            <summary>
            关于具有流速的操作器。
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.FlowOperator.completedLength">
            <summary>
            已完成长度
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.FlowOperator.m_progress">
            <summary>
            进度
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.CompletedLength">
            <summary>
            已完成长度
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.IsEnd">
            <summary>
            由<see cref="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Result"/>的结果，判断是否已结束操作。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Length">
            <summary>
            数据源的全部长度。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.MaxSpeed">
            <summary>
            最大传输速度。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Progress">
            <summary>
            进度
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Result">
            <summary>
            执行结果
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Timeout">
            <summary>
            超时时间，默认10*1000ms。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FlowOperator.Token">
            <summary>
            可取消令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FlowOperator.Speed">
            <summary>
            从上次获取到此次获得的速度
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FlowOperator.SetResult(TouchSocket.Core.Result)">
            <summary>
            设置结果状态
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FlowOperator.AddFlow(System.Int32)">
            <summary>
            添加流速(线程安全)
            </summary>
            <param name="flow"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IDependencyTouchRpc">
            <summary>
            IDependencyTouchRpc
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITouchRpc">
            <summary>
            ITouchRpc
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.ITouchRpc.RpcActor">
            <summary>
            Rpc执行角色
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITouchRpcCallContext">
            <summary>
            ITouchRpcCallContext
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcCallContext.TryCancel">
            <summary>
            当<see cref="P:TouchSocket.Rpc.ICallContext.TokenSource"/>不为空时，调用<see cref="M:System.Threading.CancellationTokenSource.Cancel"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.ITouchRpcCallContext.TouchRpcPackage">
            <summary>
            TouchRpcContext
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.ITouchRpcCallContext.SerializationType">
            <summary>
            序列化类型
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITouchRpcService">
            <summary>
            ITouchRpcService
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="targetId">目标ID</param>
            <param name="protocol">协议</param>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.SendAsync(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向对应ID的客户端发送
            </summary>
            <param name="targetId">目标ID</param>
            <param name="protocol">协议</param>
            <param name="buffer">数据</param>
            <param name="offset">偏移</param>
            <param name="length">长度</param>
            <exception cref="T:TouchSocket.Sockets.NotConnectedException">未连接异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">未找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcUtility">
            <summary>
            TouchRpcUtility
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.TouchRpc">
            <summary>
            TouchRpc字符串
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.TouchRpcProtocol">
            <summary>
            TouchRpc
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.TransferPackage">
            <summary>
            传输分包
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_0_Handshake_Request">
            <summary>
            握手
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1_ResetID_Request">
            <summary>
            重置ID
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1000_Handshake_Response">
            <summary>
            握手响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1001_ResetID_Response">
            <summary>
            重置ID响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1002_Ping_Response">
            <summary>
            Ping回应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_2_Ping_Request">
            <summary>
            Ping
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_100_CreateChannel_Request">
            <summary>
            创建一个面向对方的通道
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1100_CreateChannel_Response">
            <summary>
            创建通道回应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_101_ChannelPackage">
            <summary>
            通道数据
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1200_Invoke_Response">
            <summary>
            调用响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_200_Invoke_Request">
            <summary>
            调用
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_204_CancelInvoke">
            <summary>
            取消调用
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1400_SendStreamToSocketClient_Response">
            <summary>
            向服务器发送流响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_400_SendStreamToSocketClient_Request">
            <summary>
            向服务器发送流
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_401_SendStreamToClient">
            <summary>
            向客户端发送流
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1500_PullFile_Response">
            <summary>
            拉取文件响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1501_BeginPullFile_Response">
            <summary>
            开始拉取文件响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1502_PushFile_Response">
            <summary>
            推送文件响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_500_PullFile_Request">
            <summary>
            拉取文件
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_501_BeginPullFile_Request">
            <summary>
            开始拉取文件
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_502_PushFile_Request">
            <summary>
            推送文件
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_509_PushFileAck_Request">
            <summary>
            推送文件状态确认
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_517_PullSmallFile_Request">
            <summary>
            拉取小文件请求
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1517_PullSmallFile_Response">
            <summary>
            拉取确认小文件响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_518_PushSmallFile_Request">
            <summary>
            推送小文件请求
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1518_PushSmallFile_Response">
            <summary>
            推送确认小文件响应
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_600_Redis_Request">
            <summary>
            Redis
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcUtility.P_1600_Redis_Response">
            <summary>
            Redis回应
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitSetID">
            <summary>
            设置ID
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WaitSetID.#ctor">
            <summary>
            重置Id
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WaitSetID.#ctor(System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="oldID"></param>
            <param name="newID"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitSetID.OldID">
            <summary>
            旧ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitSetID.NewID">
            <summary>
            新ID
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitVerify">
            <summary>
            验证消息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitVerify.Token">
            <summary>
            令箭
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitVerify.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitVerify.ID">
            <summary>
            ID
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient">
            <summary>
            HttpRpcClient
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.#ctor">
            <summary>
            创建一个HttpTouchRpcClient实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.ActionMap">
            <summary>
            服务器映射
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.ID">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.IsHandshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.ChannelExisted(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Connect(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.ResetID(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnFileTransfered(TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnFileTransfering(TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnHandshaked(TouchSocket.Sockets.MsgEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnReceived(System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据。
            </summary>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnRouting(TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnStreamTransfered(TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcClient.OnStreamTransfering(TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService">
            <summary>
            Http Rpc解释器
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1">
            <summary>
            HttpRpcParser泛型类型
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.#ctor">
            <summary>
            创建一个HttpTouchRpcService实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.ActionMap">
            <summary>
            方法映射表
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnConnecting(`0,TouchSocket.Sockets.OperationEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnFileTransfered(`0,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnFileTransfering(`0,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnHandshaked(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnHandshaking(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnReceived(`0,System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnRouting(`0,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            在需要转发路由包时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnStreamTransfered(`0,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。覆盖父类方法将不会触发事件和插件。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.OnStreamTransfering(`0,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。覆盖父类方法将不会触发事件和插件。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcService`1.SendAsync(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient">
            <summary>
            Http服务器辅助类
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.IsHandshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.ChannelExisted(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.ResetID(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.OnReceivedHttpRequest(TouchSocket.Http.HttpRequest)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpTouchRpcSocketClient.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IHttpTouchRpcClient">
            <summary>
            IHttpRpcClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IHttpTouchRpcSocketClient">
            <summary>
            IHttpTouchRpcSocketClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IHttpRpcClientBase">
            <summary>
            IHttpRpcClientBase
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IHttpTouchRpcService">
            <summary>
            IHttpTouchRpcService
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcActorGroup">
            <summary>
            RpcActorGroup
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.GetInvokeMethod">
            <summary>
            获取调用函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnClose">
            <summary>
            请求关闭
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnFileTransfered">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnFileTransfering">
            <summary>
            在文件传输即将进行时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnFindRpcActor">
            <summary>
            查找其他RpcActor
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnHandshaked">
            <summary>
            在完成握手连接时
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnHandshaking">
            <summary>
            握手
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnReceived">
            <summary>
            接收到数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnRouting">
            <summary>
            需要路由
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnStreamTransfered">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OnStreamTransfering">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.OutputSend">
            <summary>
            发送数据接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.Config">
            <summary>
            配置
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActorGroup.RpcStore">
            <summary>
            RpcStore
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorGroup.CreateRpcActor(System.Object)">
            <summary>
            创建RpcActor
            </summary>
            <param name="caller"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITcpTouchRpcClient">
            <summary>
            ITcpRpcClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITcpTouchRpcSocketClient">
            <summary>
            ITcpTouchRpcSocketClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITcpRpcClientBase">
            <summary>
            ITcpRpcClientBase
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITcpTouchRpcService">
            <summary>
            ITcpTouchRpcService
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient">
            <summary>
            TcpTouchRpcClient
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.#ctor">
            <summary>
            创建一个TcpTouchRpcClient实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.ActionMap">
            <summary>
            方法映射表
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.ID">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.IsHandshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.ChannelExisted(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Connect(System.Int32)">
            <summary>
            建立Tcp连接，并且执行握手。
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.ResetID(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnFileTransfered(TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnFileTransfering(TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnHandshaked(TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnReceived(System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据。
            </summary>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnRouting(TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnStreamTransfered(TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcClient.OnStreamTransfering(TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService">
            <summary>
            TcpTouchRpcService
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1">
            <summary>
            TcpTouchRpcService泛型类型
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.#ctor">
            <summary>
            创建一个TcpTouchRpcService实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.ActionMap">
            <summary>
            方法映射表
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnConnecting(`0,TouchSocket.Sockets.OperationEventArgs)">
            <summary>
            客户端请求连接
            </summary>
            <param name="socketClient"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnFileTransfered(`0,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnRouting(`0,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            在需要转发路由包时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnFileTransfering(`0,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnHandshaked(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnHandshaking(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnReceived(`0,System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnStreamTransfered(`0,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。覆盖父类方法将不会触发事件和插件。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.OnStreamTransfering(`0,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。覆盖父类方法将不会触发事件和插件。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService`1.SendAsync(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient">
            <summary>
            Rpc服务器辅助类
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.IsHandshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.VerifyTimeout">
            <summary>
            验证超时时间,默认为3000ms
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.ChannelExisted(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.ResetID(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.HandleReceivedData(TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.OnConnected(TouchSocket.Core.TouchSocketEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.OnConnecting(TouchSocket.Sockets.OperationEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Send(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SendAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            不允许直接发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.SendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            不允许直接发送
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TcpTouchRpcSocketClient.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IUdpTouchRpc">
            <summary>
            IUdpTouchRpc
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.UdpTouchRpc">
            <summary>
            UDP Rpc解释器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.ActionMap">
            <summary>
            方法映射表
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.IsHandshaked">
            <summary>
            不需要握手，所以此值一直为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.HandleReceivedData(System.Net.EndPoint,TouchSocket.Core.ByteBlock,TouchSocket.Sockets.IRequestInfo)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpTouchRpc.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IWSTouchRpcClient">
            <summary>
            IWSTouchRpcClient
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IWSTouchRpcClient.ConnectAsync(System.Int32)">
            <summary>
            异步连接
            </summary>
            <param name="timeout">验证超时时间</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient">
            <summary>
            WSTouchRpcClient
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.#ctor">
            <summary>
            创建一个WSTouchRpcClient实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.ActionMap">
            <summary>
            方法映射表
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.CanSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Config">
            <summary>
            客户端配置
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Container">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Disconnected">
            <summary>
            断开连接
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.ID">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.IsHandshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.LastActiveTime">
            <summary>
            最后活动时间
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Logger">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PluginsManager">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.RemoteIPHost">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.RpcActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.TryCanInvoke">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.UsePlugin">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.ChannelExisted(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Close(System.String)">
            <summary>
            关闭
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.ConnectAsync(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.ResetID(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Setup(System.String)">
            <summary>
            配置
            </summary>
            <param name="ipHost"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Setup(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            配置
            </summary>
            <param name="clientConfig"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnDisconnected(TouchSocket.Sockets.DisconnectEventArgs)">
            <summary>
            已断开连接。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnFileTransfered(TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnFileTransfering(TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnHandshaked(TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnReceived(System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据。
            </summary>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnRouting(TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnStreamTransfered(TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.WSTouchRpcClient.OnStreamTransfering(TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions">
            <summary>
            Rpc配置扩展
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.DefaultIdProperty">
            <summary>
            默认使用Id。
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.MetadataProperty">
            <summary>
            TouchClient连接时的元数据, 所需类型<see cref="T:TouchSocket.Core.Metadata"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SerializationSelectorProperty">
            <summary>
            序列化转换器, 所需类型<see cref="T:TouchSocket.Rpc.TouchRpc.SerializationSelector"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.VerifyTimeoutProperty">
            <summary>
            验证超时时间,默认为3000ms, 所需类型<see cref="T:System.Int32"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.VerifyTokenProperty">
            <summary>
            连接令箭,当为null或空时，重置为默认值“rrqm”, 所需类型<see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetDefaultId(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            设置默认的使用Id。仅在TouchRpc组件适用。
            <para>
            使用该功能时，仅在服务器的Handshaking之后生效。且如果id重复，则会连接失败。
            </para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetHeartbeatFrequency(TouchSocket.Core.TouchSocketConfig,System.Object)">
            <summary>
            心跳频率，默认为间隔2000ms，3次。（设置为null时禁止心跳）
            <para>仅适用于TouchRpcClient系类</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetMetadata(TouchSocket.Core.TouchSocketConfig,TouchSocket.Core.Metadata)">
            <summary>
            设置TouchClient连接时的元数据
            <para>仅适用于TouchRpcClient系类</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetSerializationSelector(TouchSocket.Core.TouchSocketConfig,TouchSocket.Rpc.TouchRpc.SerializationSelector)">
            <summary>
            设置序列化转换器
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetVerifyTimeout(TouchSocket.Core.TouchSocketConfig,System.Int32)">
            <summary>
            验证超时时间,默认为3000ms.
            <para>该配置仅<see cref="T:TouchSocket.Rpc.TouchRpc.TcpTouchRpcService"/>有效</para>
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetVerifyToken(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            连接令箭，当为null或空时，重置为默认值“rrqm”
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.RootPathProperty">
            <summary>
            根目录
            所需类型<see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.SetRootPath(TouchSocket.Core.TouchSocketConfig,System.String)">
            <summary>
            设置根路径
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithTcpTouchRpcClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建TcpTouchRpc类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithTcpTouchRpcClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建TcpTouchRpc类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithTcpTouchRpcService``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建TcpTouchRpc类服务器，并启动。
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithTcpTouchRpcService(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建TcpTouchRpc类服务器，并启动。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithHttpTouchRpcClient``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建HttpTouchRpc类客户端，并连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithHttpTouchRpcClient(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建HttpTouchRpc类客户端，并连接
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithHttpTouchRpcService``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建HttpTouchRpc类服务器，并启动。
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithHttpTouchRpcService(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建HttpTouchRpc类服务器，并启动。
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithUdpTouchRpc``1(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建UdpTouchRpc类
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcConfigExtensions.BuildWithUdpTouchRpc(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            构建UdpTouchRpc类客户端
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RouteType">
            <summary>
            路由类型
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.#ctor(System.String)">
            <summary>
            路由类型
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.op_Equality(TouchSocket.Rpc.TouchRpc.RouteType,TouchSocket.Rpc.TouchRpc.RouteType)">
            <summary>
            判断RouteType是相等。
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.op_Inequality(TouchSocket.Rpc.TouchRpc.RouteType,TouchSocket.Rpc.TouchRpc.RouteType)">
            <summary>
            判断RouteType不相等。
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.Equals(System.Object)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.GetHashCode">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RouteType.ToString">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.Ping">
            <summary>
            一个Ping探测路由包
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.CreateChannel">
            <summary>
            创建通道路由包。
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.Rpc">
            <summary>
            Rpc调用的路由包
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.PullFile">
            <summary>
            拉取文件的路由包
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.LoadRemoteStream">
            <summary>
            加载远程流数据
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RouteType.PushFile">
            <summary>
            推送文件的路由包
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TransferFlags">
            <summary>
            传输标识
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferFlags.None">
            <summary>
            无任何标识
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferFlags.BreakpointResume">
            <summary>
            断点续传。
            <para>使用该标识时，会使用文件长度验证续传的有效性。如果需要，也可以附加<see cref="F:TouchSocket.Rpc.TouchRpc.TransferFlags.MD5Verify"/>验证。</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferFlags.MD5Verify">
            <summary>
            MD5验证。该标识在文件传输完成时，也会再次验证文件长度。
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferFlags.DeleteWhenFail">
            <summary>
            当传输失败时，删除所有缓存文件。
            <para>注意：当启用断点续传时，该标识无效</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TransferType">
            <summary>
            传输类型
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.Push">
            <summary>
            推送
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.Pull">
            <summary>
            拉取
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.SectionPush">
            <summary>
            分块推送
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.SectionPull">
            <summary>
            分块拉取
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.SmallPush">
            <summary>
            小文件推送
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TransferType.SmallPull">
            <summary>
            小文件拉取
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TransferTypeExtension">
            <summary>
            TransferTypeExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TransferTypeExtension.IsPull(TouchSocket.Rpc.TouchRpc.TransferType)">
            <summary>
            表示当前传输类型是否属于<see cref="F:TouchSocket.Rpc.TouchRpc.TransferType.Pull"/>、<see cref="F:TouchSocket.Rpc.TouchRpc.TransferType.SectionPull"/>、<see cref="F:TouchSocket.Rpc.TouchRpc.TransferType.SmallPull"/>其中的一种。
            </summary>
            <param name="transferType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs">
            <summary>
            操作文件事件类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.TransferType,TouchSocket.Rpc.TouchRpc.FileOperator,TouchSocket.Rpc.TouchRpc.RemoteFileInfo)">
            <summary>
            FileOperationEventArgs
            </summary>
            <param name="transferType"></param>
            <param name="fileOperator"></param>
            <param name="fileInfo"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.TransferType,TouchSocket.Core.Metadata,TouchSocket.Rpc.TouchRpc.RemoteFileInfo)">
            <summary>
            FileOperationEventArgs
            </summary>
            <param name="transferType"></param>
            <param name="metadata"></param>
            <param name="fileInfo"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.SavePath">
            <summary>
            存放路径，
            可输入绝对路径，也可以输入相对路径。
            但是必须包含文件名及扩展名。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.ResourcePath">
            <summary>
            请求文件路径，
            可输入绝对路径，也可以输入相对路径。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.FileOperator">
            <summary>
            文件操作器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.FileInfo">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.Flags">
            <summary>
            传输标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperationEventArgs.TransferType">
            <summary>
            传输类型
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs">
            <summary>
            文件传输状态
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.TransferType,TouchSocket.Core.Metadata,TouchSocket.Rpc.TouchRpc.RemoteFileInfo,TouchSocket.Core.Result)">
            <summary>
            FileTransferStatusEventArgs
            </summary>
            <param name="transferType"></param>
            <param name="result"></param>
            <param name="metadata"></param>
            <param name="fileInfo"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.TransferType,TouchSocket.Core.Result,TouchSocket.Rpc.TouchRpc.RemoteFileInfo,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            FileTransferStatusEventArgs
            </summary>
            <param name="transferType"></param>
            <param name="result"></param>
            <param name="fileInfo"></param>
            <param name="fileOperator"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.#ctor(TouchSocket.Core.Result,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            FileTransferStatusEventArgs
            </summary>
            <param name="result"></param>
            <param name="args"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result">
            <summary>
            结果
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.HttpVerifyOptionEventArgs">
            <summary>
            Http验证
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.HttpVerifyOptionEventArgs.#ctor(TouchSocket.Http.HttpContext,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="context"></param>
            <param name="token"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.HttpVerifyOptionEventArgs.Token">
            <summary>
            验证令箭
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs">
            <summary>
            PackageRouterEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.RouteType,TouchSocket.Core.RouterPackage)">
            <summary>
            PackageRouterEventArgs
            </summary>
            <param name="routerType"></param>
            <param name="package"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs.RouterType">
            <summary>
            路由类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs.Package">
            <summary>
            路由数据包。一般为不完全数据，仅包含基本的路由信息。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs">
            <summary>
            协议数据事件
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs.#ctor(System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            构造函数
            </summary>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs.ByteBlock">
            <summary>
            数据流，实际解析时应当偏移两个字节
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs.Protocol">
            <summary>
            协议
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.StreamEventArgs">
            <summary>
            流事件参数
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.StreamEventArgs.#ctor(TouchSocket.Core.Metadata,TouchSocket.Rpc.TouchRpc.StreamInfo)">
            <summary>
            构造函数
            </summary>
            <param name="metadata"></param>
            <param name="streamInfo"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamEventArgs.Bucket">
            <summary>
            用于接收流的容器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamEventArgs.Metadata">
            <summary>
            用于可传输的元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamEventArgs.StreamInfo">
            <summary>
            流信息
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs">
            <summary>
            接收流数据
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs.#ctor(TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata,TouchSocket.Rpc.TouchRpc.StreamInfo)">
            <summary>
            构造函数
            </summary>
            <param name="streamOperator"></param>
            <param name="metadata"></param>
            <param name="streamInfo"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs.StreamOperator">
            <summary>
            流操作
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs">
            <summary>
            具有返回状态的流
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs.Result">
            <summary>
            结果
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs.#ctor(TouchSocket.Core.Result,TouchSocket.Core.Metadata,TouchSocket.Rpc.TouchRpc.StreamInfo)">
            <summary>
            构造函数
            </summary>
            <param name="result"></param>
            <param name="metadata"></param>
            <param name="streamInfo"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs">
            <summary>
            连接验证
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs.Token">
            <summary>
            令箭
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs.#ctor(System.String,TouchSocket.Core.Metadata)">
            <summary>
            构造函数
            </summary>
            <param name="token"></param>
            <param name="metadata"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ProtocolException">
            <summary>
            协议异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ProtocolException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ProtocolException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ProtocolException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TokenVerifyException">
            <summary>
            Token验证异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TokenVerifyException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TokenVerifyException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TokenVerifyException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TokenVerifyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            构造函数
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcKeyException">
            <summary>
            Rpc添加方法键异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcKeyException.#ctor">
             <summary>
            构造函数
             </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcKeyException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcKeyException.#ctor(System.String,System.Exception)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
             <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcKeyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            构造函数
             </summary>
             <param name="info"></param>
             <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException">
            <summary>
            Rpc无注册异常
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException.#ctor">
             <summary>
            构造函数
             </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException.#ctor(System.String,System.Exception)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
             <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcNoRegisterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            构造函数
             </summary>
             <param name="info"></param>
             <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">
            <summary>
            序列化异常类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcSerializationException.#ctor">
             <summary>
            构造函数
             </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcSerializationException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcSerializationException.#ctor(System.String,System.Exception)">
             <summary>
            构造函数
             </summary>
             <param name="message"></param>
             <param name="inner"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
             <summary>
            构造函数
             </summary>
             <param name="info"></param>
             <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcActorExtensions">
            <summary>
            RpcActorExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySend``1(``0,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySend``1(``0,System.Int16,System.Byte[])">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySend``1(``0,System.Int16)">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySend``1(``0,System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySendAsync``1(``0,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySendAsync``1(``0,System.Int16,System.Byte[])">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.TrySendAsync``1(``0,System.Int16)">
            <summary>
            尝试发送
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.Send``1(``0,System.Int16,System.Byte[])">
            <summary>
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Send(System.Int16,System.Byte[],System.Int32,System.Int32)"/>
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.Send``1(``0,System.Int16)">
            <summary>
             <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Send(System.Int16,System.Byte[],System.Int32,System.Int32)"/>
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.Send``1(``0,System.Int16,TouchSocket.Core.ByteBlock)">
            <summary>
             <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Send(System.Int16,System.Byte[],System.Int32,System.Int32)"/>
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.SendAsync``1(``0,System.Int16,System.Byte[])">
            <summary>
             <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)"/>
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActorExtensions.SendAsync``1(``0,System.Int16)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)"/>
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcContainerExtension">
            <summary>
            TouchRpcContainerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcContainerExtension.SetFileResourceController(TouchSocket.Core.IContainer,TouchSocket.Rpc.TouchRpc.IFileResourceController)">
            <summary>
            设置文件资源控制器。
            </summary>
            <param name="container"></param>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcContainerExtension.SetFileResourceController``1(TouchSocket.Core.IContainer)">
            <summary>
            设置文件资源控制器。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="container"></param>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.TouchRpcContainerExtension.FileController">
            <summary>
            默认的全局资源控制器。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcContainerExtension.GetFileResourceController(TouchSocket.Core.IContainer)">
            <summary>
            获取文件资源控制器。如果没有注册的话，会新建一个<see cref="T:TouchSocket.Rpc.TouchRpc.FileResourceController"/>
            </summary>
            <param name="container"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions">
            <summary>
            RPC辅助扩展
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.CreateIDRpcClient``1(``0,System.String)">
            <summary>
            创建一个直接向目标地址请求的Rpc客户端。
            </summary>
            <param name="client"></param>
            <param name="targetId"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.PullFiles(TouchSocket.Rpc.TouchRpc.IRpcActor,System.Int32,TouchSocket.Rpc.TouchRpc.FileOperator[])">
            <summary>
            批量拉取文件
            </summary>
            <param name="client">终端</param>
            <param name="multipleCount">并行数量</param>
            <param name="fileOperators">批量操作器</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.PullFilesAsync(TouchSocket.Rpc.TouchRpc.IRpcActor,System.Int32,TouchSocket.Rpc.TouchRpc.FileOperator[])">
            <summary>
            异步批量拉取文件
            </summary>
            <param name="client">终端</param>
            <param name="multipleCount">并行数量</param>
            <param name="fileOperators">批量操作器</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.PushFiles(TouchSocket.Rpc.TouchRpc.IRpcActor,System.Int32,TouchSocket.Rpc.TouchRpc.FileOperator[])">
            <summary>
            批量推送文件
            </summary>
            <param name="client">终端</param>
            <param name="multipleCount">并行数量</param>
            <param name="fileOperators">批量操作器</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.PushFilesAsync(TouchSocket.Rpc.TouchRpc.IRpcActor,System.Int32,TouchSocket.Rpc.TouchRpc.FileOperator[])">
            <summary>
            异步批量推送文件
            </summary>
            <param name="client">终端</param>
            <param name="multipleCount">并行数量</param>
            <param name="fileOperators">批量操作器</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.SwitchProtocolToTouchRpc(TouchSocket.Sockets.ITcpClientBase)">
            <summary>
            转化Protocol协议标识为TouchRpc
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcExtensions.ToResultCode(TouchSocket.Rpc.TouchRpc.ChannelStatus)">
            <summary>
            转为ResultCode
            </summary>
            <param name="channelStatus"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension">
            <summary>
            TouchRpcServiceExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension.Send(TouchSocket.Rpc.TouchRpc.ITouchRpcService,System.String,System.Int16,System.Byte[])">
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension.Send(TouchSocket.Rpc.TouchRpc.ITouchRpcService,System.String,System.Int16)">
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension.Send(TouchSocket.Rpc.TouchRpc.ITouchRpcService,System.String,System.Int16,TouchSocket.Core.ByteBlock)">
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.Send(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension.SendAsync(TouchSocket.Rpc.TouchRpc.ITouchRpcService,System.String,System.Int16,System.Byte[])">
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.SendAsync(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcServiceExtension.SendAsync(TouchSocket.Rpc.TouchRpc.ITouchRpcService,System.String,System.Int16)">
            <inheritdoc cref="M:TouchSocket.Rpc.TouchRpc.ITouchRpcService.SendAsync(System.String,System.Int16,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.FileOperator">
            <summary>
            文件传输操作器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperator.Flags">
            <summary>
            传输标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperator.SavePath">
            <summary>
            存放路径，
            可输入绝对路径，也可以输入相对路径。
            但是必须包含文件名及扩展名。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.FileOperator.ResourcePath">
            <summary>
            资源文件路径，
            可输入绝对路径，也可以输入相对路径。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.FileResourceController">
            <summary>
            文件资源控制器。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileResourceController.GetFileInfo``1(System.String,System.Boolean,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileResourceController.GetFullPath(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileResourceController.TryReadTempInfo(System.String,TouchSocket.Rpc.TouchRpc.TransferFlags,TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileResourceController.ReadAllBytes(System.IO.FileInfo,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.FileResourceController.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IFileResourceController">
            <summary>
            文件资源控制器。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IFileResourceController.GetFileInfo``1(System.String,System.Boolean,``0@)">
            <summary>
            获取文件信息
            </summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <param name="md5"></param>
            <param name="fileInfo"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IFileResourceController.GetFullPath(System.String,System.String)">
            <summary>
            获取全路径
            </summary>
            <param name="root"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IFileResourceController.TryReadTempInfo(System.String,TouchSocket.Rpc.TouchRpc.TransferFlags,TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo@)">
            <summary>
            读取缓存文件信息
            </summary>
            <param name="path"></param>
            <param name="flags"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IFileResourceController.ReadAllBytes(System.IO.FileInfo,System.Byte[])">
            <summary>
            读取文件的所有数据
            </summary>
            <param name="fileInfo"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IFileResourceController.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入数据到文件
            </summary>
            <param name="fileInfo"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.PullSmallFileResult">
            <summary>
            PullSmallFileResult
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.PullSmallFileResult.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            初始化PullSmallFileResult
            </summary>
            <param name="resultCode"></param>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.PullSmallFileResult.#ctor(System.Byte[])">
            <summary>
            初始化PullSmallFileResult
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.PullSmallFileResult.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            初始化PullSmallFileResult
            </summary>
            <param name="resultCode"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.PullSmallFileResult.Value">
            <summary>
            实际的文件数据
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.PullSmallFileResult.Save(System.String,System.Boolean)">
            <summary>
            将拉取的数据保存为文件。
            </summary>
            <param name="path"></param>
            <param name="overwrite"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RemoteFileInfo">
            <summary>
            RemoteFileInfo
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.#ctor">
            <summary>
            初始化一个RemoteFileInfo
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.#ctor(System.IO.FileInfo)">
            <summary>
            从FileInfo初始化一个RemoteFileInfo
            </summary>
            <param name="fileInfo"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.MD5">
            <summary>
            文件MD5
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.Length">
            <summary>
            文件大小
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.Package(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileInfo.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RemoteFileOperator">
            <summary>
            远程文件控制器。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo">
            <summary>
            远程文件系统信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.Name">
            <summary>
            目录或文件的名称。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.FullName">
            <summary>
            目录或文件的完整目录。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.LastWriteTime">
            <summary>
            上次写入当前文件或目录的时间
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.LastAccessTime">
            <summary>
            上次访问当前文件或目录的时间
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.CreationTime">
            <summary>
            当前文件或目录的创建时间
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.Attributes">
            <summary>
            当前文件或目录的特性
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.Package(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RemoteFileSystemInfo.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo">
            <summary>
            TouchRpcFileInfo
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo.Package(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcFileInfo.Unpackage(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcFileStream">
            <summary>
            文件流
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcFileStream.SaveInterval">
            <summary>
            进度保存时间，默认1000毫秒。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcFileStream.SaveProgress">
            <summary>
            保存进度
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.FileInfo">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.Flags">
            <summary>
            传输标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.SavePath">
            <summary>
            存放路径，
            可输入绝对路径，也可以输入相对路径。
            但是必须包含文件名及扩展名。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.ResourcePath">
            <summary>
            请求文件路径，
            可输入绝对路径，也可以输入相对路径。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitFileInfoPackage.EventHashCode">
            <summary>
            事件Code
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitTransferPackage">
            <summary>
            等待传输
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitTransferPackage.ChannelID">
            <summary>
            通道标识
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitTransferPackage.Path">
            <summary>
            路径
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitTransferPackage.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitTransferPackage.EventHashCode">
            <summary>
            事件Code
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.DeliverEventArgs">
            <summary>
            投递事件
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.MessageQueueClient">
            <summary>
            MessageQueueClient
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.MessageQueueClient.Converter">
            <summary>
            序列化转换器。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.MessageQueueClientExtensions">
            <summary>
            MessageQueueClientExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.MessageQueueClientExtensions.MessageQueueClientProperty">
            <summary>
            获取或设置MessageQueueClient的注入键。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.MessageQueueClientExtensions.GetMessageQueueClient``1(``0)">
            <summary>
            获取MessageQueueClient
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.MessageQueuePlugin">
            <summary>
            MessageQueuePlugin
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.MessageQueuePlugin.Converter">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.MessageQueuePlugin.SetConverter(TouchSocket.Core.BytesConverter)">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.MessageQueuePlugin.OnHandshaked(TouchSocket.Rpc.TouchRpc.IDependencyTouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.MessageQueuePlugin.OnReceivedProtocolData(TouchSocket.Rpc.TouchRpc.IDependencyTouchRpc,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin">
            <summary>
            ITouchRpcPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnFileTransfered(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnFileTransferedAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnFileTransfering(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnFileTransferingAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnHandshaked(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnRouting(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnRoutingAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnHandshakedAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnHandshaking(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client">客户端</param>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnHandshakingAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnReceivedProtocolData(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnReceivedProtocolDataAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnStreamTransfered(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            当流数据传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnStreamTransferedAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            当流数据传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnStreamTransfering(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITouchRpcPlugin.OnStreamTransferingAsync(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1">
            <summary>
            具有委托能力的插件
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetFileTransfered(System.Action{`0,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs})">
            <summary>
            SetFileTransfered
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetFileTransfering(System.Action{`0,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs})">
            <summary>
            SetFileTransfering
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetHandshaked(System.Action{`0,TouchSocket.Sockets.MsgEventArgs})">
            <summary>
            SetHandshaked
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetHandshaking(System.Action{`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs})">
            <summary>
            SetHandshaking
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetReceivedProtocolData(System.Action{`0,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs})">
            <summary>
            SetReceivedProtocolData
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetStreamTransfered(System.Action{`0,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs})">
            <summary>
            SetStreamTransfered
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.SetStreamTransfering(System.Action{`0,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs})">
            <summary>
            SetStreamTransfering
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnFileTransfered(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnFileTransfering(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnHandshaked(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnHandshaking(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnReceivedProtocolData(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnStreamTransfered(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcActionPlugin`1.OnStreamTransfering(TouchSocket.Rpc.TouchRpc.ITouchRpc,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1">
            <summary>
            TouchRpcHeartbeatPlugin
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.FailedCount">
            <summary>
            连接失败次数。当成功连接时，会重置为0。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.Interval">
            <summary>
            心跳间隔。默认3秒。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.MaxFailCount">
            <summary>
            最大失败次数，默认3。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.SetInterval(System.TimeSpan)">
            <summary>
            心跳间隔。默认3秒。
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.SetMaxFailCount(System.Int32)">
            <summary>
            最大失败次数，默认3。
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcHeartbeatPlugin`1.OnHandshaked(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase">
            <summary>
            TouchRpc插件基类
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1">
            <summary>
            TouchRpc插件基类
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnFileTransfered(`0,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnFileTransferedAsync(`0,TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs)">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnFileTransfering(`0,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnFileTransferingAsync(`0,TouchSocket.Rpc.TouchRpc.FileOperationEventArgs)">
            <summary>
            在文件传输即将进行时触发。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnHandshaked(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnHandshakedAsync(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在完成握手连接时。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnHandshaking(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnHandshakingAsync(`0,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnReceivedProtocolData(`0,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnReceivedProtocolDataAsync(`0,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            收到协议数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnRouting(`0,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnRoutingAsync(`0,TouchSocket.Rpc.TouchRpc.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnStreamTransfered(`0,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnStreamTransferedAsync(`0,TouchSocket.Rpc.TouchRpc.StreamStatusEventArgs)">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnStreamTransfering(`0,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPluginBase`1.OnStreamTransferingAsync(`0,TouchSocket.Rpc.TouchRpc.StreamOperationEventArgs)">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RedisClient">
            <summary>
            具有远程键值存贮的操作端。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RedisClient.Converter">
            <summary>
            序列化转换器。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RedisClient.Timeout">
            <summary>
            超时设定。默认30000ms
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.Add``1(System.String,``0,System.Int32)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Core.ICache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})"/>
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="duration"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.AddCache(TouchSocket.Core.ICacheEntry{System.String,System.Byte[]})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.AddCacheAsync(TouchSocket.Core.ICacheEntry{System.String,System.Byte[]})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.ClearCache">
            <summary>
            <inheritdoc/>
            </summary>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.ClearCacheAsync">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.ContainsCache(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.ContainsCacheAsync(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.Get``1(System.String)">
            <summary>
            获取缓存的键值对。
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.GetCache(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.GetCacheAsync(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.RemoveCache(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.RemoveCacheAsync(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.Set``1(System.String,``0,System.Int32)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Core.ICache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})"/>
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="duration"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.SetCache(TouchSocket.Core.ICacheEntry{System.String,System.Byte[]})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.SetCacheAsync(TouchSocket.Core.ICacheEntry{System.String,System.Byte[]})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClient.TryGet``1(System.String,``0@)">
            <summary>
            获取指定键的值。
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:System.TimeoutException">操作超时</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.InternalRedisClient">
            <summary>
            RedisClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RedisClientExtensions">
            <summary>
            RedisClientExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RedisClientExtensions.RedisClientProperty">
            <summary>
            获取或设置RedisClient的注入键。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisClientExtensions.GetRedisClient``1(``0)">
            <summary>
            获取RedisClient
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RedisPlugin">
            <summary>
            RedisPlugin
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RedisPlugin.Converter">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RedisPlugin.ICache">
            <summary>
            实际储存缓存。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisPlugin.SetCache(TouchSocket.Core.ICache{System.String,System.Byte[]})">
            <summary>
            设置实际储存缓存。
            </summary>
            <param name="cache"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisPlugin.SetConverter(TouchSocket.Core.BytesConverter)">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisPlugin.OnHandshaked(TouchSocket.Rpc.TouchRpc.IDependencyTouchRpc,TouchSocket.Rpc.TouchRpc.VerifyOptionEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RedisPlugin.OnReceivedProtocolData(TouchSocket.Rpc.TouchRpc.IDependencyTouchRpc,TouchSocket.Rpc.TouchRpc.ProtocolDataEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IDRpcActor">
            <summary>
            IDRpcActor
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.#ctor(System.String,TouchSocket.Rpc.TouchRpc.IRpcActor)">
            <summary>
            构造函数
            </summary>
            <param name="targetId"></param>
            <param name="rpcActor"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.IDRpcActor.TryCanInvoke">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.Dispose">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
            <param name="types"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IDRpcActor.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            <inheritdoc/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="invokeKey"></param>
            <param name="invokeOption"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IRpcActor">
            <summary>
            RpcActor接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.IRpcActor.IsHandshaked">
            <summary>
            表示是否已经完成握手连接。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.IRpcActor.RootPath">
            <summary>
            根路径
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.ChannelExisted(System.Int32)">
            <summary>
            判断使用该ID的Channel是否存在。
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.CreateChannel">
            <summary>
            创建通道
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.CreateChannel(System.Int32)">
            <summary>
            创建通道
            </summary>
            <param name="id">指定ID</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            从对点拉取文件
            </summary>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            异步从对点拉取文件
            </summary>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            拉取小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="path">请求路径</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            拉取小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="path">请求路径</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            向对点推送文件
            </summary>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            异步向对点推送文件
            </summary>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            推送小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="savePath">保存路径</param>
            <param name="fileInfo">推送的文件信息</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            推送小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="savePath">保存路径</param>
            <param name="fileInfo">推送的文件信息</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.ResetID(System.String)">
            <summary>
            重新设置ID
            </summary>
            <param name="newId"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <summary>
            发送流数据
            </summary>
            <param name="stream"></param>
            <param name="streamOperator"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <summary>
            异步发送流数据
            </summary>
            <param name="stream"></param>
            <param name="streamOperator"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActor.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <summary>
            订阅通道
            </summary>
            <param name="id"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.IRpcActorBase">
            <summary>
            RpcActorBase
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.IRpcActorBase.SerializationSelector">
            <summary>
            序列化选择器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Ping(System.Int32)">
            <summary>
            向通信的对方执行ping。
            </summary>
            <param name="timeout"></param>
            <returns>如果返回True，则表示一定在线。如果返回false，则不一定代表不在线。</returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节
            </summary>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.IRpcActorBase.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节
            </summary>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITargetRpcActor">
            <summary>
            ITargetRpcActor
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.CreateChannel(System.String)">
            <summary>
            创建一个和其他客户端的通道
            </summary>
            <param name="targetId">目标客户端ID</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.CreateChannel(System.String,System.Int32)">
            <summary>
            创建一个和其他客户端的通道
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="id">通道Id</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.Ping(System.String,System.Int32)">
            <summary>
            向指定的Id执行ping。
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="timeout">超时配置</param>
            <returns>如果返回True，则表示一定在线。如果返回false，则不一定代表不在线。</returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            从对点拉取文件
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="fileOperator">文件传输操作器</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            异步从对点拉取文件
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="fileOperator">文件传输操作器</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            向对点推送文件
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="fileOperator">文件传输操作器</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <summary>
            异步向对点推送文件
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="fileOperator">文件传输操作器</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            拉取小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="targetId">目标客户端ID</param>
            <param name="path">请求路径</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            拉取小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="targetId">目标客户端Id</param>
            <param name="path">请求路径</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            推送小文件到特定的Id。默认设置1024*1024字节大小。
            </summary>
            <param name="targetId">目标客户端Id</param>
            <param name="savePath">保存路径</param>
            <param name="fileInfo">推送的文件信息</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcActor.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            推送小文件。默认设置1024*1024字节大小。
            </summary>
            <param name="targetId"></param>
            <param name="savePath">保存路径</param>
            <param name="fileInfo">推送的文件信息</param>
            <param name="metadata">元数据</param>
            <param name="timeout">超时设置</param>
            <param name="token">可取消令箭</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.ITargetRpcClient">
            <summary>
            ITargetRpcClient
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回值</returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回值</returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.ITargetRpcClient.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            调用对应ID的客户端Rpc
            </summary>
            <param name="targetId">客户端ID</param>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">调用内部异常</exception>
            <exception cref="T:TouchSocket.Sockets.ClientNotFindException">没有找到ID对应的客户端</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>返回值</returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.RpcActor">
            <summary>
            RpcActor
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.ChannelExisted(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.CreateChannel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.CreateChannel(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.CreateChannel(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.CreateChannel(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.TrySubscribeChannel(System.Int32,TouchSocket.Rpc.TouchRpc.Channel@)">
            <summary>
            订阅通道
            </summary>
            <param name="id"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.RootPath">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushFile(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushFile(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushFileAsync(System.String,TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushFileAsync(TouchSocket.Rpc.TouchRpc.FileOperator)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.MaxSmallFileLength">
            <summary>
            允许传输的小文件的最大长度。默认1024*1024字节。
            <para>注意，当调整该值时，应该和对端保持一致。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullSmallFile(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullSmallFile(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullSmallFileAsync(System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PullSmallFileAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushSmallFile(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushSmallFile(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushSmallFileAsync(System.String,System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.PushSmallFileAsync(System.String,System.IO.FileInfo,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.Caller">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.RpcStore">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.SerializationSelector">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Invoke``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.InvokeAsync(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.InvokeAsync``1(System.String,System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.SendStream(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <summary>
            发送流数据
            </summary>
            <param name="stream"></param>
            <param name="streamOperator"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.SendStreamAsync(System.IO.Stream,TouchSocket.Rpc.TouchRpc.StreamOperator,TouchSocket.Core.Metadata)">
            <summary>
            发送流数据
            </summary>
            <param name="stream"></param>
            <param name="streamOperator"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.RpcActor.EndCodes">
            <summary>
            结束标识编码。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.GetInvokeMethod">
            <summary>
            获取调用函数的委托
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnClose">
            <summary>
            请求关闭
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnFileTransfered">
            <summary>
            当文件传输结束之后。并不意味着完成传输，请通过<see cref="P:TouchSocket.Rpc.TouchRpc.FileTransferStatusEventArgs.Result"/>属性值进行判断。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnRouting">
            <summary>
            当需要路由的时候
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnFileTransfering">
            <summary>
            在文件传输即将进行时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnFindRpcActor">
            <summary>
            查找其他RpcActor
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnHandshaked">
            <summary>
            在完成握手连接时
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnHandshaking">
            <summary>
            握手
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnReceived">
            <summary>
            接收到数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnResetID">
            <summary>
            重设ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnStreamTransfered">
            <summary>
            流数据处理，用户需要在此事件中对e.Bucket手动释放。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OnStreamTransfering">
            <summary>
            即将接收流数据，用户需要在此事件中对e.Bucket初始化。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.OutputSend">
            <summary>
            发送数据接口
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.FileController">
            <summary>
            文件资源访问接口。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.ID">
            <summary>
            本节点ID
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.IsHandshaked">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.IsService">
            <summary>
            是否为服务器组件
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.Logger">
            <summary>
            日志
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.SyncRoot">
            <summary>
             获取可用于同步对<see cref="T:TouchSocket.Rpc.TouchRpc.RpcActor"/>的访问的对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.TryCanInvoke">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.RpcActor.WaitHandlePool">
            <summary>
            等待返回池
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.#ctor(System.Boolean)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Close(System.String)">
            <summary>
            关闭
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Handshake(System.String,System.String,System.Threading.CancellationToken,System.Int32,TouchSocket.Core.Metadata)">
            <summary>
            建立对点
            </summary>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.TokenVerifyException"></exception>
            <exception cref="T:System.TimeoutException"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.InputReceivedData(TouchSocket.Core.ByteBlock)">
            <summary>
            处理接收数据
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.TryFindRpcActor(System.String,TouchSocket.Rpc.TouchRpc.RpcActor@)">
            <summary>
            尝试获取指定Id的RpcActor。一般此方法仅在Service下有效。
            </summary>
            <param name="targetId"></param>
            <param name="rpcActor"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.TryRoute(TouchSocket.Rpc.TouchRpc.RouteType,TouchSocket.Core.RouterPackage)">
            <summary>
            尝试请求路由，触发路由相关插件。
            </summary>
            <param name="routerType"></param>
            <param name="routerPackage"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.TryRoute(TouchSocket.Rpc.TouchRpc.RouteType,TouchSocket.Core.WaitRouterPackage)">
            <summary>
            尝试请求路由，触发路由相关插件。并在路由失败时向<see cref="P:TouchSocket.Core.MsgRouterPackage.Message"/>中传递消息。
            </summary>
            <param name="routerType"></param>
            <param name="routerPackage"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Ping(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Ping(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.ResetID(System.String)">
            <summary>
            重新设置ID,并且同步到对端
            </summary>
            <param name="id"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.SendFastObject(System.Int16,System.Object)">
            <summary>
            以Fast序列化，发送小（64K）对象。接收方需要将Pos设为2，然后ReadObject即可。
            </summary>
            <param name="protocol"></param>
            <param name="obj"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.SendPackage(System.Int16,TouchSocket.Core.IPackage)">
            <summary>
            以包发送小（64K）对象。接收方需要将Pos设为2，然后ReadPackage即可。
            </summary>
            <param name="protocol"></param>
            <param name="package"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Dispose(System.Boolean)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.Send(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送字节
            </summary>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.RpcActor.SendAsync(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            异步发送字节
            </summary>
            <param name="protocol"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.InvokeOption">
            <summary>
            Rpc调用设置
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.InvokeOption.OnlySend">
            <summary>
            默认设置。
            Timeout=5000ms
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.InvokeOption.WaitInvoke">
            <summary>
            默认设置。
            Timeout=5000ms
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.TouchRpc.InvokeOption.WaitSend">
            <summary>
            默认设置。
            Timeout=5000 ms
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.InvokeOption.#ctor(System.Int32,TouchSocket.Rpc.FeedbackType,TouchSocket.Core.SerializationType,System.Threading.CancellationToken)">
            <summary>
            构造函数
            </summary>
            <param name="timeout"></param>
            <param name="feedbackType"></param>
            <param name="serializationType"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InvokeOption.FeedbackType">
            <summary>
            调用反馈
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InvokeOption.SerializationType">
            <summary>
            TouchRpc序列化类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InvokeOption.Timeout">
            <summary>
            调用超时，
            min=1000，默认5000 ms
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.InvokeOption.Token">
            <summary>
            可以取消的调用令箭
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.DefaultSerializationSelector">
            <summary>
            默认序列化选择器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.DefaultSerializationSelector.DeserializeParameter(TouchSocket.Core.SerializationType,System.Byte[],System.Type)">
            <summary>
            反序列化
            </summary>
            <param name="serializationType"></param>
            <param name="parameterBytes"></param>
            <param name="parameterType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.DefaultSerializationSelector.SerializeParameter(TouchSocket.Core.SerializationType,System.Object)">
            <summary>
            序列化参数
            </summary>
            <param name="serializationType"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.SerializationSelector">
            <summary>
            序列化选择器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.SerializationSelector.SerializeParameter(TouchSocket.Core.SerializationType,System.Object)">
            <summary>
            序列化Rpc方法返回值参数
            </summary>
            <param name="serializationType"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.SerializationSelector.DeserializeParameter(TouchSocket.Core.SerializationType,System.Byte[],System.Type)">
            <summary>
            反序列化传输对象
            </summary>
            <param name="serializationType"></param>
            <param name="parameterBytes"></param>
            <param name="parameterType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext">
            <summary>
            TouchRpc上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.TryCancel">
            <summary>
            当<see cref="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.TokenSource"/>不为空时，调用<see cref="M:System.Threading.CancellationTokenSource.Cancel"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.Caller">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.TokenSource">
            <summary>
            能取消的调用令箭，在客户端主动取消或网络故障时生效
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.TouchRpcPackage">
            <summary>
            TouchRpcContext
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.MethodInstance">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcCallContext.SerializationType">
            <summary>
            序列化类型
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.TouchRpcPackage">
            <summary>
            Rpc传输类
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.Feedback">
            <summary>
            反馈类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.IsByRef">
            <summary>
            参数是否包含引用类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.MethodName">
            <summary>
            函数名
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.ParametersBytes">
            <summary>
            参数数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.ReturnParameterBytes">
            <summary>
            返回参数数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.SerializationType">
            <summary>
            序列化类型
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.PackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.TouchRpcPackage.UnpackageBody(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.UdpCaller">
            <summary>
            Udp调用者
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.UdpCaller.#ctor(TouchSocket.Sockets.UdpSessionBase,System.Net.EndPoint)">
            <summary>
            构造函数
            </summary>
            <param name="service"></param>
            <param name="callerEndPoint"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpCaller.CallerEndPoint">
            <summary>
            调用者终结点
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.UdpCaller.Service">
            <summary>
            Udp服务器
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.StreamInfo">
            <summary>
            流信息
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.TouchRpc.StreamInfo.#ctor(System.Int64,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="size"></param>
            <param name="streamType"></param>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamInfo.Size">
            <summary>
            流长度
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.StreamInfo.StreamType">
            <summary>
            流类型
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.StreamOperator">
            <summary>
            流传输操作器
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.TouchRpc.WaitStream">
            <summary>
            等待流状态返回
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitStream.Size">
            <summary>
            流长度
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitStream.StreamType">
            <summary>
            流类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitStream.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.TouchRpc.WaitStream.ChannelID">
            <summary>
            开启的通道标识
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.OriginAttribute">
            <summary>
            跨域相关设置
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.OriginAttribute.AllowCredentials">
            <summary>
            允许客户端携带验证信息
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.OriginAttribute.AllowMethods">
            <summary>
            允许跨域的方法。
            默认为“PUT,POST,GET,DELETE,OPTIONS,HEAD,PATCH”
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.OriginAttribute.AllowOrigin">
            <summary>
            允许跨域的域名
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.OriginAttribute.Executed(TouchSocket.Rpc.ICallContext,System.Object[],TouchSocket.Rpc.InvokeResult@)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="callContext"></param>
            <param name="parameters"></param>
            <param name="invokeResult"></param>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.RouterAttribute">
            <summary>
            表示WebApi路由。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.RouterAttribute.#ctor(System.String)">
            <summary>
            表示WebApi路由。
            该模板在用于方法时，会覆盖类的使用。
            模板必须由“/”开始，如果没有设置，会自动补齐。
            模板不支持参数约定，仅支持方法路由。
            <para>模板有以下约定：
            <list type="number">
            <item>不区分大小写</item>
            <item>以“[Api]”表示当前类名，如果不包含此字段，则意味着会使用绝对设置</item>
            <item>以“[Action]”表示当前方法名，如果不包含此字段，则意味着会使用绝对设置</item>
            </list>
            </para>
            </summary>
            <param name="routeTemple"></param>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.RouterAttribute.RouteTemple">
            <summary>
            路由模板。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.WebApiAttribute">
            <summary>
            WebApiAttribute
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiAttribute.#ctor(TouchSocket.Rpc.WebApi.HttpMethodType)">
            <summary>
            构造函数。
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiAttribute.GetGenericInterfaceTypes">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiAttribute.Method">
            <summary>
            函数类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiAttribute.GetInvokenKey(TouchSocket.Rpc.MethodInstance)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiAttribute.GetRouteUrls(TouchSocket.Rpc.MethodInstance)">
            <summary>
            获取路由路径。
            <para>路由路径的第一个值会被当做调用值。</para>
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.ActionResult">
            <summary>
            结果状态
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.ActionResult.Status">
            <summary>
            状态类型
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.ActionResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.WebApiCallContext">
            <summary>
            WebApi调用上下文
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiCallContext.Caller">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiCallContext.HttpContext">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiCallContext.MethodInstance">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiCallContext.TokenSource">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.WebApiClient">
            <summary>
            WebApi客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiClient.TryCanInvoke">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiClient.StringConverter">
            <summary>
            字符串转化器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">函数名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">方法名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.RpcException">Rpc异常</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>服务器返回结果</returns>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.HttpMethodType">
            <summary>
            请求函数类型
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.WebApi.HttpMethodType.GET">
            <summary>
            以GET方式。支持调用上下文。
            <para>以该方式时，所有的参数类型必须是基础类型。所有的参数来源均来自url参数。</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Rpc.WebApi.HttpMethodType.POST">
            <summary>
            以Post方式。支持调用上下文。
            <para>以该方式时，可以应对以下情况：</para>
            <list type="bullet">
            <item>仅有一个参数时，该参数可以为任意类型，且参数来源为Body</item>
            <item>当有多个参数时，最后一个参数可以为任意类型，且参数来源为Body，其余参数均必须是基础类型，且来自url参数。</item>
            </list>
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.IHttpCallContext">
            <summary>
            IHttpCallContext
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.IHttpCallContext.HttpContext">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.IWebApiCallContext">
            <summary>
            IWebApiCallContext
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.IWebApiClient">
            <summary>
            IWebApiClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.WebApi.WebApiParserPlugin">
            <summary>
            WebApi解析器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiParserPlugin.#ctor(TouchSocket.Rpc.RpcStore)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiParserPlugin.Converter">
            <summary>
            转化器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiParserPlugin.RouteMap">
            <summary>
            获取路由映射图
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.WebApi.WebApiParserPlugin.RpcStore">
            <summary>
            所属服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiParserPlugin.OnGet(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Rpc.WebApi.WebApiParserPlugin.OnPost(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute">
            <summary>
            适用于XmlRpc的标记
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute.#ctor(System.Boolean)">
            <summary>
             适用于XmlRpc的标记.
             <para>是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。</para>
            </summary>
            <param name="methodInvoke"></param>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute.#ctor(System.String)">
            <summary>
            适用于XmlRpc的标记.
            </summary>
            <param name="invokenKey"></param>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute.MethodInvoke">
            <summary>
            是否仅以函数名调用，当为True是，调用时仅需要传入方法名即可。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute.GetGenericInterfaceTypes">
            <summary>
            <inheritdoc/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcAttribute.GetInvokenKey(TouchSocket.Rpc.MethodInstance)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="methodInstance"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcCallContext.HttpContext">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.XmlRpc.XmlRpcClient">
            <summary>
            XmlRpc客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcClient.TryCanInvoke">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[]@,System.Type[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <param name="types"></param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.Invoke(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.Invoke``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            Rpc调用
            </summary>
            <param name="method">方法名</param>
            <param name="invokeOption">调用配置</param>
            <param name="parameters">参数</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.InvokeAsync(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">函数名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException"></exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcClient.InvokeAsync``1(System.String,TouchSocket.Rpc.IInvokeOption,System.Object[])">
            <summary>
            函数式调用
            </summary>
            <param name="method">方法名</param>
            <param name="parameters">参数</param>
            <param name="invokeOption">Rpc调用设置</param>
            <exception cref="T:System.TimeoutException">调用超时</exception>
            <exception cref="T:TouchSocket.Rpc.TouchRpc.RpcSerializationException">序列化异常</exception>
            <exception cref="T:TouchSocket.Rpc.RpcInvokeException">Rpc异常</exception>
            <exception cref="T:System.Exception">其他异常</exception>
            <returns>服务器返回结果</returns>
        </member>
        <member name="T:TouchSocket.Rpc.XmlRpc.IXmlRpcCallContext">
            <summary>
            IXmlRpcCallContext
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.IXmlRpcCallContext.XmlString">
            <summary>
            XmlRpc的调用字符串。
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.XmlRpc.IXmlRpcClient">
            <summary>
            IWebApiClient
            </summary>
        </member>
        <member name="T:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin">
            <summary>
            XmlRpc解析器
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.#ctor(TouchSocket.Rpc.RpcStore)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.ActionMap">
            <summary>
            XmlRpc调用
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.RpcStore">
            <summary>
            所属服务器
            </summary>
        </member>
        <member name="P:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.XmlRpcUrl">
            <summary>
            当挂载在<see cref="T:TouchSocket.Http.HttpService"/>时，匹配Url然后响应。当设置为null或空时，会全部响应。
            </summary>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.SetXmlRpcUrl(System.String)">
            <summary>
            当挂载在<see cref="T:TouchSocket.Http.HttpService"/>时，匹配Url然后响应。当设置为null或空时，会全部响应。
            </summary>
            <param name="xmlRpcUrl"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Rpc.XmlRpc.XmlRpcParserPlugin.OnPost(TouchSocket.Sockets.ITcpClientBase,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:HttpContextEventHandler`1">
            <summary>
            HTTP上下文事件委托
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:MessageEventHandler`1">
            <summary>
            显示信息
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocketEventHandler`1">
            <summary>
            普通通知
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:IDChangedEventHandler`1">
            <summary>
            ID修改通知
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:ConnectingEventHandler`1">
            <summary>
            Connecting
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:DisconnectEventHandler`1">
            <summary>
            客户端断开连接
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:OperationEventHandler`1">
            <summary>
            正在连接事件
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:PluginReceivedEventHandler`1">
            <summary>
            插件数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:ReceivedEventHandler`1">
            <summary>
            普通数据
            </summary>
            <param name="client"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
        <member name="T:UdpReceivedEventHandler">
            <summary>
            UDP接收
            </summary>
            <param name="endpoint"></param>
            <param name="byteBlock"></param>
            <param name="requestInfo"></param>
        </member>
    </members>
</doc>
